{"version":3,"file":"js/app.ddeb7678.js","mappings":"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","sources":["webpack://teaching_web_app/./src/App.vue","webpack://teaching_web_app/./src/App.vue?7ccd","webpack://teaching_web_app/./src/views/InstrumentalInteraTableView.vue","webpack://teaching_web_app/./src/components/canvas/instrumental-interaction-demo/ReificationDemo.vue","webpack://teaching_web_app/./src/components/canvas/instrumental-interaction-demo/ReificationDemo.vue?c4f5","webpack://teaching_web_app/./src/components/canvas/instrumental-interaction-demo/ReuseDemo.vue","webpack://teaching_web_app/./src/components/interactive-components-for-canvas/ContextMenu.vue","webpack://teaching_web_app/./src/components/interactive-components-for-canvas/ContextMenu.vue?83a1","webpack://teaching_web_app/./src/components/canvas/instrumental-interaction-demo/ReuseDemo.vue?2ada","webpack://teaching_web_app/./src/components/canvas/instrumental-interaction-demo/PolymorphismDemo.vue","webpack://teaching_web_app/./src/components/canvas/instrumental-interaction-demo/PolymorphismDemo.vue?4366","webpack://teaching_web_app/./src/components/canvas/instrumental-interaction-demo/PolymorphismSubstrateDemo.vue","webpack://teaching_web_app/./src/components/canvas/instrumental-interaction-demo/PolymorphismSubstrateDemo.vue?f19c","webpack://teaching_web_app/./src/components/canvas/instrumental-interaction-demo/ReuseSubstrateDemo.vue","webpack://teaching_web_app/./src/components/canvas/instrumental-interaction-demo/ReuseSubstrateDemo.vue?5f25","webpack://teaching_web_app/./src/components/canvas/instrumental-interaction-demo/ReificationSubstrateDemo.vue","webpack://teaching_web_app/./src/components/canvas/instrumental-interaction-demo/ReificationSubstrateDemo.vue?e5dc","webpack://teaching_web_app/./src/components/interactive-components-for-canvas/NarativeBox.vue","webpack://teaching_web_app/./src/components/interactive-components-for-canvas/NarativeBox.vue?4ff8","webpack://teaching_web_app/./src/views/InstrumentalInteraTableView.vue?8f72","webpack://teaching_web_app/./src/views/HCPartnershipsTableView.vue","webpack://teaching_web_app/./src/components/canvas/hc-partnerships-demo/AppropriabilityDemo.vue","webpack://teaching_web_app/./src/components/canvas/hc-partnerships-demo/AppropriabilityDemo.vue?30c8","webpack://teaching_web_app/./src/components/canvas/hc-partnerships-demo/AppropriabilitySubstrateDemo.vue","webpack://teaching_web_app/./src/components/interactive-components-for-canvas/CenterMenu.vue","webpack://teaching_web_app/./src/components/interactive-components-for-canvas/CenterMenu.vue?2608","webpack://teaching_web_app/./src/components/canvas/hc-partnerships-demo/AppropriabilitySubstrateDemo.vue?a295","webpack://teaching_web_app/./src/components/canvas/hc-partnerships-demo/DiscoverabilitySubstrateDemo.vue","webpack://teaching_web_app/./src/components/canvas/hc-partnerships-demo/DiscoverabilitySubstrateDemo.vue?78c7","webpack://teaching_web_app/./src/components/canvas/hc-partnerships-demo/DiscoverabilityDemo.vue","webpack://teaching_web_app/./src/components/canvas/hc-partnerships-demo/DiscoverabilityDemo.vue?708b","webpack://teaching_web_app/./src/components/canvas/hc-partnerships-demo/ExpressivityDemo.vue","webpack://teaching_web_app/./src/components/canvas/hc-partnerships-demo/ExpressivityDemo.vue?cbbd","webpack://teaching_web_app/./src/components/canvas/hc-partnerships-demo/ExpressivitySubstrateDemo.vue","webpack://teaching_web_app/./src/components/canvas/hc-partnerships-demo/ExpressivitySubstrateDemo.vue?395f","webpack://teaching_web_app/./src/views/HCPartnershipsTableView.vue?7773","webpack://teaching_web_app/./src/components/canvas/PlayGround.vue","webpack://teaching_web_app/./src/components/interactive-components-for-canvas/ToolBar.vue","webpack://teaching_web_app/./src/components/interactive-components-for-canvas/ToolBar.vue?a597","webpack://teaching_web_app/./src/components/canvas/PlayGround.vue?56ce","webpack://teaching_web_app/./src/views/IntroductionView.vue","webpack://teaching_web_app/./src/components/canvas/classic-demo/BasicAlignmentDemo.vue","webpack://teaching_web_app/./src/components/canvas/classic-demo/BasicAlignmentDemo.vue?7424","webpack://teaching_web_app/./src/views/IntroductionView.vue?24e8","webpack://teaching_web_app/./src/router/index.js","webpack://teaching_web_app/./src/main.js","webpack://teaching_web_app/webpack/bootstrap","webpack://teaching_web_app/webpack/runtime/chunk loaded","webpack://teaching_web_app/webpack/runtime/compat get default export","webpack://teaching_web_app/webpack/runtime/define property getters","webpack://teaching_web_app/webpack/runtime/ensure chunk","webpack://teaching_web_app/webpack/runtime/get javascript chunk filename","webpack://teaching_web_app/webpack/runtime/get mini-css chunk filename","webpack://teaching_web_app/webpack/runtime/global","webpack://teaching_web_app/webpack/runtime/hasOwnProperty shorthand","webpack://teaching_web_app/webpack/runtime/load script","webpack://teaching_web_app/webpack/runtime/make namespace object","webpack://teaching_web_app/webpack/runtime/publicPath","webpack://teaching_web_app/webpack/runtime/css loading","webpack://teaching_web_app/webpack/runtime/jsonp chunk loading","webpack://teaching_web_app/webpack/startup"],"sourcesContent":["<template>\n  <nav id=\"main_menu\" :style=\"style\">\n    <router-link to=\"/\">Introduction</router-link> \n    <router-link to=\"/instrumentalinteractiontable\">Instrumental Interaction Overview</router-link> \n    <router-link to=\"/hc-partnerships-table\">Human-Computer Partnerships Overview</router-link> \n    <router-link to=\"/playground\">Playground</router-link>\n    <router-link to=\"/about\">About</router-link> \n  </nav>\n  <router-view/>\n  \n  <div id=\"menu_button\">\n  <img id=\"button_image\" width=80 src=\"@/assets/exsitu-minus.png\"  @click=\"closeMenu\">\n  </div>\n</template>\n<script>\n\nexport default {\n  data(){\n    return{\n          style: {\n              '--height': '35px',\n              \n          }\n    }\n  },\n    methods:{\n      openMenu(){\n\n},\n        closeMenu(){\n          console.log(document.getElementById(\"button_image\").src)\n          if(JSON.stringify(this.style)!='{\"--height\":\"35px\"}'){\n            this.style={'--height': '35px'}\n            document.getElementById(\"button_image\").src=require(\"@/assets/exsitu-minus.png\")\n          }else{\n            this.style={'--height': '0px'}\n            document.getElementById(\"button_image\").src=require(\"@/assets/exsitu-plus.png\")\n          }\n        }\n        \n        \n    }\n}\n</script>\n\n<style>\n#main_menu{\n  height: var(--height); \n  width: 100%; /* 0 width - change this with JavaScript */\n  position: fixed; /* Stay in place */\n  z-index: 1; /* Stay on top */\n  top: 0;\n  left: 0;\n  background-color: blueviolet; /* Black*/\n  overflow-x: hidden; /* Disable horizontal scroll */\n  overflow-y: hidden; /* Disable horizontal scroll */\n  padding-top: 0px; /* Place content 60px from the top */\n  transition: 0.5s; /* 0.5 second transition effect to slide in the sidenav */\n  z-index: 1;\n}\n#menu_button{\n  position: fixed;\n  top:0;\n  left:calc(100% - 80px);\n  width:80px;\n  z-index: 2;\n}\n#app {\n  padding: 50px 20px;\n  \n  font-family: Avenir, Helvetica, Arial, sans-serif;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  text-align: center;\n  color: #2c3e50;\n}\n\nnav {\n  /*padding: 30px;*/\n  list-style-type: none;\n  margin: 0;\n  padding: 0;\n  overflow: hidden;\n\n}\nnav a {\n  display: block;\n  float: left;\n  color: white;\n  text-align: center;\n  padding: 10px 16px;\n  text-decoration: none;\n}\n\nnav a.router-link-exact-active {\n  color: #ffffff;\n  background-color: rgb(105, 33, 173);\n}\n</style>\n","import { render } from \"./App.vue?vue&type=template&id=6658d6ec\"\nimport script from \"./App.vue?vue&type=script&lang=js\"\nexport * from \"./App.vue?vue&type=script&lang=js\"\n\nimport \"./App.vue?vue&type=style&index=0&id=6658d6ec&lang=css\"\n\nimport exportComponent from \"/Users/junhangyu/Desktop/PE code/github/teachingApp/node_modules/vue-loader/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render]])\n\nexport default __exports__","<template>\n   <!--Instrumental Interaction overview-->\n  <div class=\"instrumentalInteractionTable\" style=\"display:table\">\n  <div style=\"display:table-cell\">\n    <table>\n      <tr>\n        <th></th>\n        <th>Reification</th>\n        <th>Polymorphism</th>\n        <th>Reuse</th>\n      </tr>\n      <tr>\n        <th>Instrument (Input)</th>\n        <td>\n          <div id=\"reificationdemo\">\n          <ReificationDemo :height=\"height\" :width=\"width\" @explain=\"addExplanation\"></ReificationDemo>\n          </div>\n          <p class=\"caption\">Use Stickyline to align the shapes</p>\n        </td>\n        <td>\n          <div id=\"polymorphismdemo\">\n          <PolymorphismDemo :height=\"height\" :width=\"width\" @explain=\"addExplanation\"></PolymorphismDemo>\n          </div>\n          <p class=\"caption\">Use Stickyline to align shapes, text, and even pictures</p>\n        </td>\n        <td>\n          <div id=\"reusedemo\">\n          <ReuseDemo :height=\"height\" :width=\"width\" @explain=\"addExplanation\"></ReuseDemo>\n          </div>\n          <p class=\"caption\">Reuse Stickyline to align another group of objects (right-click,copy and paste)</p>\n        </td>\n      </tr>\n      <tr>\n        <th>Substrate (Output)</th>\n        <td>\n          <div id=\"reificationSubstrateDemo\">\n          <ReificationSubstrateDemo :height=\"height\" :width=\"width\" @explain=\"addExplanation\"></ReificationSubstrateDemo>\n          </div>\n          <p class=\"caption\">Use Stickyline to move the aligned objects together</p>\n        </td>\n        <td>\n          <div id=\"polymorphismSubstrateDemo\">\n          <PolymorphismSubstrateDemo :height=\"height\" :width=\"width\" @explain=\"addExplanation\"></PolymorphismSubstrateDemo>\n          </div>\n          <p class=\"caption\">Stickyline preserves both alignment and distribution</p>\n        </td>\n        <td>\n          <div id=\"reuseSubstrateDemo\" >\n          <ReuseSubstrateDemo :height=\"height\" :width=\"width\" @explain=\"addExplanation\"></ReuseSubstrateDemo>\n          </div>\n          <p class=\"caption\">Reuse Stickyline to duplicate the aligned objects (right-click,copy and paste)</p>\n        </td>\n      </tr>\n    </table>\n  </div>\n  \n  <div id=\"narationBox\" style='display:table-cell'>\n  <NarativeBox class=\"narativeBox\" :texts-for-naration=\"naration\" ></NarativeBox>\n  </div>\n  </div>\n</template>\n\n<script>\n// @ is an alias to /src\nimport ReificationDemo from '@/components/canvas/instrumental-interaction-demo/ReificationDemo.vue'\nimport ReuseDemo from '@/components/canvas/instrumental-interaction-demo/ReuseDemo.vue'\nimport PolymorphismDemo from '@/components/canvas/instrumental-interaction-demo/PolymorphismDemo.vue'\nimport PolymorphismSubstrateDemo from '@/components/canvas/instrumental-interaction-demo/PolymorphismSubstrateDemo.vue'\nimport ReuseSubstrateDemo from '@/components/canvas/instrumental-interaction-demo/ReuseSubstrateDemo.vue'\nimport ReificationSubstrateDemo from '@/components/canvas/instrumental-interaction-demo/ReificationSubstrateDemo.vue'\nimport NarativeBox from '@/components/interactive-components-for-canvas/NarativeBox.vue'\n\n\nexport default {\n  name: 'InstrumentalInteractionTableView',\n  components: {\n    ReificationDemo,\n    ReuseDemo,\n    PolymorphismDemo,\n    PolymorphismSubstrateDemo,\n    ReuseSubstrateDemo,\n    ReificationSubstrateDemo,\n    NarativeBox,\n  },\n  created() {\n        this.width = 300;\n        this.height = 260;\n  },\n  updated(){\n    let elem = document.getElementsByClassName(\"narativeBox\")[0]\n    elem.scrollTop=elem.scrollHeight\n  },\n  data(){\n    return{\n      naration:[],\n      last_origin:'',\n      last_text:'',\n    }\n  },\n  methods:{\n    addExplanation(e){\n      let text=e.text\n      if(e.origin!=this.last_origin){\n        this.last_origin=e.origin;\n        this.last_text=text\n        this.naration.splice(0,this.naration.length)\n        this.naration.push(e.origin+\" :<br>\",)\n        \n      this.naration.push(text,);\n      }else if(text!=this.last_text){\n      this.naration.push(\"***\",)\n      this.naration.push(text,);\n      this.last_text=text\n      }\n      let elem = document.getElementsByClassName(\"narativeBox\")[0]\n      \n      elem.scrollTop=elem.scrollHeight\n    },\n  }\n}\n</script>\n\n<style>\ntable, th, td {\n  border: 1px solid black;\n  border-collapse: collapse;\n}\n.caption{\n  width: 300px;\n  height:20px\n}\n</style>\n","<template>\n\n<div @click=\"HideContextMenu\" id=\"playground\"\n    @mousedown=\"updateNaration(this.groups[0])\">\n<!--\n  <ToolBar :height=\"100\" :width=\"400\"\n  @need_new_shape=\"createNewShape\" @eraser_is_selected=\"switchEraseMode\"></ToolBar>\n  -->\n  <v-stage\n    ref=\"stage\"\n    id=\"stage\"\n    :config=\"stageSize\"\n    @dragmove=\"update\"\n    @mousedown=\"handleTransformation\"\n    @touchstart=\"handleTransformation\"\n    @fusion=\"makeGroup\"\n    @contextMenu=\"DisplayContextMenu\"\n  >\n    <v-layer ref=\"layer\">\n      <!--\n        see if a group should contain more than one line\n      -->\n      <!--\n      <v-circle :key=\"center.id\" :config=\"center\"/>\n      -->\n      <v-group ref=\"groups\" v-for=\"step in groups\" :key=\"step.id\" :config=\"step\">\n      \n      \n      \n        <v-rect\n        v-for=\"item in step.shapes_g.filter(i=>i.className=='Rect')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        \n       \n        @transformend=\"updateTransformedShape\"\n        @dragend= \"updatePosInGrp($event,step.id) \"\n        @dragmove=\"CheckIfNeedToDetach\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n      />\n      <v-circle\n        v-for=\"item in step.shapes_g.filter(i=>i.className=='Circle')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragend=\"updatePosInGrp($event,step.id)\"\n        @dragmove=\"CheckIfNeedToDetach\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n      />\n      \n      <v-image\n        v-for=\"item in step.shapes_g.filter(i=>i.className=='Image')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragend=\"updatePosInGrp($event,step.id)\"\n        @dragmove=\"CheckIfNeedToDetach\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n      />\n        <v-regular-polygon\n        v-for=\"item in step.shapes_g.filter(i=>i.className=='Triangle')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragend=\"updatePosInGrp($event,step.id)\"\n        @dragmove=\"CheckIfNeedToDetach\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n      />\n        <v-line \n        :key=\"step.line.id\"\n        :config=\"step.line\"\n        @transformend=\"updateTransformedShape\"\n        @dragmove=\"updateGrp($event,step.id)\"\n        @mouseout=\"unshowSelectedShape\"\n        @mouseenter=\"showSelectedShape\"\n        />\n    <v-circle\n        v-for=\"item in step.line.positionPoints\"\n        :key=\"item.id\"\n        :config=\"item\"\n        \n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n      />\n      </v-group>\n      <v-rect\n        v-for=\"item in shapes.filter(i=>i.className=='Rect')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragmove=\"updatePos\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n        \n      />\n      \n      <v-circle\n        v-for=\"item in shapes.filter(i=>i.className=='Circle')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragmove=\"updatePos\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n        \n      />\n      <!--\n      <v-image\n        v-for=\"item in shapes.filter(i=>i.className=='Image')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragmove=\"updatePos\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n        />\n     \n      <v-text\n        v-for=\"item in shapes.filter(i=>i.className=='Text')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragmove=\"updatePos\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n        \n        @dblclick=\"editText\"\n        /> \n      -->\n      <v-regular-polygon\n        v-for=\"item in shapes.filter(i=>i.className=='Triangle')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragmove=\"updatePos\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n        />\n      \n      \n      <v-transformer  v-for=\"item in transformers\" :key=\"item.id\" :config=\"item\"/>\n      <v-circle :key=\"center.id\" :config=\"center\"\n      @dragend=\"ChangeCenter\"\n      @click=\"DisplayCenterMenu\"/>\n      <!--\n      <v-transformer id=\"shapeTransformer\"/>\n      <v-transformer id=\"lineTransformer\" :config=\"{enabledAnchors: ['middle-left', 'middle-right'],}\" />\n      -->\n    </v-layer>\n    \n  </v-stage>\n  \n  <!--\n  <div id=\"active\">\n  <ContextMenu :menu-of-stage=\"isStageOnlySelected\" :menu-of-line=isALineSelected :menu-of-grouped-shape=isAGroupedShapeSelected :keep-distance-button-text=\"this.keepDistanceButtonText\" \n  @changecenter-button=\"ChangeCenterButtonAction\" @detachshape-button=\"DetachShapeButtonAction\" @keepdistance-button=\"KeepDistribution\"\n  @copy-button=\"Copy\" @copy-all-button=\"CopyAll\" @past-button=\"Past\" @remove-button=\"Remove\" @remove-all-button=\"RemoveAll\"></ContextMenu>\n  </div>\n  <div id=\"center_menu\">\n  <CenterMenu :defaultAlignment=\"this.selectedShapeAlignment\" @center-button=\"ChangeAlignCenter\"></CenterMenu>\n  </div>\n  -->\n  \n  \n  </div>\n</template>\n\n<script>\n\n//import ContextMenu from \"./ContextMenu.vue\"\n//import CenterMenu from \"./CenterMenu.vue\"\n//import ToolBar from \"./ToolBar.vue\";\n\n\nconst dragFunc=function (pos) {\n  let width=this.getStage().width();\n  let height=this.getStage().height();\n  let strokeSize=10\n    if(pos.x>width-strokeSize && pos.y>height-strokeSize){\n      return{\n        x: width-strokeSize,\n        y: height-strokeSize,\n      }\n    } else if(pos.x>width-strokeSize && pos.y<strokeSize){\n      return{\n        x: width-strokeSize,\n        y: strokeSize,\n      }\n    } else if(pos.y>height-strokeSize && pos.x<strokeSize){\n      return{\n        x: strokeSize,\n        y: height-strokeSize,\n      }\n    } else if(pos.x<strokeSize && pos.y<strokeSize){\n      return{\n        x: strokeSize,\n        y: strokeSize,\n      }\n    } else if(pos.x<strokeSize){\n      return{\n        x: strokeSize,\n        y: pos.y,\n      }\n    }else if(pos.y<strokeSize){\n      return{\n        x: pos.x,\n        y: strokeSize,\n      }\n    }else if(pos.x>width-strokeSize){\n      return{\n        x: width-strokeSize,\n        y: pos.y,\n      }\n    }else if(pos.y>height-strokeSize){\n      return{\n        x: pos.x,\n        y: height-strokeSize,\n      }\n    } else{\n      return {\n        x: pos.x,\n        y: pos.y,\n      };\n    }\n};\n\n\nexport default {\n  props:{\n    width:{\n      type: Number,\n      default:window.innerWidth,\n    },\n    height:{\n      type: Number,\n      default:window.innerHeight,\n    }\n  },\n  components:{\n    //ContextMenu,\n    //CenterMenu,\n    //ToolBar,\n},\n  data() {\n    return {\n      stageSize: {\n        width: this.width,\n        height: this.height,\n      },\n      lengthToCapture:10,\n      lengthToDetach:15,\n      editedText:null,\n\n      eraseMode:0,\n\n      selectedShapeAlignment:'',\n      \n      needMenu: 'initial', //say if the context menu has to be \"active\" or not.\n      isALineSelected:false, \n      isAGroupedShapeSelected:false,\n      isStageOnlySelected: false,\n      //dragItemId: null, //id of the item which is dragging.\n      //text which will appear on the button corresponding to the management of the distribution\n      keepDistanceButtonText:\"Liberate Distribution\",\n      max_id_figures: 6, //max among id of shapes and line since the canvas exist (line excluded) \n      //max_id_lines: 2, //max among id of lines since the canvas exist (line excluded) \n      //groups of shapes (ie a line with shapes on it)\n      groups:[{\n        //rotation: 20,\n        name: \"group\",\n        className: \"Group\",\n        id: '6',\n        x:0,\n        y:0,\n        offsetX:0,\n        offsetY:0,\n        rotation: 0,\n        draggable: false,\n        shapes_g:[], //list of shapes that are on the line\n        //the line of the group:\n        aShapeHasBeenDetach:0,\n        line:{\n          x:150,\n          y:250,\n          points: [0, 0, 0, 0, 250, 0],\n          positionPoints:[],\n          strokeWidth: 10,\n          rotation: 0,\n          tension:0,\n          closed: true,\n          draggable: true,\n          scaleX:1,\n          scaleY:1,\n          opacity:0.5,\n          offset:{\n            x:125,\n            y:0,\n          },\n          name: \"ligne\",\n          className: \"Line\",\n          stroke: 'red',\n          id:'6',\n          //distShapesToCenter:[],\n          keepDistribution: false, //say of we keep the distribution on the line or not\n          freeDistances:[], // distance that can be taken by other shapes (if we keep distribution on the line).\n          occupiedDistances:[], //distance already \"taken\" by shapes on the line.       \n          //text which will appear on the button corresponding to the management of the distribution:\n          keepDistanceButtonText:\"Liberate Distribution\",\n          //function which determine how the line can be dragged:\n          defaultAlignment:\"Bottom\",\n          dragBoundFunc: dragFunc,\n        },\n      },\n      /*{\n        name: \"group2\",\n        className: \"Group\",\n        id: '7',\n        x:0,\n        y:0,\n        offsetX:0,\n        offsetY:0,\n        rotation: 0,\n        draggable: false,\n        shapes_g:[],\n        line:{\n        x:500,\n        y:300,\n        points: [0, 0, 0, 0, 300, 0],\n        positionPoints:[],\n        strokeWidth: 10,\n        rotation: 0,\n        tension:0,\n        closed: true,\n        draggable: true,\n        scaleX:1,\n        scaleY:1,\n        opacity:0.5,\n        offset:{\n          x:150,\n          y:0,\n        },\n        //draggable:true,\n        name: \"ligne\",\n        className: \"Line\",\n        stroke: 'black',\n        id:'7',\n        distShapesToCenter:[],\n        keepDistribution: true,\n        freeDistances:[],\n        occupiedDistances:[],\n        keepDistanceButtonText:\"Liberate Distribution\",\n        defaultAlignment:\"Middle\",\n        dragBoundFunc: dragFunc,\n      },\n      \n      }*/\n      ],\n      transformers:[\n        {\n          id: 'lineTransformer',\n          enabledAnchors: [],\n          rotateEnabled: false,\n          borderEnabled:false,\n          flipEnabled: false, // in order to not have a rotation of the transformer which lead to problem related to shapes position on a line\n          nodes: [],\n\n        },\n        {\n          id: 'shapeTransformer',\n          nodes: [],\n        }\n      ],\n      shapes: [\n        /*\n        {\n          rotation: 0,\n          id: '1',\n          x: 100,\n          y: 10,\n          width: 130,\n          height: 100,\n          scaleX: 1,\n          scaleY: 1,\n          strokeWidth: 0,\n          stroke: 'black',\n          fill: 'red',\n          name: 'rect1',\n          draggable: true,\n          className:\"Rect\",\n          isGrouped: 0, //if =0 the shape is not attached to a stickyline. if=1, it does.\n          offsetX:130/2,\n          offsetY:0,\n          personalRotation:0, \n          centerPosition:'Top',\n          dragBoundFunc: dragFunc\n          \n        },\n        */\n        \n        {\n          rotation: 0,\n          id:'2',\n          x: 150,\n          y: 210,\n          width: 70,\n          height: 70,\n          scaleX: 1,\n          scaleY: 1,\n          strokeWidth: 0,\n          stroke: 'black',\n          fill: 'green',\n          name: 'rect2',\n          draggable: true,\n          className:\"Rect\",\n          isGrouped: 0,\n          dragBoundFunc: dragFunc,\n          offsetX: 70/2,\n          offsetY: 70,\n          /*When it is on a line, a shape can be rotate by the user independently from the line.\n          To keep the independant rotation of the attached shape, we add the parameter \"personalRotation\".\n          So, when the shape is attached, is final rotation is the sum of this parameter with the rotation of the line.\n          */\n          personalRotation:0, \n          centerPosition:'Bottom',\n        },\n        {\n        rotation:0,\n        x: 50,\n        y: 100,\n        scaleX:1,\n        scaleY:1,\n        offsetX: 0,\n        offsetY: 40,\n        radius: 40,\n        fill: 'orange',\n        strokeWidth: 0,\n        stroke: 'black',\n        draggable:true,\n        isGrouped: 0,\n        className:\"Circle\",\n        /*When it is on a line, a shape can be rotate by the user independently from the line.\n          To keep the independant rotation of the attached shape, we add the parameter \"personalRotation\".\n          So, when the shape is attached, is final rotation is the sum of this parameter with the rotation of the line.\n          */\n        personalRotation:0, \n        id:'3',\n        dragBoundFunc: dragFunc,\n        centerPosition:'Bottom',\n      },\n      /*\n        {\n            text: 'A text',\n            rotation: 0,\n            x: 400,\n            y: 200,           \n            scaleX:1,\n            scaleY:1,\n            offsetY:0,\n            offsetX: 36,\n            length_x:72,\n            length_y:30,\n            draggable: true,\n            isGrouped: 0,\n            className:\"Text\",    \n            fontSize: 30,\n            fontFamily: 'Calibri',\n          personalRotation:0,\n            id:'4',\n            dragBoundFunc:dragFunc,\n            centerPosition:'Top',\n        },\n        {\n            rotation: 0,\n            x: 700,\n            y: 400,           \n            scaleX:1,\n            scaleY:1,\n            offsetY:0,\n            offsetX:0,\n            //width:72,\n            //height:30,\n            image: null,\n            draggable: true,\n            isGrouped: 0,\n            className:\"Image\", \n               \n            fontSize: 30,\n          personalRotation:0, \n            id:'5',\n            dragBoundFunc:dragFunc,\n            centerPosition:'Top',\n        },\n        */\n         {\n          rotation: 0,\n          id:'8',\n          x: 250,\n          y: 100,\n          sides:3,\n          radius:45,\n          width: 90,\n          height: 90,\n          scaleX: 1,\n          scaleY: 1,\n          strokeWidth: 0,\n          stroke: 'black',\n          fill: 'purple',\n          name: 'triangle1',\n          draggable: true,\n          className:\"Triangle\",\n          isGrouped: 0,\n          dragBoundFunc: dragFunc,\n          offsetX: 0,\n          offsetY: 22.5,\n          personalRotation:0, \n          centerPosition:'Bottom',\n        },\n      ],\n      center:{\n        x: 300,\n        y: 500,\n        scaleX:1,\n        scaleY:1,\n        offsetX: 0,\n        offsetY: 0,\n        radius: 4,\n        fill: 'black',\n        opacity:1,\n        draggable:true,\n        isGrouped: 0,\n        className:\"Circle\",\n        id:'center',\n        dragBoundFunc:dragFunc,\n      },\n      positionPoint:{\n        x: 300,\n        y: 500,\n        scaleX:1,\n        scaleY:1,\n        offsetX: 0,\n        offsetY: 0,\n        radius: 3,\n        fill: 'yellow',\n        opacity:1,\n        draggable:false,\n        isGrouped: 0,\n        className:\"positionPoint\",\n        id:'positionPoint',\n        distance_to_line_center:undefined,\n      },\n      selectedShapeId: '',\n    };\n  },\n  mounted(){\n    let texts=this.$refs.stage.getStage().getChildren()[0].getChildren().filter((r)=>r.attrs.className=='Text');\n    \n    \n    for(let i=0;i<texts.length;i++){\n      texts[i].attrs.length_x=texts[i].width();\n      texts[i].attrs.length_y=texts[i].height();\n      texts[i].offsetX(texts[i].attrs.length_x/2);\n    }\n  },\n  created(){\n    //nb of shapes on the canvas (line excluded), we consider that there is no shape on line:\n    this.max_id_figures=this.shapes.length +this.groups.length; \n    //this.max_id_lines=this.groups.length;\n    /*\n    const image = new window.Image();\n    image.src = require(\"@/assets/exsitu.png\");\n    // set image only when it is loaded\n    image.height=150;\n    image.width=150;\n    image.onload = () => {\n      this.shapes.find((r)=>r.className===\"Image\").image= image;\n      this.shapes.find((r)=>r.className===\"Image\").offsetX=image.width/2;\n      this.shapes.find((r)=>r.className===\"Image\").offsetY=0; \n    };\n    */\n  },\n  methods: {\n\n    switchEraseMode(){\n      if(this.eraseMode==0){\n        this.eraseMode=1;\n        document.getElementById(\"playground\").style.cursor='url('+require('@/assets/ugly_eraser.png')+'),default';\n        \n      this.eraseNodefromTransformer(\"shapeTransformer\");\n      this.eraseNodefromTransformer(\"lineTransformer\");\n      } else{\n        this.eraseMode=0;\n        document.getElementById(\"playground\").style.cursor=\"default\";\n      }\n    },\n    /*\n    Check if all shapes that are supposed to be on a line still in this line.\n    id_grp is the id of the group which contains the line.\n    */\n    checkIfShapesOnLine(id_grp){\n      const grp= this.groups.find((r) => r.id===id_grp);\n      const line=grp.line;\n      const groupedShapes = grp.shapes_g;\n      //const lengthToDetach=10;\n      \n      /*\n      To determine if a shape is on a line, we see if the point is not on the corresponding\n      straight line y=a*x+b regarding certains intervals for x and y.Those intervals depends of the rotation of\n      the line. \n      */\n     /*\n      let coord_y1=line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x1=line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let coord_y2= line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x2=line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let a=(coord_y1-coord_y2)/(coord_x2-coord_x1);\n      let b=line.y-a*line.x;\n      let is_on_straight_line=false;\n      */\n      \n      let i=0;\n      while(i<groupedShapes.length){\n        /*\n        if(Math.abs(coord_x1-coord_x2)>1){\n        is_on_straight_line=(Math.abs(a*groupedShapes[i].x+b-groupedShapes[i].y)<this.lengthToDetach);\n      }else{\n        is_on_straight_line=(Math.abs(groupedShapes[i].x-line.x)<this.lengthToDetach);\n      }\n        if (\n          !(is_on_straight_line)\n        ||((line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].y\n        ||line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].y)\n        && ((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n        ||((line.x+line.points[4]*line.scaleX*(1/2)*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].x\n        ||line.x-line.points[4]*line.scaleX*(1/2)*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].x)\n        &&((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n        ||((line.y+line.points[4]*line.scaleX*(1/2)*Math.sin(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].y\n        ||line.y-line.points[4]*line.scaleX*(1/2)*Math.sin(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].y)\n        &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>=-Math.PI)))\n\n        ||((line.x+line.points[4]*line.scaleX*(1/2)*Math.cos(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].x\n        ||line.x-line.points[4]*line.scaleX*(1/2)*Math.cos(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].x)\n        &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>=-Math.PI)))\n\n        ||((line.y+line.points[4]*line.scaleX*(1/2)*Math.sin(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].y\n        ||line.y-line.points[4]*line.scaleX*(1/2)*Math.sin(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].y)\n        &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n        ||((line.x+line.points[4]*line.scaleX*(1/2)*Math.cos(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].x\n        ||line.x-line.points[4]*line.scaleX*(1/2)*Math.cos(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].x)\n        &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n        ||((line.y+line.points[4]*line.scaleX*(1/2)*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].y\n        ||line.y-line.points[4]*line.scaleX*(1/2)*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].y)\n        &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>0)))\n\n        ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].x\n        ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].x)\n        &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>0)))\n        )\n        */\n       if(!this.isCoordinateOnLine(groupedShapes[i].x,groupedShapes[i].y,line.id)){\n          console.log(\"a shape is not on a line\");\n          groupedShapes[i].dragBoundFunc= dragFunc;\n          groupedShapes[i].isGrouped=0;\n          line.positionPoints.splice(i,1)\n          \n          this.shapes.push(groupedShapes[i],)\n          line.freeDistances.push(line.occupiedDistances[i]);\n          line.occupiedDistances.splice(i,1);\n          groupedShapes.splice(i,1);\n          this.updateNaration(grp)\n        }else{\n          i=i+1;\n        }\n      }\n    },\n\n    //say of {x,y} is a point from the line\n    isCoordinateOnLine(x,y,id_grp){\n      const grp=this.groups.find((r) => r.id===id_grp);\n      const line=grp.line;\n      let is_not_on_straight_line=true;\n      let coord_y1=line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x1=line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let coord_y2= line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x2=line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let a=(coord_y1-coord_y2)/(coord_x2-coord_x1);\n      let b=line.y-a*line.x;\n      if(Math.abs(coord_x1-coord_x2)>1){\n        is_not_on_straight_line=(Math.abs(a*x+b-y)>1);\n      }else{\n        is_not_on_straight_line=(Math.abs(x-line.x)>1)\n      }\n      if(\n        (is_not_on_straight_line)\n\n      ||((line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<y\n      ||line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>y)\n      && ((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<x\n        ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>x)\n      &&((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<y\n        ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>y)\n      &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>-Math.PI)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>x)\n      &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>-Math.PI)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>y)\n      &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>x)\n      &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>y)\n      &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>=0)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>x)\n      &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>=0)))\n\n      ||(!is_not_on_straight_line && Math.sqrt((line.x-x)**2+(line.y-y)**2)>line.points[4]*line.scaleX/2)\n\n      )\n      {\n        return false; \n      } else{\n        return true;\n      }\n    },\n\n    //update a group with the id id_grp\n    updateGrp(e,id_grp){\n      const grep=this.groups.find((r)=>r.id===id_grp);\n      const line= grep.line;\n      grep.offsetX=line.offsetX;\n      grep.offsetY=line.offsetY;\n      \n      line.x=e.target.x();\n      line.y=e.target.y();\n      this.center.x=line.x;\n      this.center.y=line.y;\n      /*\n      if(line.keepDistribution){\n        this.updateOccupiedDistance(line.id);\n      }\n      */\n      this.updateAllPosInGrp(line.id); \n      this.checkIfShapesOnLine(line.id);\n    },\n\n\n    //update the position of all shapes that are on the line of the group with the id id_grp.\n    updateAllPosInGrp(id_grp){\n      const grp= this.groups.find((r) => r.id===id_grp);     \n      const line= grp.line;\n      const shapes_g = grp.shapes_g;\n      for (let i=0;i<shapes_g.length;i++){\n          if(line.keepDistribution){\n            shapes_g[i].x=line.x+line.occupiedDistances[i]*Math.cos(line.rotation*(Math.PI/180));\n            shapes_g[i].y=line.y+line.occupiedDistances[i]*Math.sin(line.rotation*(Math.PI/180));\n            shapes_g[i].distance_to_line_center=line.occupiedDistances[i];\n            shapes_g[i].rotation=shapes_g[i].personalRotation+line.rotation;\n            \n          } else{\n            shapes_g[i].x=line.x+line.occupiedDistances[i]*Math.cos(line.rotation*(Math.PI/180));\n            shapes_g[i].y=line.y+line.occupiedDistances[i]*Math.sin(line.rotation*(Math.PI/180));\n            shapes_g[i].distance_to_line_center=line.occupiedDistances[i];\n            shapes_g[i].rotation=shapes_g[i].personalRotation+line.rotation;\n          }\n          line.positionPoints[i].x=shapes_g[i].x;\n          line.positionPoints[i].y=shapes_g[i].y;\n          line.positionPoints[i].distance_to_line_center=shapes_g[i].distance_to_line_center;\n      }\n      let i=shapes_g.length;\n      while(i<line.positionPoints.length){\n        if(line.keepDistribution){\n          line.positionPoints.splice(i,1);\n        }else{\n        line.positionPoints[i].x=line.x+line.freeDistances[i-shapes_g.length]*Math.cos(line.rotation*(Math.PI/180));\n        line.positionPoints[i].y=line.y+line.freeDistances[i-shapes_g.length]*Math.sin(line.rotation*(Math.PI/180));\n        line.positionPoints[i].distance_to_line_center=line.freeDistances[i-shapes_g.length];\n        i++;\n        }\n        \n      }\n    \n    },\n    isOutsideTheLine(shape,line){\n      let coord_y1=line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x1=line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let coord_y2= line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x2=line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let a=(coord_y1-coord_y2)/(coord_x2-coord_x1);\n      let b=line.y-a*line.x;\n      let is_on_straight_line=false;\n      if(Math.abs(coord_x1-coord_x2)>=1){\n        is_on_straight_line=(Math.abs(a*shape.x+b-shape.y)<1);\n      }else{\n        is_on_straight_line=(Math.abs(shape.x-line.x)<1);\n      }\n      if(\n        !(is_on_straight_line)\n      ||((line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n        ||line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      && ((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>-Math.PI)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>-Math.PI)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>=0)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>=0)))\n      ){\n        return true;\n      }else{ return false}\n    },\n    \n    //update the canvas\n    update(){\n      const shapes = this.shapes\n      \n      //const lengthToCapture=10; //bigger is the number, bigger is the intervals of x and y where a shape can be added to a line.\n      let is_on_straight_line=false;\n      for (let i=0;i<shapes.length;i++){\n        let x=shapes[i].x;\n        let y=shapes[i].y;\n      for (let j=0;j<this.groups.length;j++){\n      \n        let line=this.groups[j].line;\n\n        \n        let coord_y1=line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n        let coord_x1=line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n        let coord_y2= line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n        let coord_x2=line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n        let a=(coord_y1-coord_y2)/(coord_x2-coord_x1);\n        let b=line.y-a*line.x;\n        if(Math.abs(coord_x1-coord_x2)>1){\n          is_on_straight_line=(Math.abs(a*x+b-y)<=this.lengthToCapture);\n        }else{\n          is_on_straight_line=(Math.abs(x-line.x)<=this.lengthToCapture);\n          //is_on_straight_line=true;\n        }\n        if(\n        (\n          is_on_straight_line\n      &&(line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToCapture>=y\n      && line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToCapture<=y)\n      &&(line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToCapture>=x\n      && line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToCapture<=x)\n      &&(line.rotation*(Math.PI/180)<=0 \n      && line.rotation*(Math.PI/180)>-Math.PI/2))\n\n      ||(\n        is_on_straight_line\n      &&(line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))+this.lengthToCapture>=y\n      && line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))-this.lengthToCapture<=y) \n      &&(line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))+this.lengthToCapture>=x\n      && line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))-this.lengthToCapture<=x)\n      &&(line.rotation*(Math.PI/180)<=-Math.PI/2 \n      && line.rotation*(Math.PI/180)>=-Math.PI))\n\n      ||(\n        is_on_straight_line\n      &&(line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))+this.lengthToCapture>=y\n      &&line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))-this.lengthToCapture<=y)\n      &&(line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))+this.lengthToCapture>=x\n      && line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))-this.lengthToCapture<=x)\n      &&(line.rotation*(Math.PI/180)<=Math.PI \n      && line.rotation*(Math.PI/180)>Math.PI/2))\n\n      ||(\n        is_on_straight_line\n      &&(line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToCapture>=y\n      && line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToCapture<=y)\n      &&(line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToCapture>=x\n      && line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToCapture<=x)\n      &&(line.rotation*(Math.PI/180)<=Math.PI/2\n      && line.rotation*(Math.PI/180)>=0))\n      )\n       {\n          shapes[i].isGrouped=1;\n          this.makeGroup(line.id);\n        }\n      }\n      }\n    },\n\n    CheckIfNeedToDetach(e){\n      let grp=this.groups.find((r)=>r.id===e.target.getParent().attrs.id);\n      let shape= grp.shapes_g.find((r)=>r.id==e.target.id());\n      let dist=Math.sqrt((e.target.getStage().getPointerPosition().y-e.target.y())**2+(e.target.getStage().getPointerPosition().x-e.target.x())**2);\n      if(e.target.className==\"Rect\"){\n        dist-=e.target.attrs.height*e.target.attrs.scaleY;\n      } else if(e.target.className==\"Circle\"){\n        dist-=(2*e.target.attrs.radius)*e.target.attrs.scaleY;\n      } else if(e.target.className==\"Text\"){\n        dist-=e.target.attrs.length_y*e.target.attrs.scaleY;\n      } else if(e.target.className==\"Image\"){\n        dist-=e.target.height()*e.target.scaleY();\n      } else if(e.target.attrs.className==\"Triangle\"){\n        dist-=e.target.height()*e.target.scaleY();\n      } \n      \n      if (dist>50){\n        //let shape= this.groups.find((r)=>r.id===e.target.getParent().attrs.id).shapes_g.find((r)=>r.id==e.target.id());\n        //this.groups.find((r)=>r.id===e.target.getParent().attrs.id).shapes_g.find((r)=>r.id==e.target.id()).needToBeDetach=1;\n        /*\n        shape.dragBoundFunc= function (pos) {\n              return {\n                x: pos.x,\n                y: pos.y,\n              };\n        }\n        */\n        //shape.x=e.target.getStage().getPointerPosition().x;\n        //shape.y=e.target.getStage().getPointerPosition().y;\n        //if (Math.abs(e.target.getStage().getPointerPosition().y-e.target.y())>220){\n\n        //shape.x=e.target.getStage().getPointerPosition().x;\n        //shape.y=e.target.getStage().getPointerPosition().y;\n        this.groups.find((r)=>r.id===e.target.getParent().attrs.id).aShapeHasBeenDetach=1;\n        this.DetachShape(shape,e.target.getStage().getPointerPosition().x,e.target.getStage().getPointerPosition().y);\n        //}\n        \n        \n        \n      }\n    },\n\n    //Give the sign of the distance of shape from the center of a line.\n    GiveSignOfDistance(shape,line){\n      let result;\n      let angle=line.rotation*(Math.PI/180);\n      let distX=shape.x-line.x;\n      let distY=shape.y-line.y;\n      /*\n      \n      if(angle<=-Math.PI/4 || angle>=-Math.PI/2){\n        result=-Math.sign(distY);\n      }\n      else if(angle<=-Math.PI/2 || angle>=-3*Math.PI/4){\n        result=Math.sign(distY);\n      }\n      else if(angle<=-3*Math.PI/4 || angle>=-Math.PI){\n        result=-Math.sign(distX);\n      }else if(angle>=3*Math.PI/4 || angle<=Math.PI){\n        result=Math.sign(distX);\n      }else if(angle>=Math.PI/2 || angle<3*Math.PI/4){\n        result=-Math.sign(distY);\n      } else if(angle<=Math.PI/2 || angle>Math.PI/4){\n        result=-Math.sign(distY);\n      } else if(angle<=Math.PI/4 || angle>=0){\n        result=Math.sign(distX);\n      }\n      */\n      \n      \n      if(Math.abs(distX)<=this.lengthToCapture && line.rotation==-90){\n        \n        result=-Math.sign(distY);\n      } else if (Math.abs(distX)<=this.lengthToCapture && line.rotation==90){\n        result=Math.sign(distY);\n      }\n      else{\n        result=Math.sign(distX);\n      }\n      if(angle<-Math.PI/2 || angle>Math.PI/2){\n        result=-result;\n      }\n      \n      return result;\n    },\n\n    //Different from the previous function bcs the straight line of the center is perdendicular to the line\n    GiveSignOfDistanceBtwCenterAndShape(center,shape){\n      let result;\n      let angle=shape.rotation*(Math.PI/180);\n      let distX=center.x-shape.x;\n      let distY=center.y-shape.y;\n      /*\n      \n      if(angle<=-Math.PI/4 || angle>=-Math.PI/2){\n        result=-Math.sign(distY);\n      }\n      else if(angle<=-Math.PI/2 || angle>=-3*Math.PI/4){\n        result=Math.sign(distY);\n      }\n      else if(angle<=-3*Math.PI/4 || angle>=-Math.PI){\n        result=-Math.sign(distX);\n      }else if(angle>=3*Math.PI/4 || angle<=Math.PI){\n        result=Math.sign(distX);\n      }else if(angle>=Math.PI/2 || angle<3*Math.PI/4){\n        result=-Math.sign(distY);\n      } else if(angle<=Math.PI/2 || angle>Math.PI/4){\n        result=-Math.sign(distY);\n      } else if(angle<=Math.PI/4 || angle>=0){\n        result=Math.sign(distX);\n      }\n      */\n      \n      \n      if(Math.abs(distY)<=this.lengthToCapture && shape.rotation==-90){\n        \n        result=Math.sign(distX);\n      } else if (Math.abs(distY)<=this.lengthToCapture && shape.rotation==90){\n        result=-Math.sign(distX);\n      }\n      else{\n        result=Math.sign(distY);\n      }\n      if(angle<-Math.PI/2 || angle>Math.PI/2){\n        result=-result;\n      }\n      \n      return result;\n    },\n\n    /*add shapes with isGrouped==1 to the group with the id id_grp.\n    */\n    makeGroup(id_grp){\n      this.eraseNodefromTransformer(\"shapeTransformer\");\n      this.eraseNodefromTransformer(\"lineTransformer\");\n      const grp=this.groups.find((r)=> r.id===id_grp);\n      const line=grp.line;\n      const shapes = this.shapes;\n      line.freeDistances.sort(this.isSmaller); //we will give the shortest available distance to the added shape\n      shapes.sort(this.isBeforeRegardingX);\n      for (let i=0;i<shapes.length;i++){\n        if(shapes[i].isGrouped==1){\n          const positionPoint=Object.assign({},this.positionPoint);\n          let distX=shapes[i].x-line.x;\n          let distY=shapes[i].y-line.y; \n          shapes[i].personalRotation=0;\n          //let pot_dist=this.GiveSignOfDistance(shapes[i],line)*Math.sqrt((distX)**2+(distY)**2);\n          /*\n          if(line.keepDistribution && line.freeDistances.length>0){\n          let distances=line.freeDistances+line.occupiedDistances;\n          console.log(distances);\n           let freeDistance=this.isNearest(line.freeDistances,pot_dist);\n           //shapes[i].distance_to_line_center=freeDistance.res; \n           shapes[i].distance_to_line_center=this.GiveSignOfDistance(shapes[i],line)*Math.sqrt((distX)**2+(distY)**2);\n            \n           line.occupiedDistances.push(shapes[i].distance_to_line_center,);\n           line.freeDistances.splice(freeDistance.indice,1);\n\n          } else{\n            */\n            //let distX=shapes[i].x-line.x;\n            //let distY=shapes[i].y-line.y;\n            shapes[i].distance_to_line_center=this.GiveSignOfDistance(shapes[i],line)*Math.sqrt((distX)**2+(distY)**2);\n            /*If the distance is a little bit to far from the center \n            we adjust it so that the shape can be at one of the border of the stickyline*/\n            if(Math.abs(shapes[i].distance_to_line_center)>=line.points[4]*line.scaleX/2){\n              shapes[i].distance_to_line_center=Math.sign(shapes[i].distance_to_line_center)*line.points[4]*line.scaleX/2\n            }\n            this.ChangeCenterRegardingCommand(shapes[i].id,grp.line.defaultAlignment);\n            \n              //shapes[i].isGrouped=0;\n              this.updateDragFunc(shapes[i],line);\n              grp.shapes_g.push(shapes[i],);\n              grp.line.occupiedDistances.push(shapes[i].distance_to_line_center,);\n              positionPoint.id=\"positionPoint\"+grp.id+grp.line.positionPoints.length;\n              grp.line.positionPoints.push(positionPoint,);\n              //shapes[i].distance_to_line_center=this.GiveSignOfDistance(shapes[i],line)*Math.sqrt((distX)**2+(distY)**2);\n            \n            //line.occupiedDistances.push(shapes[i].distance_to_line_center,);\n          //}\n          console.log(\"A new shape has been added with a distance\"+shapes[i].distance_to_line_center);\n          \n          //shapes[i].isGrouped=0;\n          //this.updateDragFunc(shapes[i],line);\n          //grp.shapes_g.push(shapes[i],);\n          this.updateOccupiedDistance(line.id);\n          \n          this.updateAllPosInGrp(id_grp);\n          this.updateNaration(grp);\n          shapes.splice(i,1);\n        }\n      }\n      this.center.x=line.x;\n      this.center.y=line.y;\n    },\n\n    updateOccupiedDistance(id_grp){\n      \n      const grp=this.groups.find((r)=> r.id===id_grp);\n      //this.updateAllPosInGrp(id_grp);\n      this.sortByDistToLineCenter(grp);\n      \n      //let l=grp.line.points[4]/2;\n      if(grp.line.keepDistribution){\n      let L=grp.line.points[4];\n      let nb_shapes=grp.shapes_g.length;\n      let d=(L/(nb_shapes-1))*grp.line.scaleX;\n      if(nb_shapes%2==0){\n        \n      for (let i =1;i<=nb_shapes/2-1;i++){\n        //grp.line.occupiedDistances[i-1]=-(l/i);\n        grp.line.occupiedDistances[i-1]=-((nb_shapes/2-1)-i+1)*d-d/2\n      }\n      for (let i =1;i<=nb_shapes/2-1;i++){\n        grp.line.occupiedDistances[nb_shapes/2+i]=i*d+d/2;\n      }\n      grp.line.occupiedDistances[nb_shapes/2-1]=-d/2\n      grp.line.occupiedDistances[nb_shapes/2]=d/2\n      } else{\n        for (let i =1;i<=(nb_shapes-1)/2;i++){\n          grp.line.occupiedDistances[i-1]=-d*(((nb_shapes-1)/2)-i+1);\n        }\n        for (let i =1;i<=(nb_shapes-1)/2;i++){\n          grp.line.occupiedDistances[((nb_shapes-1)/2)+i]=d*i;\n        }\n        grp.line.occupiedDistances[(nb_shapes-1)/2]=0;\n      }\n      \n      for (let i=0;i<grp.shapes_g.length;i++){\n        grp.shapes_g[i].distance_to_line_center=grp.line.occupiedDistances[i];\n      }\n      }\n      else{\n        grp.line.occupiedDistances.sort(this.isSmaller);\n      }\n      \n      \n      \n    \n\n    },\n\n   isSmaller(a,b){\n    if(a<b){\n      return -1;\n    }else{\n      return 1\n    }\n   },\n\n   isBeforeRegardingX(a,b){\n    if(a.x<b.x){\n      return -1;\n    }else{\n      return 1;\n    }\n   },\n\n    \n   updateOccDist(grp,shape){\n    let res=this.isNearest(grp.line,shape);\n    //let grp=this.groups.find((r)=>r.id===line.id);\n    if(res.isFree){\n      shape.distance_to_line_center=grp.line.freeDistances[res.indice];\n      grp.line.freeDistances.splice(res.indice,1);\n      this.sortByDistToLineCenter(grp);\n      for(let l=0;l<grp.shapes_g.length;l++){\n        if(grp.line.occupiedDistances.length==l){\n          grp.line.occupiedDistances.push(grp.shapes_g[l].distance_to_line_center,);\n        }else{\n          grp.line.occupiedDistances[l]=grp.shapes_g[l].distance_to_line_center;\n        }\n      } \n    } else{\n      grp.shapes_g.find((r)=>r.id==shape.id).distance_to_line_center=grp.line.occupiedDistances[res.indice];\n      grp.line.occupiedDistances.splice(res.indice,1);\n      //line.occupiedDistances.push(shape.distance_to_line_center,);\n      //line.freeDistances.splice(res.indice,1);   \n      this.updateOccDist(grp,grp.shapes_g[res.indice]);\n    }\n   },\n   isNearest(line,shape){\n    let ecart;\n    let invx=line.x+line.freeDistances[0]*Math.cos(line.rotation*(Math.PI/180));\n    let invy=line.y+line.freeDistances[0]*Math.sin(line.rotation*(Math.PI/180));\n    let ecart_min=Math.sqrt((invx-shape.x)**2+(invy-shape.y)**2);\n    let indice=0;\n    for(let i=1;i<line.freeDistances.length;i++){\n      invx=line.x+line.freeDistances[i]*Math.cos(line.rotation*(Math.PI/180));\n      invy=line.y+line.freeDistances[i]*Math.sin(line.rotation*(Math.PI/180));\n      ecart=Math.sqrt((invx-shape.x)**2+(invy-shape.y)**2);\n      if(ecart<ecart_min){\n        //res=line.freeDistances[i];\n        ecart_min=ecart;\n        indice=i;\n      }\n    }\n    return indice;\n    /*\n    let allDist=line.freeDistances.concat(line.occupiedDistances);\n    console.log(allDist);\n    \n    let ecart;\n    let invx=line.x+allDist[0]*Math.cos(line.rotation*(Math.PI/180));\n    let invy=line.y+allDist[0]*Math.sin(line.rotation*(Math.PI/180));\n    let ecart_min=Math.sqrt((invx-shape.x)**2+(invy-shape.y)**2)\n    let indice=0;\n    console.log(ecart_min);\n    for(let i=1;i<allDist.length;i++){\n      invx=line.x+allDist[i]*Math.cos(line.rotation*(Math.PI/180));\n      invy=line.y+allDist[i]*Math.sin(line.rotation*(Math.PI/180));\n      ecart=Math.sqrt((invx-shape.x)**2+(invy-shape.y)**2);\n      if(this.groups.find((r)=>r.id==line.id).shapes_g.indexOf(shape)!=-1){\n        console.log(ecart_min);\n        console.log(ecart);\n        if(ecart<ecart_min && ecart!=0){\n          //res=allDist[i];\n          ecart_min=ecart;\n          indice=i;\n        }\n      }else if(ecart<ecart_min){\n        //res=allDist[i];\n        ecart_min=ecart;\n        indice=i;\n      }\n    }\n    console.log(indice);\n    if(indice>=line.freeDistances.length){\n      return{\n        isFree: false,\n        indice: indice-line.freeDistances.length,\n      }\n    }else{\n      return{\n        isFree: true,\n        indice: indice,\n      }\n    }\n    */\n\n    /*\n    line.freeDistances.sort(this.isSmaller);\n    let ecart;\n    let invx=line.x+line.freeDistances[0]*Math.cos(line.rotation*(Math.PI/180));\n    let invy=line.y+line.freeDistances[0]*Math.sin(line.rotation*(Math.PI/180));\n    let ecart_min=Math.sqrt((invx-shape.x)**2+(invy-shape.y)**2)\n    let indice=0;\n    for(let i=0;i<line.freeDistances.length;i++){\n      invx=line.x+line.freeDistances[i]*Math.cos(line.rotation*(Math.PI/180));\n      invy=line.y+line.freeDistances[i]*Math.sin(line.rotation*(Math.PI/180));\n      ecart=Math.sqrt((invx-shape.x)**2+(invy-shape.y)**2)\n      if(ecart<ecart_min){\n        //res=freeDistances[i];\n        ecart_min=ecart;\n        indice=i;\n      }\n    }\n    return indice;\n    */\n    /*\n    if(shapeDistance>=0){\n      for(let i=0;i<freeDistances.length;i++){\n        if(freeDistances[i]>shapeDistance){\n          return i;\n        }\n      }\n      return freeDistances.length-1;\n    }else{\n      let ecart_min=Math.abs(Math.abs(freeDistances[0])-Math.abs(shapeDistance))\n      let indice=0;\n      for(let i=0;i<freeDistances.length;i++){\n        let ecart=Math.abs(Math.abs(freeDistances[i])-Math.abs(shapeDistance));\n        if(ecart<ecart_min){\n          //res=freeDistances[i];\n          ecart_min=ecart;\n          indice=i;\n        }\n      }\n      return indice;\n    }\n    */\n    /*\n    //let res=freeDistances[0];\n    let ecart_min=Math.abs(Math.abs(freeDistances[0])-Math.abs(shapeDistance))\n    let indice=0;\n    for(let i=0;i<freeDistances.length;i++){\n      let ecart=Math.abs(Math.abs(freeDistances[i])-Math.abs(shapeDistance));\n      if(ecart<ecart_min){\n        //res=freeDistances[i];\n        ecart_min=ecart;\n        indice=i;\n      }\n    }\n    return indice;\n    */\n   },\n   \n\n   sortByDistToLineCenter(grp){\n    //this.updateAllPosInGrp(grp.id)\n    //let last_distX=new Array(grp.shapes_g.length);\n    \n    //let distX;\n    //let distY;\n    //let sign;\n    //let dist=new Array(grp.shapes_g.length);\n    //let angle;\n    if(grp.line.keepDistribution){\n      for (let l=0;l<grp.shapes_g.length;l++){\n          let distX=grp.shapes_g[l].x-grp.line.x;\n          let distY=grp.shapes_g[l].y-grp.line.y;\n          //dist[l]=this.GiveSignOfDistance(grp.shapes_g[l],grp.line)*Math.sqrt((distX)**2+(distY)**2);\n          grp.shapes_g[l].distance_to_line_center=this.GiveSignOfDistance(grp.shapes_g[l],grp.line)*Math.sqrt((distX)**2+(distY)**2);\n          //last_distX[l]=distX;\n        }\n    }\n    for(let i=1;i<grp.shapes_g.length;i++){\n      \n     \n      let shape=grp.shapes_g[i];\n      //let distance=dist[i];\n      let j=i\n      while(j>0 && grp.shapes_g[j-1].distance_to_line_center>shape.distance_to_line_center){\n        grp.shapes_g[j]=grp.shapes_g[j-1];\n        //dist[j]=dist[j-1]\n        j=j-1;\n      }\n      grp.shapes_g[j]=shape;\n      //dist[j]=distance;\n    }\n   },\n   \n\n   sortAnyShapesByDistToLineCenter(shapes,line){\n    //this.updateAllPosInGrp(grp.id)\n    //let last_distX=new Array(grp.shapes_g.length);\n    \n    //let distX;\n    //let distY;\n    //let sign;\n    //let dist=new Array(grp.shapes_g.length);\n    //let angle;\n    for (let l=0;l<shapes.length;l++){\n        let distX=shapes[l].x-line.x;\n        let distY=shapes[l].y-line.y;\n        /*\n        angle=grp.shapes_g[l].rotation*(Math.PI/180);\n\n      \n      if(angle<=-Math.PI/4 || angle>=-Math.PI/2){\n        sign=-Math.sign(distY);\n      }\n      else if(angle<=-Math.PI/2 || angle>=-3*Math.PI/4){\n        sign=Math.sign(distY);\n      }\n      else if(angle<=-3*Math.PI/4 || angle>=-Math.PI){\n        sign=-Math.sign(distX);\n      }else if(angle>=3*Math.PI/4 || angle<=Math.PI){\n        sign=Math.sign(distX);\n      }else if(angle>=Math.PI/2 || angle<3*Math.PI/4){\n        sign=-Math.sign(distY);\n      } else if(angle<=Math.PI/2 || angle>Math.PI/4){\n        sign=-Math.sign(distY);\n      } else if(angle<=Math.PI/4 || angle>=0){\n        sign=Math.sign(distX);\n      }\n       console.log(sign);\n        */\n       \n        /*\n        if(Math.sin(grp.line.rotation*(Math.PI/180))==0){\n            grp.shapes_g[l].distance_to_line_center=grp.shapes_g[l].x-grp.line.x;\n        }else{\n            grp.shapes_g[l].distance_to_line_center=Math.sign(distX)*Math.sqrt((distX)**2+(distY)**2);\n          \n            if(grp.line.rotation*(Math.PI/180)<=-Math.PI/2 || grp.line.rotation*(Math.PI/180)<=Math.PI/2 &&grp.line.rotation*(Math.PI/180)>=0){\n              grp.shapes_g[l].distance_to_line_center=-grp.shapes_g[l].distance_to_line_center\n            }\n        }\n        */\n        //dist[l]=this.GiveSignOfDistance(grp.shapes_g[l],grp.line)*Math.sqrt((distX)**2+(distY)**2);\n        shapes.distance_to_line_center=this.GiveSignOfDistance(shapes,line)*Math.sqrt((distX)**2+(distY)**2);\n        /*\n        if((grp.line.rotation*(Math.PI/180)<=-Math.PI/2 || (grp.line.rotation*(Math.PI/180)<=Math.PI/2 && grp.line.rotation*(Math.PI/180)>=0)) && (Math.sign(last_distX[l])!=Math.sign(distX))){\n          grp.shapes_g[l].distance_to_line_center=-grp.shapes_g[l].distance_to_line_center\n        }\n        */\n        //last_distX[l]=distX;\n      }\n    for(let i=1;i<shapes.length;i++){\n      \n     \n      let shape=shapes[i];\n      //let distance=dist[i];\n      let j=i\n      while(j>0 && shapes[j-1].distance_to_line_center>shape.distance_to_line_center){\n        shapes[j]=shapes[j-1];\n        //dist[j]=dist[j-1]\n        j=j-1;\n      }\n      shapes[j]=shape;\n      //dist[j]=distance;\n    }\n   },\n\n  \n\n   /*\n   update the drag function of a shape which is on a line. \n   */\n   updateDragFunc(shape,line){\n          let angle=line.rotation*(Math.PI/180);\n          if (angle<=0 && angle>=-Math.PI/4){\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x +(pos.x-line.x)*Math.cos(angle),\n                y: line.y+(pos.x-line.x)*Math.sin(angle),\n              };\n            }\n          } else if (angle<-Math.PI/4 && angle>=-Math.PI/2){\n            // We prefer, in this case, moving the shape of the line regarding the y of the mouse position instead of the x.\n            // So that the user can move the shape more intuitively\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x-(pos.y-line.y)*Math.cos(angle),\n                y: line.y-(pos.y-line.y)*Math.sin(angle),\n              };\n            }\n          }\n          else if (angle<-Math.PI/2 && angle>=-3*Math.PI/4){\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x-(pos.y-line.y)*Math.cos(angle),\n                y: line.y-(pos.y-line.y)*Math.sin(angle),\n              };\n            }\n          } else if (angle<-3*Math.PI/4 && angle>=-Math.PI){\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x-(pos.x-line.x)*Math.cos(angle),\n                y: line.y-(pos.x-line.x)*Math.sin(angle),\n              };\n            }\n          }else if (angle<=Math.PI && angle>=3*Math.PI/4){\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x-(pos.x-line.x)*Math.cos(angle),\n                y: line.y-(pos.x-line.x)*Math.sin(angle),\n              };\n            }\n          } else if (angle<3*Math.PI/4 && angle>=Math.PI/2){\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x+(pos.y-line.y)*Math.cos(angle),\n                y: line.y+(pos.y-line.y)*Math.sin(angle),\n              };\n            }\n          } else if (angle<Math.PI/2 && angle>=Math.PI/4){\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x+(pos.y-line.y)*Math.cos(angle),\n                y: line.y+(pos.y-line.y)*Math.sin(angle),\n              };\n            }\n          }else if (angle<Math.PI/4 && angle>=0){\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x+(pos.x-line.x)*Math.cos(angle),\n                y: line.y+(pos.x-line.x)*Math.sin(angle),\n              };\n            }\n          }\n   },\n\n   /*\n   Update the position of a free shape when it is dragging.\n   */\n    updatePos(e){\n      const shape = this.shapes.find(i => i.id === e.target.id());\n      shape.x=e.target.x();\n      shape.y=e.target.y();\n      this.center.x=e.target.x();\n      this.center.y=e.target.y();\n\n      let pos = { x: shape.x, y: shape.y };\n      e.target.position(pos);\n      e.target.getLayer().batchDraw();\n      \n    },\n\n    /*\n    Update the positio  of shape attached to a line (from the group with id=id_grp) when it is dragging.\n     */\n    updatePosInGrp(e,id_grp){\n      let distX;\n      let distY;\n      let distance_to_line_center;\n      const grp=this.groups.find((r)=> r.id===id_grp);\n      \n      if(grp.aShapeHasBeenDetach==1){\n        grp.aShapeHasBeenDetach=0;\n        return;\n      }\n      const line=grp.line;\n      const shape = grp.shapes_g.find(i => i.id === e.target.id());\n      const shapes_g = grp.shapes_g; \n      //const lengthToDetach=10;\n      if(shape.needToBeDetach==1){\n        shape.needToBeDetach=0;\n        this.DetachShape(shape);\n        this.updateAllPosInGrp(e.target.getParent().attrs.id);\n      }\n      if(line.keepDistribution){\n        if(this.isCoordinateOnLine(e.target.x(),e.target.y(),line.id)){\n          distX=shape.x-e.target.x();\n          distY=shape.y -e.target.y();\n          let L=grp.line.points[4];\n          let nb_shapes=grp.shapes_g.length;\n          let d=(L/(nb_shapes-1))*grp.line.scaleX;\n          let dist=Math.sqrt(distX**2 +distY**2);\n          if(dist>=d){\n            shape.x=e.target.x();\n            shape.y=e.target.y();\n            this.updateOccupiedDistance(line.id)\n            shape.x=line.x+line.occupiedDistances[shapes_g.indexOf(shape)]*Math.cos(line.rotation*(Math.PI/180));\n            shape.y=line.y+line.occupiedDistances[shapes_g.indexOf(shape)]*Math.sin(line.rotation*(Math.PI/180));\n            shape.distance_to_line_center=line.occupiedDistances[shapes_g.indexOf(shape)];\n            shape.rotation=line.rotation;\n            this.updateAllPosInGrp(line.id);\n          }else{\n            shape.x=line.x+line.occupiedDistances[shapes_g.indexOf(shape)]*Math.cos(line.rotation*(Math.PI/180));\n            shape.y=line.y+line.occupiedDistances[shapes_g.indexOf(shape)]*Math.sin(line.rotation*(Math.PI/180));\n            shape.distance_to_line_center=line.occupiedDistances[shapes_g.indexOf(shape)];\n            shape.rotation=line.rotation; \n          }   \n        }else{\n          shape.x=e.target.x();\n          shape.y=e.target.y();\n        }\n        line.positionPoints[grp.shapes_g.indexOf(shape)].x=shape.x;\n        line.positionPoints[grp.shapes_g.indexOf(shape)].y=shape.y;\n        line.positionPoints[grp.shapes_g.indexOf(shape)].distance_to_line_center=shape.distance_to_line_center; \n      } else{\n        \n          line.positionPoints[grp.shapes_g.indexOf(shape)].x=shape.x;\n          line.positionPoints[grp.shapes_g.indexOf(shape)].y=shape.y;\n          shape.x=e.target.x();\n          shape.y=e.target.y();\n          \n          if(Math.sin(line.rotation*(Math.PI/180))==0){\n            distance_to_line_center=shape.x-line.x;\n          }else{\n            if(Math.sign(shape.x-line.x)!=0){\n              distance_to_line_center=Math.sign(-shape.rotation)*Math.sign(shape.x-line.x)*Math.sqrt((shape.x-line.x)**2+(shape.y-line.y)**2);\n            } else{\n             distance_to_line_center=Math.sign(-shape.rotation)*Math.sign(shape.y-line.y)*Math.sqrt((shape.x-line.x)**2+(shape.y-line.y)**2); \n            }\n          \n            if(shape.rotation*(Math.PI/180)<=-Math.PI/2 || (shape.rotation*(Math.PI/180)<=Math.PI/2 && shape.rotation*(Math.PI/180)>=0)){\n              distance_to_line_center=-distance_to_line_center\n            }\n          }\n          //shape.distance_to_line_center=distance_to_line_center;\n          //grp.line.occupiedDistances[shapes_g.indexOf(shape)]=shape.distance_to_line_center;\n        line.positionPoints[grp.shapes_g.indexOf(shape)].distance_to_line_center=shape.distance_to_line_center;\n          \n      }\n      let pos = { x: shape.x, y: shape.y };\n      this.center.x=shape.x;\n      this.center.y=shape.y;\n      e.target.position(pos);\n      e.target.getLayer().batchDraw();\n      if(!this.isCoordinateOnLine(shape.x,shape.y,line.id)){\n        shape.dragBoundFunc= dragFunc;\n        shape.isGrouped=0;\n        this.shapes.push(shape,)\n        for (let i=0;i<shapes_g.length;i++){\n          if(shapes_g[i].id==shape.id){\n            line.freeDistances.push(line.occupiedDistances[i]);\n            line.occupiedDistances.splice(i,1);\n            line.positionPoints.splice(i,1);\n            shapes_g.splice(i,1);\n            console.log(\"a shape has been removed from the line\");\n          }\n        } \n      }else{\n        if(!line.keepDistribution){\n          grp.line.occupiedDistances[shapes_g.indexOf(shape)]=distance_to_line_center;\n        }else{\n        grp.line.occupiedDistances[shapes_g.indexOf(shape)]=shape.distance_to_line_center;\n        }\n        \n      line.positionPoints[grp.shapes_g.indexOf(shape)].x=shape.x;\n      line.positionPoints[grp.shapes_g.indexOf(shape)].y=shape.y;\n      line.positionPoints[grp.shapes_g.indexOf(shape)].distance_to_line_center=shape.distance_to_line_center;\n       \n      }\n      /*\n      let coord_y1=line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x1=line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let coord_y2= line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x2=line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let a=(coord_y1-coord_y2)/(coord_x2-coord_x1);\n      let b=line.y-a*line.x;\n      let is_on_straight_line=false;\n      if(Math.abs(coord_x1-coord_x2)>=1){\n        is_on_straight_line=(Math.abs(a*shape.x+b-shape.y)<1);\n      }else{\n        is_on_straight_line=(Math.abs(shape.x-line.x)<1);\n      }\n      if(\n        !(is_on_straight_line)\n      ||((line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n        ||line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      && ((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>-Math.PI)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>-Math.PI)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>=0)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>=0)))\n      )\n      {\n        shape.dragBoundFunc= dragFunc;\n        this.shapes.push(shape,)\n        for (let i=0;i<shapes_g.length;i++){\n          if(shapes_g[i].id==shape.id){\n            line.freeDistances.push(line.occupiedDistances[i]);\n            line.occupiedDistances.splice(i,1);\n            shapes_g.splice(i,1);\n            console.log(\"a shape has been removed from the line\");\n          }\n        } \n      }else{\n        if(!line.keepDistribution){\n          grp.line.occupiedDistances[shapes_g.indexOf(shape)]=distance_to_line_center;\n        }else{\n        grp.line.occupiedDistances[shapes_g.indexOf(shape)]=shape.distance_to_line_center;\n        }\n      }\n      */\n      //this.updateOccupiedDistance(line.id);\n      \n          if(line.keepDistribution){\n            this.updateOccupiedDistance(line.id);\n          }\n          \n          this.updateAllPosInGrp(line.id);\n    },\n    \n    /*\n    Function called when the transformation of a shape with a transfomer is finished.\n    */\n    updateTransformedShape(e) {\n      \n\n      let res;\n      let shape; //Object concerned by the transformation\n      if(e.target.className==\"Line\"){\n        shape=this.groups.find(\n        (r) => r.id === this.selectedShapeId\n      ).line;\n      }else{\n        res=this.findShape(this.selectedShapeId)\n        shape=res.shape_data;\n        if(shape== undefined){\n          return;\n        }\n      }\n\n      \n      let last_shapex= shape.x;\n      let last_shapey= shape.y;\n\n      //update data of the transformed object.\n      shape.x = e.target.x();\n      shape.y = e.target.y();\n      shape.rotation = e.target.rotation();\n      let last_scaleX= shape.scaleX;\n      shape.scaleX = e.target.scaleX();\n      shape.scaleY = e.target.scaleY();\n\n      if(e.target.className==\"Line\"){\n        const grp=this.groups.find((r)=> r.id===shape.id);\n        if(shape.keepDistribution){\n          for (let i=0;i<shape.occupiedDistances.length;i++){\n            shape.occupiedDistances[i]=(shape.occupiedDistances[i]/last_scaleX)*shape.scaleX;\n          }\n          /*\n          for (let i=0;i<shape.freeDistances.length;i++){\n            shape.freeDistances[i]=(shape.freeDistances[i]/last_scaleX)*shape.scaleX;\n          }\n          */\n          \n          //this.updateOccupiedDistance(shape.id)\n          this.update();\n          this.updateGrp(e, this.selectedShapeId);\n          this.checkIfShapesOnLine(this.selectedShapeId);        \n        }else{\n          \n          \n          \n         if(last_scaleX!=shape.scaleX){\n          for(let i=0;i<grp.shapes_g.length;i++){\n          \n          //If the width of the line has been changed, we update the distance from the shape to the center of the line\n            \n              let distX=grp.shapes_g[i].x-shape.x;\n              let distY=grp.shapes_g[i].y-shape.y;\n              /*\n              if(Math.sign(grp.shapes_g[i].distance_to_line_center)==0){\n                grp.shapes_g[i].distance_to_line_center=-this.GiveSignOfDistance(grp.shapes_g[i],shape)*Math.sqrt((distX)**2 +(distY)**2);\n              \n              }else{\n                grp.shapes_g[i].distance_to_line_center=Math.sign(grp.shapes_g[i].distance_to_line_center)*Math.sqrt((distX)**2 +(distY)**2);\n              }\n              if(Math.sign((grp.shapes_g[i].x-last_shapex))!=Math.sign(distX)){\n                grp.shapes_g[i].distance_to_line_center=-grp.shapes_g[i].distance_to_line_center;\n              }\n              */\n             if(Math.sign(grp.line.occupiedDistances[i])==0){\n                //if(grp.line.rotation!=-90 && grp.line.rotation!=90){\n                  //grp.line.occupiedDistances[i]=-this.GiveSignOfDistance(grp.shapes_g[i],shape)*Math.sqrt((distX)**2 +(distY)**2);\n                //}else{\n                  grp.line.occupiedDistances[i]=this.GiveSignOfDistance(grp.shapes_g[i],shape)*Math.sqrt((distX)**2 +(distY)**2);\n                  \n                //}\n              \n              }else{\n                grp.line.occupiedDistances[i]=Math.sign(grp.line.occupiedDistances[i])*Math.sqrt((distX)**2 +(distY)**2);\n              }\n\n              \n              if(Math.sign((grp.shapes_g[i].x-last_shapex))!=Math.sign(distX) && Math.sign((grp.shapes_g[i].x-last_shapex))!=0 && grp.line.rotation!=90 && grp.line.rotation!=-90){\n                \n                grp.line.occupiedDistances[i]=-grp.line.occupiedDistances[i];\n              }\n              if(Math.sign((grp.shapes_g[i].y-last_shapey))!=Math.sign(distY) && Math.sign((grp.shapes_g[i].y-last_shapey))!=0 && (grp.line.rotation==90 || grp.line.rotation==-90)){\n                grp.line.occupiedDistances[i]=-grp.line.occupiedDistances[i];\n              }\n              //this.checkIfShapesOnLine(this.selectedShapeId);  \n            \n            //this.checkIfShapesOnLine(this.selectedShapeId);\n            //grp.line.occupiedDistances[i]=grp.shapes_g[i].distance_to_line_center;\n            \n          }\n          for (let i=0;i<shape.freeDistances.length;i++){\n            let distX=last_shapex-shape.x;\n            let distY=last_shapey-shape.y; \n            let dist=Math.sqrt(distX**2+distY**2);\n            if(shape.rotation<-90 ||shape.rotation>90){\n              shape.freeDistances[i]=shape.freeDistances[i]-Math.sign(last_shapex-shape.x)*dist;\n            } else if(shape.rotation==90 || shape.rotation==-90){\n              shape.freeDistances[i]=shape.freeDistances[i]-distY\n            } else{\n              shape.freeDistances[i]=shape.freeDistances[i]+Math.sign(last_shapex-shape.x)*dist;\n            \n            }\n          }\n         }\n          this.update();\n          this.updateGrp(e, this.selectedShapeId);\n          this.checkIfShapesOnLine(this.selectedShapeId);\n\n          // We now see if freeDistances need to be delete(so if they are bigger than the half of the stickyline);\n          \n        }\n        for(let i=0;i<grp.shapes_g.length;i++){\n            \n          this.updateDragFunc(grp.shapes_g[i],shape);\n\n        }\n      }else if(res.grp_id!='-1'){\n        //this.update();\n        //let layer=e.target.getParent().getLayer();\n        //layer.batchDraw();\n        this.updateAllPosInGrp(res.grp_id);\n        this.updateOccupiedDistance(res.grp_id);\n        e.target.x(e.target.getParent().attrs.shapes_g.find((r)=>r.id===e.target.id()).x);\n        e.target.y(e.target.getParent().attrs.shapes_g.find((r)=>r.id===e.target.id()).y);\n        this.groups.find((r)=>r.id===res.grp_id).shapes_g.find((r)=>r.id===e.target.id()).personalRotation=e.target.rotation()-e.target.getParent().attrs.line.rotation;\n        \n        \n        this.updateAllPosInGrp(res.grp_id);\n        this.checkIfShapesOnLine(res.grp_id);\n        this.updateDragFuncOfCenter();\n      \n      }\n      else{\n        this.update();\n        \n        this.updateDragFuncOfCenter();\n      }\n      this.center.x=e.target.attrs.x;\n      this.center.y=e.target.attrs.y;\n    },\n    \n    handleTransformation(e) {\n      if (e.evt==undefined) {\n        return;\n      }\n      if(this.eraseMode==1){\n        this.eraserAction(e);\n        return;\n      }\n      \n      //If we click on the stage, we have to remove the transformer from the node where it was.\n      if (e.target === e.target.getStage()) {\n        this.selectedShapeId = 'NoId';\n        this.eraseNodefromTransformer(\"lineTransformer\");\n        this.eraseNodefromTransformer(\"shapeTransformer\");\n        this.center.opacity=0;\n        return;\n      }\n\n      // If we click on a transformer, nothing happen.\n      const clickedOnTransformer = e.target.getParent().className === 'Transformer';\n      if (clickedOnTransformer) {\n        return;\n      }\n      \n      const id = e.target.id();\n      let transformer_id;\n      let shape=this.findShape(id).shape_data;\n\n      //if it is a line, we need the transformer dedicated to the line (ie transformer with id=\"lineTransformer\")\n      //if it is a classic shape, we need the transformer dedicated to the shape (ie transformer with id=\"shapeTransformer\")\n      if(e.target.attrs.id==\"center\"){\n        return;\n      }\n      if(e.target.className==\"Line\"){\n        transformer_id=\"lineTransformer\"\n        shape = this.groups.find((r) => r.id === id).line;\n        this.center.draggable=false;\n        this.selectedShapeAlignment=shape.defaultAlignment;\n        this.eraseNodefromTransformer(\"shapeTransformer\");\n      }else{\n        transformer_id=\"shapeTransformer\"\n        this.center.draggable=true;\n        this.selectedShapeAlignment=shape.centerPosition;\n        this.eraseNodefromTransformer(\"lineTransformer\");\n      }\n      \n      if (shape!=undefined) {\n        this.selectedShapeId = id;\n        this.center.opacity=1;\n        this.updateTransformer(transformer_id);\n      } else{\n        /*Only if the center is not selected.\n        When the center is dragged, this function is called.\n        But a shape is actualy selected (the one of the center).\n        */\n        this.selectedShapeId = 'NoId';\n      }\n      //this.updateTransformer(transformer_id);\n      \n      this.updateDragFuncOfCenter()\n    },\n\n    //remove node from transformer with id=transformer_id\n    eraseNodefromTransformer(transformer_id) {\n      let stage= this.$refs.stage.getStage();      \n      const transformerNode = stage.find(\"#\"+transformer_id)[0]; \n      transformerNode.nodes([]);\n    },\n\n    //Update transformer with id=transformer_id\n    //It places the transformer regarding what node is selected\n    updateTransformer(transformer_id) {\n\n      let stage= this.$refs.stage.getStage();\n      const transformerNode = stage.find(\"#\"+transformer_id)[0];\n      let selectedNode;\n      if (transformer_id==\"lineTransformer\"){\n        selectedNode = stage.children[0].getChildren().filter((r)=> r.attrs.className==\"Group\" && r.attrs.id==this.selectedShapeId)[0]\n        .getChildren().filter(r=>r.attrs.className==\"Line\" && r.attrs.id==this.selectedShapeId)[0];\n      }else{\n      selectedNode = stage.children[0].getChildren().filter((r)=>r.attrs.className!=\"Group\" && r.attrs.id==this.selectedShapeId)[0];\n\n      let isFunded=true;\n      if(selectedNode==undefined){\n        isFunded=false;\n      }\n      let i=0;\n      while(!isFunded){\n        if(i<this.groups.length){\n          selectedNode=stage.children[0].getChildren().filter((r)=>r.attrs.className==\"Group\")[i].getChildren().find((r)=>r.attrs.id==this.selectedShapeId && r.attrs.className!=\"Line\");\n        if(selectedNode==undefined){\n          isFunded=false;\n        }else{\n          isFunded=true;\n        }\n        i++;\n        }else{        \n          isFunded=true;\n        }\n      }\n      }\n      /*\n      if (transformer_id==\"lineTransformer\"){\n        selectedNode = stage.children[0].getChildren().filter((r)=> r.attrs.className==\"Group\" && r.attrs.id==this.selectedShapeId)[0]\n        .getChildren().filter(r=>r.attrs.className==\"Line\" && r.attrs.id==this.selectedShapeId)[0];\n      }\n      */\n     \n      //If the selected node has already the transformer on it, nothing happen\n      if (selectedNode === transformerNode.node()) {\n        return;\n      }\n\n      //If a node is selected\n      if (selectedNode!=undefined) {\n        //We attach the transformer to the node\n        transformerNode.nodes([selectedNode]);\n      } else {\n        //if no node is selected, we remove the transformer from its node.\n        transformerNode.nodes([]);\n      }\n      this.center.x=selectedNode.attrs.x;\n      this.center.y=selectedNode.attrs.y;\n      \n    },\n/*\n  DisplayCenterMenu(e){\n    CenterMenu.props.ConcernedShape=e.target;\n   document.getElementById(\"center_menu\").style.display=\"initial\";\n   document.getElementById(\"center_menu\").style.top=e.target.getStage().getPointerPosition().y+8+\"px\";\n  document.getElementById(\"center_menu\").style.left=e.target.getStage().getPointerPosition().x+8+\"px\";\n  },\n  */\n\n  //display context menu according to the target\n  /*\n  DisplayContextMenu(e){\n    e.evt.preventDefault()\n    if (e.target.className!=undefined && e.target.attrs.id!=\"center\"){\n      this.isStageOnlySelected=false;\n      ContextMenu.data().dM='initial';\n      this.$emit('needmenu');\n      this.needMenu=true;\n      ContextMenu.props.ConcernedShape=e.target;\n      if (e.target.attrs.className==\"Line\"){\n        this.isALineSelected=true;\n        this.isAGroupedShapeSelected=true;\n        //We precise the text which depends on the line where we clicked.\n        this.keepDistanceButtonText=e.target.attrs.keepDistanceButtonText;\n      } else if(e.target.getParent().attrs.className==\"Group\"){\n        this.isAGroupedShapeSelected=true;\n      }\n      else{\n        this.isALineSelected=false;\n        this.isAGroupedShapeSelected=false;\n      }\n      document.getElementById(\"active\").style.display=\"initial\";\n      document.getElementById(\"active\").style.top=e.target.getStage().getPointerPosition().y+8+\"px\";\n      document.getElementById(\"active\").style.left=e.target.getStage().getPointerPosition().x +8+\"px\";\n    }\n    if (e.target === e.target.getStage()) {\n      this.needMenu=true;\n      this.isALineSelected=false;\n      this.isAGroupedShapeSelected=false;\n      this.isStageOnlySelected=true;\n      document.getElementById(\"active\").style.display=\"initial\";\n      document.getElementById(\"active\").style.top=e.target.getStage().getPointerPosition().y+8+\"px\";\n      document.getElementById(\"active\").style.left=e.target.getStage().getPointerPosition().x +8+\"px\";\n    \n    }\n  },\n\n  //hide context menu\n  HideContextMenu(){\n    this.needMenu=false;\n    document.getElementById(\"active\").style.display=\"none\";\n    document.getElementById(\"center_menu\").style.display=\"none\";\n  },\n*/\n\n  \n ChangeCenter(e){\n  let res=this.findShape(this.selectedShapeId);\n  let shape=res.shape_data;\n  let threshold1;\n  let threshold2;\n  let dist=this.GiveSignOfDistanceBtwCenterAndShape(e.target.attrs,shape)*Math.sqrt((e.target.y()-(shape.y))**2+(e.target.x()-shape.x)**2)+shape.offsetY*shape.scaleY;\n  \n  //let last_offsetX=shape.offsetX;\n  let last_offsetY=shape.offsetY;\n  if(shape==undefined){\n    shape=this.groups.find((r)=>r.id==this.selectedShapeId).line;\n\n  }else{\n    \n      if(shape.className==\"Rect\") {\n        threshold1=shape.height*shape.scaleY/3;\n        threshold2=shape.height*shape.scaleY*2/3;\n        if(dist>=threshold1 && dist<=threshold2){\n          shape.offsetX=shape.width/2;\n          shape.offsetY=shape.height/2;\n          shape.centerPosition=\"Middle\";\n        }else if(dist>threshold2){\n          shape.offsetX=shape.width/2;\n          shape.offsetY=shape.height;\n          shape.centerPosition=\"Bottom\";\n        }\n        else{\n          shape.offsetX=shape.width/2;\n          shape.offsetY=0;\n          shape.centerPosition=\"Top\";\n        }\n      }\n      else if(shape.className==\"Circle\") {\n        dist=dist+shape.radius*shape.scaleY;\n        threshold1=shape.radius*shape.scaleY*2/3;\n        threshold2=shape.radius*shape.scaleY*4/3;\n        if(dist>=threshold1 && dist<=threshold2){\n          shape.offsetX=0;\n          shape.offsetY=0;\n          shape.centerPosition=\"Middle\";\n        }else if(dist>threshold2){\n          shape.offsetX=0;\n          shape.offsetY=shape.radius;\n          shape.centerPosition=\"Bottom\";\n        }else{\n          shape.offsetX=0;\n          shape.offsetY=-shape.radius;\n          shape.centerPosition=\"Top\";\n        } \n      }\n      else if(shape.className==\"Image\") {\n        threshold1=shape.image.height*shape.scaleY/3;\n        threshold2=shape.image.height*shape.scaleY*2/3;\n        if(dist>=threshold1 && dist<=threshold2){\n          shape.offsetX=shape.image.width/2;\n          shape.offsetY=shape.image.height/2;\n          shape.centerPosition=\"Middle\";\n        }else if(dist>threshold2){\n          shape.offsetX=shape.image.width/2;\n          shape.offsetY=shape.image.height;\n          shape.centerPosition=\"Bottom\";\n        }\n        else {\n          shape.offsetX=shape.image.width/2;\n          shape.offsetY=0;\n          shape.centerPosition=\"Top\";\n        }\n      }\n      else if(shape.className==\"Text\") {\n        threshold1=shape.length_y*shape.scaleY/3;\n        threshold2=shape.length_y*shape.scaleY*2/3;\n        if(dist>=threshold1 && dist<=threshold2){\n          shape.offsetX=shape.length_x/2;\n          shape.offsetY=shape.length_y/2;\n          shape.centerPosition=\"Middle\";\n        }else if(dist>threshold2){\n          shape.offsetX=shape.length_x/2;\n          shape.offsetY=shape.length_y;\n          shape.centerPosition=\"Bottom\";\n        }\n        else{\n          shape.offsetX=shape.length_x/2;\n          shape.offsetY=0;\n          shape.centerPosition=\"Top\";\n        }\n      }\n      else if(shape.className==\"Triangle\") {\n        dist=dist+shape.radius*shape.scaleY;\n        threshold1=shape.radius*shape.scaleY/2;\n        threshold2=shape.radius*shape.scaleY*5/4;\n        if(dist>=threshold1 && dist<=threshold2){\n          shape.offsetX=0;\n          shape.offsetY=0;\n        }else if(dist>threshold2){\n          shape.offsetX=0;\n          shape.offsetY=shape.radius/2\n          shape.centerPosition=\"Bottom\";\n        }\n        else{\n          shape.offsetX=0;\n          shape.offsetY=-shape.radius;\n          shape.centerPosition=\"Top\";\n        }\n      }\n      shape.y=shape.y-(last_offsetY-shape.offsetY)*shape.scaleY*Math.cos(shape.rotation*(Math.PI/180));\n      shape.x=shape.x+(last_offsetY-shape.offsetY)*shape.scaleY*Math.sin(shape.rotation*(Math.PI/180));\n      this.selectedShapeAlignment=shape.centerPosition;\n\n      if (res.grp_id!='-1'){\n        this.updateAllPosInGrp(res.grp_id);\n      }\n        \n      e.target.x(shape.x);\n      e.target.y(shape.y);\n\n     \n\n      \n  }\n  },\n  /*\n  ChangeAlignCenter(align_choice){\n    let center=CenterMenu.props.ConcernedShape;\n    let grp=this.groups.find((r)=>r.id===this.selectedShapeId);\n    let shape;\n    if(grp!=undefined){\n      for(let i=0;i<grp.shapes_g.length;i++){\n        this.ChangeCenterRegardingCommand(grp.shapes_g[i].id,align_choice)\n      }\n      center.x(grp.line.x);\n      center.y(grp.line.y);\n      if(grp.line.defaultAlignment==align_choice){\n        grp.line.defaultAlignment='' //If we select again the same alogn_choice, we deselect it, no alignement center is fixed.\n      }else{\n        grp.line.defaultAlignment=align_choice;\n      }\n      this.selectedShapeAlignment=grp.line.defaultAlignment;\n    }else{\n      shape=this.findShape(this.selectedShapeId).shape_data;\n      this.ChangeCenterRegardingCommand(shape.id,align_choice)\n      this.selectedShapeAlignment=shape.centerPosition;\n      center.x(shape.x);\n      center.y(shape.y);\n    }\n  },\n  */\n  //Allow to change the center regarding a text command (Top,Middle or Bottom)\n  ChangeCenterRegardingCommand(shape_id,command){\n    let res=this.findShape(shape_id);\n    let shape=res.shape_data;\n    let last_offsetY=shape.offsetY;\n    if(shape.className==\"Rect\" ){\n      if(command==\"Top\"){\n        shape.offsetY=0;\n        shape.offsetX=shape.width/2;\n      }\n      else if(command==\"Middle\"){\n          shape.offsetX=shape.width/2;\n          shape.offsetY=shape.height/2;\n      }else if(command==\"Bottom\"){\n            shape.offsetX=shape.width/2;\n            shape.offsetY=shape.height;\n      }\n    }\n      else if(shape.className==\"Circle\") {\n        if(command==\"Top\"){\n          shape.offsetX=0;\n          shape.offsetY=-shape.radius;\n        }else if(command==\"Middle\"){\n          shape.offsetX=0;\n          shape.offsetY=0\n        }else if(command==\"Bottom\"){\n          shape.offsetX=0;\n          shape.offsetY=shape.radius;\n        } \n      }\n      else if(shape.className==\"Image\") {\n        if(command==\"Middle\"){\n          shape.offsetX=shape.image.width/2;\n          shape.offsetY=shape.image.height/2;\n        }else if(command==\"Bottom\"){\n          shape.offsetX=shape.image.width/2;\n          shape.offsetY=shape.image.height;\n        }\n        else if (command==\"Top\"){\n          shape.offsetX=shape.image.width/2;\n          shape.offsetY=0;\n        }\n      }\n      else if(shape.className==\"Text\") {\n        if(command==\"Middle\"){\n          shape.offsetX=shape.length_x/2;\n          shape.offsetY=shape.length_y/2;\n        }else if(command==\"Bottom\"){\n          shape.offsetX=shape.length_x/2;\n          shape.offsetY=shape.length_y;\n        }\n        else if(command==\"Top\"){\n          shape.offsetX=shape.length_x/2;\n          shape.offsetY=0;\n        }\n      }\n      else if(shape.className==\"Triangle\") {\n        if(command==\"Middle\"){\n          shape.offsetX=0;\n          shape.offsetY=0;\n        }else if(command==\"Bottom\"){\n          shape.offsetX=0;\n          shape.offsetY=shape.radius/2;\n        }\n        else if(command==\"Top\"){\n          shape.offsetX=0;\n          shape.offsetY=-shape.radius;\n        }\n      }\n      shape.centerPosition=command;\n      shape.y=shape.y-(last_offsetY-shape.offsetY)*shape.scaleY*Math.cos(shape.rotation*(Math.PI/180));\n      shape.x=shape.x+(last_offsetY-shape.offsetY)*shape.scaleY*Math.sin(shape.rotation*(Math.PI/180));\n\n      if (res.grp_id!='-1'){\n        this.updateAllPosInGrp(res.grp_id);\n      }\n        \n      //center.x(shape.x);\n      //center.y(shape.y);\n  },\n  updateDragFuncOfCenter(){\n    let shape=this.findShape(this.selectedShapeId).shape_data\n    let center=this.center;\n    let angle=shape.rotation*(Math.PI/180);\n    if(angle>=-Math.PI/2 && angle<=0){\n      angle-=90*(Math.PI/180);\n    }else if(angle<-Math.PI/2){\n      angle+=(Math.PI/2);\n      angle=Math.PI+angle;\n    } else if(angle<=Math.PI && angle>0){\n      angle-=90*(Math.PI/180);\n    } \n    if (angle<=0 && angle>=-Math.PI/4){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x +(pos.x-shape.x)*Math.cos(angle),\n          y: shape.y+(pos.x-shape.x)*Math.sin(angle),\n        };\n      }\n    } else if (angle<-Math.PI/4 && angle>=-Math.PI/2){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x-(pos.y-shape.y)*Math.cos(angle),\n          y: shape.y-(pos.y-shape.y)*Math.sin(angle),\n        };\n      }\n    }\n    else if (angle<-Math.PI/2 && angle>=-3*Math.PI/4){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x-(pos.y-shape.y)*Math.cos(angle),\n          y: shape.y-(pos.y-shape.y)*Math.sin(angle),\n        };\n      }\n    } else if (angle<-3*Math.PI/4 && angle>=-Math.PI){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x-(pos.x-shape.x)*Math.cos(angle),\n          y: shape.y-(pos.x-shape.x)*Math.sin(angle),\n        };\n      }\n    }else if (angle<=Math.PI && angle>=3*Math.PI/4){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x-(pos.x-shape.x)*Math.cos(angle),\n          y: shape.y-(pos.x-shape.x)*Math.sin(angle),\n        };\n      }\n    } else if (angle<3*Math.PI/4 && angle>=Math.PI/2){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x+(pos.y-shape.y)*Math.cos(angle),\n          y: shape.y+(pos.y-shape.y)*Math.sin(angle),\n        };\n      }\n    } else if (angle<Math.PI/2 && angle>=Math.PI/4){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x+(pos.y-shape.y)*Math.cos(angle),\n          y: shape.y+(pos.y-shape.y)*Math.sin(angle),\n        };\n      }\n    }else if (angle<Math.PI/4 && angle>=0){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x+(pos.x-shape.x)*Math.cos(angle),\n          y: shape.y+(pos.x-shape.x)*Math.sin(angle),\n        };\n      }\n    }\n  },\n  MovingCenter(){\n    //let shape=this.findShape(this.selectedShapeId)\n    //console.log(e.target)\n  },\n  /*\n  //called when the \"Change Center\" button is clicked\n  ChangeCenterButtonAction(){\n      let shape= ContextMenu.props.ConcernedShape;\n      if(shape.attrs.className==\"Line\"){\n        let shapes_g=shape.getParent().attrs.shapes_g //the list of the shapes which are on the line is in the corresponding group.\n        for (let j=0;j<shapes_g.length;j++){\n          this.ChangeCenter(shapes_g[j]);\n        }\n      }else{\n        let shape_data=this.shapes.find(i => i.id ===shape.attrs.id);\n        let isFunded=true;\n        if(shape_data==undefined){\n          isFunded=false;\n        }\n        let i=0;\n        while(!isFunded){\n          if(i<this.groups.length){\n            shape_data=this.groups[i].shapes_g.find(i => i.id === shape.attrs.id);\n          if(shape_data==undefined){\n            isFunded=false;\n          }else{\n            isFunded=true;\n          }\n          i++;\n          }else{        \n            isFunded=true;\n          }\n        }\n        this.ChangeCenter(shape_data)\n      }\n    },\n    */\n    \n    //allow to copy a target\n    /*\n    Copy(){\n      ContextMenu.props.CopiedShape=ContextMenu.props.ConcernedShape;\n      ContextMenu.props.pastOneObject=true;\n    },\n    CopyAll(){\n      ContextMenu.props.CopiedShape=ContextMenu.props.ConcernedShape;\n      ContextMenu.props.pastOneObject=false;\n    },\n    Past(){   \n      //Prevent error when no shape is copied\n      if(ContextMenu.props.CopiedShape.attrs==undefined){\n        return;\n      }\n      let clone=ContextMenu.props.CopiedShape.clone({\n        id: ''+this.max_id_figures,\n      })\n      //let layer=ContextMenu.props.CopiedShape.getLayer();\n      let i= this.groups.length\n      //let new_id=i+1;\n      if(ContextMenu.props.CopiedShape.attrs.className==\"Line\"){\n        this.max_id_figures=this.max_id_figures+1;\n        if(!ContextMenu.props.pastOneObject){\n          //let i= this.groups.length;\n          //let new_id=i+1;\n        \n          clone=ContextMenu.props.CopiedShape.getParent().clone({\n            id: ''+ this.max_id_figures,\n            name: \"group\"+this.max_id_figures,\n            shapes_g:[],\n          })\n          clone.attrs.line.id=''+this.max_id_figures;\n          clone.attrs.line.x=ContextMenu.props.ConcernedShape.getStage().getPointerPosition().x;\n          clone.attrs.line.y=ContextMenu.props.ConcernedShape.getStage().getPointerPosition().y;\n          let positionPoints=Object.assign([],clone.attrs.line.positionPoints);\n            let length=positionPoints.length;\n            clone.attrs.line.positionPoints=[];\n            for(let i=0;i<length.valueOf();i++){\n              let clone_positionPoint=ContextMenu.props.CopiedShape.getParent().getChildren().find((r)=>r.attrs.id===positionPoints[i].id).clone({\n              id:'positionPoint'+clone.attrs.line.id+i,\n              });\n              clone.attrs.line.positionPoints.push(clone_positionPoint.attrs,);\n            }\n          \n          //layer= ContextMenu.props.CopiedShape.getParent().getLayer();\n          this.groups.push(clone.attrs,);\n          let shapesg=this.groups[this.groups.indexOf(this.groups.find((r)=> r.id==ContextMenu.props.CopiedShape.getParent().attrs.id))].shapes_g;\n          let shapesg_length=shapesg.length;\n          for (let j=0; j<shapesg_length;j++){\n            this.max_id_figures=this.max_id_figures + 1;\n            let clone_shape=ContextMenu.props.CopiedShape.getParent().getChildren().find((r)=>r.attrs.id===shapesg[j].id).clone({\n              id:''+this.max_id_figures,\n            });\n           // this.updateDragFunc(clone_shape,clone_line);\n            this.groups[i].shapes_g.push(clone_shape.attrs,);\n            this.updateDragFunc(this.groups[i].shapes_g[this.groups[i].shapes_g.length-1],this.groups[i].line);\n          }\n          this.updateAllPosInGrp(clone.attrs.id);\n        }else{\n          //let i= this.groups.length;\n          //let new_id=i+1;\n        \n          clone=ContextMenu.props.CopiedShape.getParent().clone({\n            id: ''+this.max_id_figures,\n            name: \"group\"+this.max_id_figures,\n            shapes_g:[],\n          })\n          clone.attrs.line.id=''+this.max_id_figures;\n          clone.attrs.line.x=ContextMenu.props.ConcernedShape.getStage().getPointerPosition().x;\n          clone.attrs.line.y=ContextMenu.props.ConcernedShape.getStage().getPointerPosition().y;\n          for(let j=0;j<clone.attrs.line.occupiedDistances.length;j++){\n            clone.attrs.line.freeDistances.push(clone.attrs.line.occupiedDistances[j],);\n          }\n          clone.attrs.line.occupiedDistances=[];\n          if(clone.attrs.line.keepDistribution!=1){\n            let positionPoints=Object.assign([],clone.attrs.line.positionPoints);\n            let length=positionPoints.length;\n            clone.attrs.line.positionPoints=[];\n            for(let i=0;i<length.valueOf();i++){\n              let clone_positionPoint=ContextMenu.props.CopiedShape.getParent().getChildren().find((r)=>r.attrs.id===positionPoints[i].id).clone({\n              id:'positionPoint'+clone.attrs.line.id+i,\n              });\n              clone.attrs.line.positionPoints.push(clone_positionPoint.attrs,);\n            }\n          }\n          //layer= ContextMenu.props.CopiedShape.getParent().getLayer();\n          this.groups.push(clone.attrs,)\n        }\n        //In order to actualize the new line (in particular to show the positionPoints):\n        this.updateAllPosInGrp(clone.attrs.id)\n      } \n      else{\n        this.max_id_figures=this.max_id_figures + 1;\n        clone=ContextMenu.props.CopiedShape.clone({\n          id: ''+this.max_id_figures,  \n          x:ContextMenu.props.ConcernedShape.getStage().getPointerPosition().x,\n          y:ContextMenu.props.ConcernedShape.getStage().getPointerPosition().y,\n        });\n        clone.attrs.dragBoundFunc=function (pos) {\n          return {\n            x: pos.x,\n            y: pos.y,\n          };\n        };\n        clone.attrs.isGrouped=0;\n        this.shapes.push(clone.attrs,); \n         \n      }\n      //layer.batchDraw(); \n      \n    },\n    //RemoveShape(shape)\n    Remove(shape){\n      //let shape=ContextMenu.props.ConcernedShape;\n      if(shape.attrs.className==\"Line\"){\n        let grp=this.groups.find((r)=>r.id===shape.attrs.id);\n        const length=grp.shapes_g.length;\n        for(let i=0;i<length;i++){\n          grp.shapes_g[i].dragBoundFunc= dragFunc;\n          grp.shapes_g[i].isGrouped=0;\n          this.shapes.push(grp.shapes_g[i],);\n        }\n        this.eraseNodefromTransformer(\"lineTransformer\");\n        this.groups.splice(this.groups.indexOf(grp),1);\n        shape.getParent().destroy();\n\n        //We give to the circle (representing center of shapes) a default position\n        if(this.groups[0]!=undefined){\n          this.center.x=this.groups[0].line.x;\n          this.center.y=this.groups[0].line.y;\n        } else if(this.shapes[0]!=undefined){\n          this.center.x=this.shapes[0].x;\n          this.center.y=this.shapes[0].y;\n        }\n        this.center.opacity=0;\n        \n      }else if(shape.attrs.className==\"positionPoint\"){\n        let line=shape.getParent().attrs.line;\n        let target_positionPoint=line.positionPoints.find((r)=>r.id===shape.attrs.id);\n        let index=line.freeDistances.indexOf(shape.attrs.distance_to_line_center);\n        console.log(line.positionPoints);\n        if(line.keepDistribution!=1 && index!=-1){\n          line.freeDistances.splice(index,1);\n          line.positionPoints.splice(line.positionPoints.indexOf(target_positionPoint),1)\n        }\n      }\n      else{\n        let res=this.findShape(shape.attrs.id)\n        let shape_data=res.shape_data;\n        let grp_id=res.grp_id;\n        if(shape_data!=undefined){\n        if(grp_id!='-1'){\n        //let shape_data=this.shapes.find(i => i.id ===shape.attrs.id);\n        let grp=this.groups.find((r)=>r.id===grp_id);\n          grp.line.freeDistances.push(grp.line.occupiedDistances[grp.shapes_g.indexOf(shape_data)],)\n          grp.line.occupiedDistances.splice(grp.shapes_g.indexOf(shape_data),1)\n          \n          grp.shapes_g.splice(grp.shapes_g.indexOf(shape_data),1);\n          this.updateOccupiedDistance(grp.id);\n          \n          this.updateAllPosInGrp(grp.id);\n          \n         console.log(grp.line.positionPoints)\n      \n        } else{\n          this.eraseNodefromTransformer(\"shapeTransformer\");\n          this.shapes.splice(this.shapes.indexOf(shape_data),1);\n          //We give to the circle (representing center of shapes) a default position\n          if(this.groups[0]!=undefined){\n            this.center.x=this.groups[0].line.x;\n            this.center.y=this.groups[0].line.y;\n          } else if(this.shapes[0]!=undefined){\n            this.center.x=this.shapes[0].x;\n            this.center.y=this.shapes[0].y;\n          }\n          this.center.opacity=0;\n        }\n        shape.destroy();\n        }\n      }\n    },\n\n    RemoveAll(){\n      let shape=ContextMenu.props.ConcernedShape;\n      if(shape.className==\"Line\"){\n        let grp=this.groups.find((r)=>r.id===shape.attrs.id);\n        while(grp.shapes_g.length!=0){\n          grp.shapes_g[0].dragBoundFunc= dragFunc;\n          grp.shapes_g.splice(0,1);\n        }\n        this.eraseNodefromTransformer(\"lineTransformer\");\n        this.groups.splice(this.groups.indexOf(grp),1);\n        shape.getParent().destroy();\n\n        //We give to the circle (representing center of shapes) a default position\n        if(this.groups[0]!=undefined){\n          this.center.x=this.groups[0].line.x;\n          this.center.y=this.groups[0].line.y;\n        } else if(this.shapes[0]!=undefined){\n          this.center.x=this.shapes[0].x;\n          this.center.y=this.shapes[0].y;\n        }\n        \n      }else{\n        return;\n      }\n    },\n    */\n\n    findShape(id){\n      let shape_data=this.shapes.find(i => i.id ===id);\n      let grp_id='-1'; // return grp_id=-1 if the shape doesn't belong to attached group.\n      let isFunded=true;\n      if(shape_data==undefined){\n        isFunded=false;\n      }\n      let i=0;\n      while(!isFunded){\n        if(i<this.groups.length){\n          shape_data=this.groups[i].shapes_g.find(i => i.id === id);\n        if(shape_data==undefined){\n          isFunded=false;\n        }else{\n          grp_id=this.groups[i].id; \n          isFunded=true;\n        }\n        i++;\n        }else{        \n          isFunded=true;\n        }\n      }\n      return {shape_data, grp_id}\n    },\n\n    //detach a shape from its line.\n    /*\n    DetachShape(shape){\n      \n      \n      const added_distance=this.lengthToCapture+5;\n      let grp=this.groups.find((r)=>r.shapes_g.indexOf(shape)!=-1);\n      let i=grp.shapes_g.indexOf(shape);\n      \n      shape.dragBoundFunc= dragFunc;\n\n      let coord_y1=grp.line.y-grp.line.points[4]*(1/2)*grp.line.scaleX*Math.sin(grp.line.rotation*(Math.PI/180));\n      let coord_x2=grp.line.x+grp.line.points[4]*(1/2)*grp.line.scaleX*Math.cos(grp.line.rotation*(Math.PI/180));\n      let coord_y2= grp.line.y+grp.line.points[4]*(1/2)*grp.line.scaleX*Math.sin(grp.line.rotation*(Math.PI/180));\n      let coord_x1=grp.line.x-grp.line.points[4]*(1/2)*grp.line.scaleX*Math.cos(grp.line.rotation*(Math.PI/180));\n      let a=(coord_y2-coord_y1)/(coord_x2-coord_x1);\n      //let b=grp.line.y-a*grp.line.x;\n      let b=shape.x*(1/a)+shape.y;\n      if (grp.line.rotation<0 && grp.line.rotation>-90){\n        \n        shape.x=shape.x-added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } else if(grp.line.rotation<-90){\n        shape.x=shape.x+added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } else if( grp.line.rotation>0 && grp.line.rotation<180){\n        \n        shape.x=shape.x+added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } \n      else if(grp.line.rotation==-90){\n        shape.x=shape.x+added_distance\n      } else if(grp.line.rotation==90){\n        shape.x=shape.x-added_distance\n      } else if(grp.line.rotation==180 || grp.line.rotation==-180){\n        shape.y=shape.y-added_distance\n      } else if(grp.line.rotation==0){\n        shape.y=shape.y+added_distance\n      } \n      //shape.rotation=shape.rotation+shape.personalRotation;\n      shape.isGrouped=0;\n      this.shapes.push(shape,)\n      this.center.x=shape.x;\n      this.center.y=shape.y;\n      grp.line.freeDistances.push(grp.line.occupiedDistances[i]);\n      grp.line.occupiedDistances.splice(i,1);\n      grp.shapes_g.splice(i,1);\n      grp.line.positionPoints.splice(i,1)\n      \n      this.updateOccupiedDistance(grp.id)\n      this.updateAllPosInGrp(grp.id)\n      this.updateNaration(grp)\n    \n    },\n    */\n\n    DetachShape(shape,target_x,target_y){\n      \n      \n      const added_distance=this.lengthToCapture+5;\n      let grp=this.groups.find((r)=>r.shapes_g.indexOf(shape)!=-1);\n      let i=grp.shapes_g.indexOf(shape);\n      \n      shape.dragBoundFunc= dragFunc;\n\n      let coord_y1=grp.line.y-grp.line.points[4]*(1/2)*grp.line.scaleX*Math.sin(grp.line.rotation*(Math.PI/180));\n      let coord_x2=grp.line.x+grp.line.points[4]*(1/2)*grp.line.scaleX*Math.cos(grp.line.rotation*(Math.PI/180));\n      let coord_y2= grp.line.y+grp.line.points[4]*(1/2)*grp.line.scaleX*Math.sin(grp.line.rotation*(Math.PI/180));\n      let coord_x1=grp.line.x-grp.line.points[4]*(1/2)*grp.line.scaleX*Math.cos(grp.line.rotation*(Math.PI/180));\n      let a=(coord_y2-coord_y1)/(coord_x2-coord_x1);\n      //let b=grp.line.y-a*grp.line.x;\n      let b=shape.x*(1/a)+shape.y;\n      if (grp.line.rotation<0 && grp.line.rotation>-45){\n        \n        shape.x=shape.x+Math.sign(shape.y-target_y)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } else if (grp.line.rotation<=-45 && grp.line.rotation>-90){\n        \n        shape.x=shape.x+Math.sign(shape.x-target_x)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      }\n      \n      else if(grp.line.rotation<-90 && grp.line.rotation>-135){\n        shape.x=shape.x+Math.sign(shape.x-target_x)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } \n      else if(grp.line.rotation<=-135 && grp.line.rotation>-180){\n        shape.x=shape.x-Math.sign(shape.y-target_y)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } \n      \n      else if( grp.line.rotation>135 && grp.line.rotation<180){\n        \n        shape.x=shape.x-Math.sign(shape.y-target_y)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } else if( grp.line.rotation>90 && grp.line.rotation<=135){\n        \n        shape.x=shape.x-Math.sign(shape.x-target_x)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } else if( grp.line.rotation>45 && grp.line.rotation<=90){\n        \n        shape.x=shape.x-Math.sign(shape.x-target_x)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } else if( grp.line.rotation>0 && grp.line.rotation<=45){\n        \n        shape.x=shape.x+Math.sign(shape.y-target_y)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } \n      else if(grp.line.rotation==-90){\n        shape.x=shape.x-Math.sign(shape.x-target_x)*added_distance\n      } else if(grp.line.rotation==90){\n        shape.x=shape.x+Math.sign(shape.x-target_x)*added_distance\n      } else if(grp.line.rotation==180 || grp.line.rotation==-180){\n        shape.y=shape.y-Math.sign(shape.y-target_y)*added_distance\n      } else if(grp.line.rotation==0){\n        shape.y=shape.y-Math.sign(shape.y-target_y)*added_distance\n      } \n      //shape.rotation=shape.rotation+shape.personalRotation;\n      shape.isGrouped=0;\n      this.shapes.push(shape,)\n      this.center.x=shape.x;\n      this.center.y=shape.y;\n      grp.line.freeDistances.push(grp.line.occupiedDistances[i]);\n      grp.line.occupiedDistances.splice(i,1);\n      grp.shapes_g.splice(i,1);\n      grp.line.positionPoints.splice(i,1)\n      \n      this.updateOccupiedDistance(grp.id)\n      this.updateAllPosInGrp(grp.id)\n      this.updateNaration(grp)\n      this.eraseNodefromTransformer(\"shapeTransformer\");\n    \n    },\n    /*\n\n    //called when the button \"Detach Shape\" is clicked\n    DetachShapeButtonAction(){\n      let shape= ContextMenu.props.ConcernedShape;\n      if(shape.attrs.className==\"Line\"){\n        let shapes_g=shape.getParent().attrs.shapes_g;\n        while(shapes_g.length!=0){\n          this.DetachShape(shapes_g[0]);\n        }\n      }else{\n        let shape_data=this.shapes.find(i => i.id ===shape.attrs.id);\n        let isFunded=true;\n        if(shape_data==undefined){\n          isFunded=false;\n        }\n        let i=0;\n        while(!isFunded){\n          if(i<this.groups.length){\n            shape_data=this.groups[i].shapes_g.find(i => i.id === shape.attrs.id);\n          if(shape_data==undefined){\n            isFunded=false;\n          }else{\n            isFunded=true;\n          }\n          i++;\n          }else{        \n            isFunded=true;\n          }\n        }\n        this.DetachShape(shape_data)\n      }\n    },\n\n    //called when the button \"keep/liberate distribution\" is clicked.\n    KeepDistribution(){\n      let grp=this.groups.find(i => i.id === ContextMenu.props.ConcernedShape.attrs.id);\n      let line=grp.line;\n      if(line==undefined){\n        return;\n      }else{\n        if(line.keepDistribution){\n          line.keepDistribution=false;\n          for (let i=0;i<grp.shapes_g.length;i++){\n            grp.shapes_g[i].distance_to_line_center=line.occupiedDistances[i]\n          }\n          line.freeDistances=[];\n\n          line.stroke='blue'\n          grp.line.keepDistanceButtonText=\"Keep Distribution\";\n          //ContextMenu.props.ConcernedShape.attrs.keepDistanceButtonText=\"Keep Distribution\";\n        }else{\n          line.keepDistribution=true;\n          for (let i=0;i<grp.shapes_g.length;i++){\n            line.occupiedDistances[i]=grp.shapes_g[i].distance_to_line_center;\n          }\n          line.stroke='black'\n          grp.line.keepDistanceButtonText=\"Liberate Distribution\";\n          //ContextMenu.props.ConcernedShape.attrs.keepDistanceButtonText=\"Liberate Distribution\";\n          this.updateOccupiedDistance(line.id);\n          this.updateAllPosInGrp(line.id);\n        }\n      }\n    },\n    */\n    createNewShape(shape){\n      if(shape.attrs.className==\"Line\"){\n        \n        this.max_id_figures=this.max_id_figures+1;\n\n          let clone=shape.getParent().clone({\n            id: ''+this.max_id_figures,\n            name: \"group\"+this.max_id_figures,\n            shapes_g:[],\n          })\n          clone.attrs.line.id=''+this.max_id_figures;\n          clone.attrs.line.x=shape.getStage().getPointerPosition().x;\n          clone.attrs.line.y=shape.getStage().getPointerPosition().y;\n          clone.attrs.line.draggable=true;\n          this.groups.push(clone.attrs,)\n          \n        \n      }else{\n        \n        this.max_id_figures=this.max_id_figures+1\n        let clone=shape.clone({\n          id: ''+this.max_id_figures,\n          draggable: true,\n        })\n        clone.attrs.isGrouped=0;\n        this.shapes.push(clone.attrs,);\n      }\n      \n\n    },\n    \n  \n  eraserAction(e){\n    this.Remove(e.target);\n    \n  },\n  unshowSelectedShape(e){\n    if(e.target.attrs.className==\"Line\" && this.eraseMode==0){\n      e.target.opacity(0.5)\n    }\n    else if(e.target.attrs.className==\"Line\" && this.eraseMode==1){\n      if(e.target.attrs.keepDistribution==1){\n        e.target.stroke(\"rgb(48,48,48)\")\n      }else{\n        e.target.stroke(\"blue\")\n      }\n    }\n    else if(e.target.attrs.className==\"positionPoint\" && this.eraseMode==1){\n      if(e.target.getParent().attrs.line.keepDistribution!=1){\n        e.target.strokeWidth(0)\n      }\n    }\n    else if(this.eraseMode==1){\n      e.target.strokeWidth(0)\n    }\n  },\n  showSelectedShape(e){\n    if(e.target.attrs.className==\"Line\" && this.eraseMode==0){\n      e.target.opacity(1)\n    }\n    else if(e.target.attrs.className==\"Line\" && this.eraseMode==1){\n      e.target.stroke('rgb(200, 59, 218)')\n    }\n    else if(e.target.attrs.className==\"positionPoint\" && this.eraseMode==1){\n      let line=e.target.getParent().attrs.line;\n      if(line.freeDistances.indexOf(e.target.attrs.distance_to_line_center)!=-1){\n        if(line.keepDistribution!=1){\n          e.target.stroke('rgb(200, 59, 218)')\n          e.target.strokeWidth(3)\n        }\n      }\n    }\n    else if(this.eraseMode==1){\n      e.target.stroke('rgb(200, 59, 218)')\n      e.target.strokeWidth(3)\n    }\n    /*\n    let shape=e.target;\n    if(this.eraseMode==1){\n    let shape_data=this.shapes.find(i => i.id ===shape.attrs.id);\n    let isFunded=true;\n    if(shape_data==undefined){\n      isFunded=false;\n      let i=0;\n      while(!isFunded){\n        if(i<this.groups.length){\n          shape_data=this.groups[i].shapes_g.find(i => i.id === shape.attrs.id);\n        if(shape_data==undefined){\n          isFunded=false;\n          i++;\n        }else{\n          isFunded=true;\n        }\n        }else{        \n          isFunded=true;\n        }\n      }\n    }\n    if (shape_data!=undefined){\n      shape_data.opacity=0.3\n    }\n    */\n\n  },\n  editText(e){\n    //let valuey=document.getElementById(\"stage\").style.top+e.target.y()\n    //let valuex=document.getElementById(\"stage\").style.left+e.target.x()\n    let stageBox=e.target.getStage().attrs.container.getBoundingClientRect();\n    document.getElementById(\"input\").style.top=stageBox.y+e.target.getAbsolutePosition().y+'px';\n    document.getElementById(\"input\").style.left=stageBox.x+e.target.getAbsolutePosition().x-document.getElementById(\"input\").size*5+'px';\n    document.getElementById(\"input\").style.display=\"initial\"\n    this.editedText=e.target\n  },\n  updateText(e){\n    let shape=this.shapes.find(i => i.id ===this.editedText.attrs.id);\n    let isFunded=true;\n    if(shape==undefined){\n      isFunded=false;\n    }\n    let i=0;\n    while(!isFunded){\n      if(i<this.groups.length){\n        shape=this.groups[i].shapes_g.find(i => i.id === this.editedText.attrs.id);\n      if(shape==undefined){\n        isFunded=false;\n      }else{\n        isFunded=true;\n      }\n      i++;\n      }else{        \n        isFunded=true;\n      }\n    }\n    if(shape!=undefined){\n    let last_width;\n    let last_height;\n    let diff_width;\n    let diff_height;\n\n    last_width=this.editedText.width();\n    last_height=this.editedText.height();\n\n    shape.text=e.target.value;\n\n    this.editedText.text(e.target.value);\n    diff_width=this.editedText.width()-last_width;\n    diff_height=this.editedText.height()-last_height;\n\n    \n    shape.offsetX=shape.offsetX+diff_width/2\n    shape.offsetY=shape.offsetY+diff_height/2\n    shape.length_x=this.editedText.width()\n    shape.length_y=this.editedText.height()\n    document.getElementById(\"input\").style.display=\"none\"\n    }\n\n  },\n  updateNaration(grp){\n      let text=\"<strong></strong><br>\"\n      text=text+\"- <mark class='red'> StickyLine </mark><br>\";\n      text=text+\"Relation: <i>alignement with</i>:\";\n      for(let j=0;j<grp.shapes_g.length;j++){\n        text=text+\"<br>\"+\"- \"+grp.shapes_g[j].className\n      }\n      this.$emit('explain',{origin:\"Instrument - Reification<br><mark class='red'> The Stickyline reifies alignment into a persistent, directly-manipulable line. </mark>\",text:text});\n  }\n},\n};\n\n</script>\n<style>\n#playground{\n  cursor: default\n}\n#active{\n  position: absolute;\n  display: none;\n  top: 0px;\n  left: 0px;\n  width: 60px;\n  background-color: white;\n  box-shadow: 0 0 5px grey;\n  border-radius: 3px;\n}\n#center_menu{\n  position: absolute;\n  display: none;\n  top: 0px;\n  left: 0px;\n  width: 60px;\n  background-color: white;\n  box-shadow: 0 0 5px grey;\n  border-radius: 3px;\n}\ninput{\n  position:absolute;\n  display: none;\n  top:0px;\n  left:0px; \n}\n</style> ","import { render } from \"./ReificationDemo.vue?vue&type=template&id=e70ab096\"\nimport script from \"./ReificationDemo.vue?vue&type=script&lang=js\"\nexport * from \"./ReificationDemo.vue?vue&type=script&lang=js\"\n\nimport \"./ReificationDemo.vue?vue&type=style&index=0&id=e70ab096&lang=css\"\n\nimport exportComponent from \"/Users/junhangyu/Desktop/PE code/github/teachingApp/node_modules/vue-loader/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render]])\n\nexport default __exports__","<template>\n\n<div @click=\"HideContextMenu\" id=\"ReuseDemo\"\n @focusin=\"initialNaration(this.groups)\"\n@focusout=\"this.narationHasBeenInitialized=false\"\ntabindex=\"0\">\n<!--\n  <ToolBar :height=\"100\" :width=\"400\"\n  @need_new_shape=\"createNewShape\" @eraser_is_selected=\"switchEraseMode\"></ToolBar>\n  -->\n  <v-stage\n    ref=\"stage\"\n    id=\"stage\"\n    :config=\"stageSize\"\n    @dragmove=\"update\"\n    @mousedown=\"handleTransformation\"\n    @touchstart=\"handleTransformation\"\n    @fusion=\"makeGroup\"\n    @contextMenu=\"DisplayContextMenu\"\n  >\n    <v-layer ref=\"layer\">\n      <!--\n        see if a group should contain more than one line\n      -->\n      <!--\n      <v-circle :key=\"center.id\" :config=\"center\"/>\n      -->\n      <v-group ref=\"groups\" v-for=\"step in groups\" :key=\"step.id\" :config=\"step\">\n      \n      \n      \n        <v-rect\n        v-for=\"item in step.shapes_g.filter(i=>i.className=='Rect')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        \n       \n        @transformend=\"updateTransformedShape\"\n        @dragend= \"updatePosInGrp($event,step.id) \"\n        @dragmove=\"CheckIfNeedToDetach\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n      />\n      <v-circle\n        v-for=\"item in step.shapes_g.filter(i=>i.className=='Circle')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragend=\"updatePosInGrp($event,step.id)\"\n        @dragmove=\"CheckIfNeedToDetach\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n      />\n      \n      <v-image\n        v-for=\"item in step.shapes_g.filter(i=>i.className=='Image')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragend=\"updatePosInGrp($event,step.id)\"\n        @dragmove=\"CheckIfNeedToDetach\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n      />\n      <v-text\n        v-for=\"item in step.shapes_g.filter(i=>i.className=='Text')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragend=\"updatePosInGrp($event,step.id)\"\n        @dragmove=\"CheckIfNeedToDetach\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n\n        @dblclick=\"editText\"\n        />\n        <v-regular-polygon\n        v-for=\"item in step.shapes_g.filter(i=>i.className=='Triangle')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragend=\"updatePosInGrp($event,step.id)\"\n        @dragmove=\"CheckIfNeedToDetach\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n      />\n        <v-line \n        :key=\"step.line.id\"\n        :config=\"step.line\"\n        @transformend=\"updateTransformedShape\"\n        @dragmove=\"updateGrp($event,step.id)\"\n        @mouseout=\"unshowSelectedShape\"\n        @mouseenter=\"showSelectedShape\"\n        />\n    <v-circle\n        v-for=\"item in step.line.positionPoints\"\n        :key=\"item.id\"\n        :config=\"item\"\n        \n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n      />\n      </v-group>\n      <v-rect\n        v-for=\"item in shapes.filter(i=>i.className=='Rect')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragmove=\"updatePos\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n        \n      />\n      \n      <v-circle\n        v-for=\"item in shapes.filter(i=>i.className=='Circle')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragmove=\"updatePos\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n        \n      />\n      <!--\n      <v-image\n        v-for=\"item in shapes.filter(i=>i.className=='Image')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragmove=\"updatePos\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n        />\n     \n      <v-text\n        v-for=\"item in shapes.filter(i=>i.className=='Text')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragmove=\"updatePos\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n        \n        @dblclick=\"editText\"\n        /> \n      -->\n      <v-regular-polygon\n        v-for=\"item in shapes.filter(i=>i.className=='Triangle')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragmove=\"updatePos\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n        />\n      \n      \n      <v-transformer  v-for=\"item in transformers\" :key=\"item.id\" :config=\"item\"/>\n      <v-circle :key=\"center.id\" :config=\"center\"\n      @dragend=\"ChangeCenter\"\n      @click=\"DisplayCenterMenu\"/>\n      <!--\n      <v-transformer id=\"shapeTransformer\"/>\n      <v-transformer id=\"lineTransformer\" :config=\"{enabledAnchors: ['middle-left', 'middle-right'],}\" />\n      -->\n    </v-layer>\n    \n  </v-stage>\n  \n  \n  <div id=\"activeReuse\"\n  @focusout=\"stopInitialisation\"\n  tabindex=\"1\">\n  <ContextMenu :menu-of-stage=\"isStageOnlySelected\" :menu-of-line=isALineSelected \n  :menu-of-grouped-shape=isAGroupedShapeSelected :keep-distance-button-text=\"this.keepDistanceButtonText\" :need-switch-distribution-mode-button=\"false\"\n  :need-copy-all-button=\"false\"\n\n \n  @changecenter-button=\"ChangeCenterButtonAction\" @detachshape-button=\"DetachShapeButtonAction\" @keepdistance-button=\"KeepDistribution\"\n  @copy-button=\"Copy\" @copy-all-button=\"CopyAll\" @past-button=\"Past\" @remove-button=\"Remove\" @remove-all-button=\"RemoveAll\"></ContextMenu>\n  </div>\n  <!--\n  <div id=\"center_menu\">\n  <CenterMenu :defaultAlignment=\"this.selectedShapeAlignment\" @center-button=\"ChangeAlignCenter\"></CenterMenu>\n  </div>\n  -->\n  </div>\n</template>\n\n<script>\n\nimport ContextMenu from \"@/components/interactive-components-for-canvas/ContextMenu.vue\"\n//import CenterMenu from \"./CenterMenu.vue\"\n//import ToolBar from \"./ToolBar.vue\";\n\nconst dragFunc=function (pos) {\n  let width=this.getStage().width();\n  let height=this.getStage().height();\n  let strokeSize=10\n    if(pos.x>width-strokeSize && pos.y>height-strokeSize){\n      return{\n        x: width-strokeSize,\n        y: height-strokeSize,\n      }\n    } else if(pos.x>width-strokeSize && pos.y<strokeSize){\n      return{\n        x: width-strokeSize,\n        y: strokeSize,\n      }\n    } else if(pos.y>height-strokeSize && pos.x<strokeSize){\n      return{\n        x: strokeSize,\n        y: height-strokeSize,\n      }\n    } else if(pos.x<strokeSize && pos.y<strokeSize){\n      return{\n        x: strokeSize,\n        y: strokeSize,\n      }\n    } else if(pos.x<strokeSize){\n      return{\n        x: strokeSize,\n        y: pos.y,\n      }\n    }else if(pos.y<strokeSize){\n      return{\n        x: pos.x,\n        y: strokeSize,\n      }\n    }else if(pos.x>width-strokeSize){\n      return{\n        x: width-strokeSize,\n        y: pos.y,\n      }\n    }else if(pos.y>height-strokeSize){\n      return{\n        x: pos.x,\n        y: height-strokeSize,\n      }\n    } else{\n      return {\n        x: pos.x,\n        y: pos.y,\n      };\n    }\n};\n\n\nexport default {\n  props:{\n    width:{\n      type: Number,\n      default:window.innerWidth,\n    },\n    height:{\n      type: Number,\n      default:window.innerHeight,\n    }\n  },\n  components:{\n    ContextMenu,\n    //CenterMenu,\n    //ToolBar,\n},\n  data() {\n    return {\n      stageSize: {\n        width: this.width,\n        height: this.height,\n      },\n      narationHasBeenInitialized:false, //to know if the naration has to be initialized or not\n\n      lengthToCapture:10,\n      lengthToDetach:15,\n      editedText:null,\n\n      eraseMode:0,\n\n      selectedShapeAlignment:'',\n      \n      needMenu: 'initial', //say if the context menu has to be \"active\" or not.\n      isALineSelected:false, \n      isAGroupedShapeSelected:false,\n      isStageOnlySelected: false,\n      //dragItemId: null, //id of the item which is dragging.\n      //text which will appear on the button corresponding to the management of the distribution\n      keepDistanceButtonText:\"Liberate Distribution\",\n      max_id_figures: 6, //max among id of shapes and line since the canvas exist (line excluded) \n      //max_id_lines: 2, //max among id of lines since the canvas exist (line excluded) \n      //groups of shapes (ie a line with shapes on it)\n      groups:[{\n        //rotation: 20,\n        name: \"group\",\n        className: \"Group\",\n        id: '1',\n        x:0,\n        y:0,\n        offsetX:0,\n        offsetY:0,\n        rotation: 0,\n        draggable: false,\n        shapes_g:[ {\n        rotation:0,\n        x: 20,\n        y: 320,\n        scaleX:1,\n        scaleY:1,\n        offsetX: 0,\n        offsetY: 40,\n        radius: 40,\n        fill: 'orange',\n        strokeWidth: 0,\n        stroke: 'black',\n        draggable:true,\n        isGrouped: 1,\n        className:\"Circle\",\n        /*When it is on a line, a shape can be rotate by the user independently from the line.\n          To keep the independant rotation of the attached shape, we add the parameter \"personalRotation\".\n          So, when the shape is attached, is final rotation is the sum of this parameter with the rotation of the line.\n          */\n        personalRotation:0, \n        id:'2',\n        dragBoundFunc: dragFunc,\n        centerPosition:'Bottom',\n      },\n        {\n        rotation:0,\n        x: 110,\n        y: 320,\n        scaleX:1,\n        scaleY:1,\n        offsetX: 0,\n        offsetY: 40,\n        radius: 40,\n        fill: 'orange',\n        strokeWidth: 0,\n        stroke: 'black',\n        draggable:true,\n        isGrouped: 1,\n        className:\"Circle\",\n        /*When it is on a line, a shape can be rotate by the user independently from the line.\n          To keep the independant rotation of the attached shape, we add the parameter \"personalRotation\".\n          So, when the shape is attached, is final rotation is the sum of this parameter with the rotation of the line.\n          */\n        personalRotation:0, \n        id:'3',\n        dragBoundFunc: dragFunc,\n        centerPosition:'Bottom',\n      },{\n        rotation:0,\n        x: 200,\n        y: 320,\n        scaleX:1,\n        scaleY:1,\n        offsetX: 0,\n        offsetY: 40,\n        radius: 40,\n        fill: 'orange',\n        strokeWidth: 0,\n        stroke: 'black',\n        draggable:true,\n        isGrouped: 1,\n        className:\"Circle\",\n        /*When it is on a line, a shape can be rotate by the user independently from the line.\n          To keep the independant rotation of the attached shape, we add the parameter \"personalRotation\".\n          So, when the shape is attached, is final rotation is the sum of this parameter with the rotation of the line.\n          */\n        personalRotation:0, \n        id:'4',\n        dragBoundFunc: dragFunc,\n        centerPosition:'Bottom',\n      }], //list of shapes that are on the line\n        //the line of the group:\n        aShapeHasBeenDetach:0,\n        line:{\n          x:150,\n          y:250,\n          points: [0, 0, 0, 0, 250, 0],\n          positionPoints:[{\n        x: 300,\n        y: 500,\n        scaleX:1,\n        scaleY:1,\n        offsetX: 0,\n        offsetY: 0,\n        radius: 3,\n        fill: 'yellow',\n        opacity:1,\n        draggable:false,\n        isGrouped: 0,\n        className:\"positionPoint\",\n        id:'positionPoint1',\n        distance_to_line_center:undefined,\n      },{\n        x: 300,\n        y: 500,\n        scaleX:1,\n        scaleY:1,\n        offsetX: 0,\n        offsetY: 0,\n        radius: 3,\n        fill: 'yellow',\n        opacity:1,\n        draggable:false,\n        isGrouped: 0,\n        className:\"positionPoint\",\n        id:'positionPoint2',\n        distance_to_line_center:undefined,\n      },{\n        x: 300,\n        y: 500,\n        scaleX:1,\n        scaleY:1,\n        offsetX: 0,\n        offsetY: 0,\n        radius: 3,\n        fill: 'yellow',\n        opacity:1,\n        draggable:false,\n        isGrouped: 0,\n        className:\"positionPoint\",\n        id:'positionPoint3',\n        distance_to_line_center:undefined,\n      },],\n          strokeWidth: 10,\n          rotation: 0,\n          tension:0,\n          closed: true,\n          draggable: true,\n          scaleX:1,\n          scaleY:1,\n          opacity:0.5,\n          offset:{\n            x:125,\n            y:0,\n          },\n          name: \"ligne\",\n          className: \"Line\",\n          stroke: 'blue',\n          id:'1',\n          //distShapesToCenter:[],\n          keepDistribution: false, //say of we keep the distribution on the line or not\n          freeDistances:[], // distance that can be taken by other shapes (if we keep distribution on the line).\n          occupiedDistances:[-95,-25,80], //distance already \"taken\" by shapes on the line.       \n          //text which will appear on the button corresponding to the management of the distribution:\n          keepDistanceButtonText:\"Liberate Distribution\",\n          //function which determine how the line can be dragged:\n          defaultAlignment:\"Bottom\",\n          dragBoundFunc: dragFunc,\n        },\n      },\n      /*{\n        name: \"group2\",\n        className: \"Group\",\n        id: '7',\n        x:0,\n        y:0,\n        offsetX:0,\n        offsetY:0,\n        rotation: 0,\n        draggable: false,\n        shapes_g:[],\n        line:{\n        x:500,\n        y:300,\n        points: [0, 0, 0, 0, 300, 0],\n        positionPoints:[],\n        strokeWidth: 10,\n        rotation: 0,\n        tension:0,\n        closed: true,\n        draggable: true,\n        scaleX:1,\n        scaleY:1,\n        opacity:0.5,\n        offset:{\n          x:150,\n          y:0,\n        },\n        //draggable:true,\n        name: \"ligne\",\n        className: \"Line\",\n        stroke: 'black',\n        id:'7',\n        distShapesToCenter:[],\n        keepDistribution: true,\n        freeDistances:[],\n        occupiedDistances:[],\n        keepDistanceButtonText:\"Liberate Distribution\",\n        defaultAlignment:\"Middle\",\n        dragBoundFunc: dragFunc,\n      },\n      \n      }*/\n      ],\n      transformers:[\n        {\n          id: 'lineTransformer',\n          enabledAnchors: [],\n          rotateEnabled: false,\n          borderEnabled:false,\n          flipEnabled: false, // in order to not have a rotation of the transformer which lead to problem related to shapes position on a line\n          nodes: [],\n\n        },\n        {\n          id: 'shapeTransformer',\n          nodes: [],\n        }\n      ],\n      shapes: [\n        /*\n        {\n          rotation: 0,\n          id: '1',\n          x: 100,\n          y: 10,\n          width: 130,\n          height: 100,\n          scaleX: 1,\n          scaleY: 1,\n          strokeWidth: 0,\n          stroke: 'black',\n          fill: 'red',\n          name: 'rect1',\n          draggable: true,\n          className:\"Rect\",\n          isGrouped: 0, //if =0 the shape is not attached to a stickyline. if=1, it does.\n          offsetX:130/2,\n          offsetY:0,\n          personalRotation:0, \n          centerPosition:'Top',\n          dragBoundFunc: dragFunc\n          \n        },\n        */\n        \n        {\n          rotation: 0,\n          id:'5',\n          x: 150,\n          y: 120,\n          sides:3,\n          radius:45,\n          width: 90,\n          height: 90,\n          scaleX: 1,\n          scaleY: 1,\n          strokeWidth: 0,\n          stroke: 'black',\n          fill: 'purple',\n          name: 'triangle1',\n          draggable: true,\n          className:\"Triangle\",\n          isGrouped: 0,\n          dragBoundFunc: dragFunc,\n          offsetX: 0,\n          offsetY: 22.5,\n          personalRotation:0, \n          centerPosition:'Bottom',\n        },\n      {\n          rotation: 0,\n          id:'6',\n          x: 50,\n          y: 70,\n          sides:3,\n          radius:45,\n          width: 90,\n          height: 90,\n          scaleX: 1,\n          scaleY: 1,\n          strokeWidth: 0,\n          stroke: 'black',\n          fill: 'purple',\n          name: 'triangle1',\n          draggable: true,\n          className:\"Triangle\",\n          isGrouped: 0,\n          dragBoundFunc: dragFunc,\n          offsetX: 0,\n          offsetY: 22.5,\n          personalRotation:0, \n          centerPosition:'Bottom',\n        },\n      /*\n        {\n            text: 'A text',\n            rotation: 0,\n            x: 400,\n            y: 200,           \n            scaleX:1,\n            scaleY:1,\n            offsetY:0,\n            offsetX: 36,\n            length_x:72,\n            length_y:30,\n            draggable: true,\n            isGrouped: 0,\n            className:\"Text\",    \n            fontSize: 30,\n            fontFamily: 'Calibri',\n          personalRotation:0,\n            id:'4',\n            dragBoundFunc:dragFunc,\n            centerPosition:'Top',\n        },\n        {\n            rotation: 0,\n            x: 700,\n            y: 400,           \n            scaleX:1,\n            scaleY:1,\n            offsetY:0,\n            offsetX:0,\n            //width:72,\n            //height:30,\n            image: null,\n            draggable: true,\n            isGrouped: 0,\n            className:\"Image\", \n               \n            fontSize: 30,\n          personalRotation:0, \n            id:'5',\n            dragBoundFunc:dragFunc,\n            centerPosition:'Top',\n        },\n        */\n         {\n          rotation: 0,\n          id:'7',\n          x: 250,\n          y: 100,\n          sides:3,\n          radius:45,\n          width: 90,\n          height: 90,\n          scaleX: 1,\n          scaleY: 1,\n          strokeWidth: 0,\n          stroke: 'black',\n          fill: 'purple',\n          name: 'triangle1',\n          draggable: true,\n          className:\"Triangle\",\n          isGrouped: 0,\n          dragBoundFunc: dragFunc,\n          offsetX: 0,\n          offsetY: 22.5,\n          personalRotation:0, \n          centerPosition:'Bottom',\n        },\n      ],\n      center:{\n        x: 300,\n        y: 500,\n        scaleX:1,\n        scaleY:1,\n        offsetX: 0,\n        offsetY: 0,\n        radius: 4,\n        fill: 'black',\n        opacity:1,\n        draggable:true,\n        isGrouped: 0,\n        className:\"Circle\",\n        id:'center',\n        dragBoundFunc:dragFunc,\n      },\n      positionPoint:{\n        x: 300,\n        y: 500,\n        scaleX:1,\n        scaleY:1,\n        offsetX: 0,\n        offsetY: 0,\n        radius: 3,\n        fill: 'yellow',\n        opacity:1,\n        draggable:false,\n        isGrouped: 0,\n        className:\"positionPoint\",\n        id:'positionPoint',\n        distance_to_line_center:undefined,\n      },\n      selectedShapeId: '',\n    };\n  },\n  mounted(){\n    let texts=this.$refs.stage.getStage().getChildren()[0].getChildren().filter((r)=>r.attrs.className=='Text');\n    \n    \n    for(let i=0;i<texts.length;i++){\n      texts[i].attrs.length_x=texts[i].width();\n      texts[i].attrs.length_y=texts[i].height();\n      texts[i].offsetX(texts[i].attrs.length_x/2);\n    }\n    let grp=this.groups[0];\n    let line=grp.line;\n    let shapes_g=grp.shapes_g;\n    for(let i=0;i<shapes_g.length;i++){\n      this.updateDragFunc(shapes_g[i],line);\n      \n      this.updateAllPosInGrp(grp.id);\n    }\n  },\n  created(){\n    //nb of shapes on the canvas (line excluded), we consider that there is no shape on line:\n    this.max_id_figures=this.shapes.length +this.groups.length;\n    for(let i=0;i<this.groups.length;i++){\n      this.max_id_figures= this.max_id_figures+this.groups[i].shapes_g.length;\n    }\n    //this.max_id_lines=this.groups.length;\n    /*\n    const image = new window.Image();\n    image.src = require(\"@/assets/exsitu.png\");\n    // set image only when it is loaded\n    image.height=150;\n    image.width=150;\n    image.onload = () => {\n      this.shapes.find((r)=>r.className===\"Image\").image= image;\n      this.shapes.find((r)=>r.className===\"Image\").offsetX=image.width/2;\n      this.shapes.find((r)=>r.className===\"Image\").offsetY=0; \n    };\n    */\n  },\n  methods: {\n    //this function is here to avoid the execution of the function initialNaration.\n    \n\n    switchEraseMode(){\n      if(this.eraseMode==0){\n        this.eraseMode=1;\n        document.getElementById(\"playground\").style.cursor='url('+require('@/assets/ugly_eraser.png')+'),default';\n        \n      this.eraseNodefromTransformer(\"shapeTransformer\");\n      this.eraseNodefromTransformer(\"lineTransformer\");\n      } else{\n        this.eraseMode=0;\n        document.getElementById(\"playground\").style.cursor=\"default\";\n      }\n    },\n    /*\n    Check if all shapes that are supposed to be on a line still in this line.\n    id_grp is the id of the group which contains the line.\n    */\n    checkIfShapesOnLine(id_grp){\n      const grp= this.groups.find((r) => r.id===id_grp);\n      const line=grp.line;\n      const groupedShapes = grp.shapes_g;\n      //const lengthToDetach=10;\n      \n      /*\n      To determine if a shape is on a line, we see if the point is not on the corresponding\n      straight line y=a*x+b regarding certains intervals for x and y.Those intervals depends of the rotation of\n      the line. \n      */\n     /*\n      let coord_y1=line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x1=line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let coord_y2= line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x2=line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let a=(coord_y1-coord_y2)/(coord_x2-coord_x1);\n      let b=line.y-a*line.x;\n      let is_on_straight_line=false;\n      */\n      \n      let i=0;\n      while(i<groupedShapes.length){\n        /*\n        if(Math.abs(coord_x1-coord_x2)>1){\n        is_on_straight_line=(Math.abs(a*groupedShapes[i].x+b-groupedShapes[i].y)<this.lengthToDetach);\n      }else{\n        is_on_straight_line=(Math.abs(groupedShapes[i].x-line.x)<this.lengthToDetach);\n      }\n        if (\n          !(is_on_straight_line)\n        ||((line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].y\n        ||line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].y)\n        && ((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n        ||((line.x+line.points[4]*line.scaleX*(1/2)*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].x\n        ||line.x-line.points[4]*line.scaleX*(1/2)*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].x)\n        &&((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n        ||((line.y+line.points[4]*line.scaleX*(1/2)*Math.sin(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].y\n        ||line.y-line.points[4]*line.scaleX*(1/2)*Math.sin(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].y)\n        &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>=-Math.PI)))\n\n        ||((line.x+line.points[4]*line.scaleX*(1/2)*Math.cos(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].x\n        ||line.x-line.points[4]*line.scaleX*(1/2)*Math.cos(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].x)\n        &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>=-Math.PI)))\n\n        ||((line.y+line.points[4]*line.scaleX*(1/2)*Math.sin(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].y\n        ||line.y-line.points[4]*line.scaleX*(1/2)*Math.sin(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].y)\n        &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n        ||((line.x+line.points[4]*line.scaleX*(1/2)*Math.cos(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].x\n        ||line.x-line.points[4]*line.scaleX*(1/2)*Math.cos(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].x)\n        &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n        ||((line.y+line.points[4]*line.scaleX*(1/2)*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].y\n        ||line.y-line.points[4]*line.scaleX*(1/2)*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].y)\n        &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>0)))\n\n        ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].x\n        ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].x)\n        &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>0)))\n        )\n        */\n       if(!this.isCoordinateOnLine(groupedShapes[i].x,groupedShapes[i].y,line.id)){\n          console.log(\"a shape is not on a line\");\n          groupedShapes[i].dragBoundFunc= dragFunc;\n          groupedShapes[i].isGrouped=0;\n          if(line.keepDistribution){\n            line.positionPoints.slice(i,1)\n          }\n          this.shapes.push(groupedShapes[i],)\n          line.freeDistances.push(line.occupiedDistances[i]);\n          line.occupiedDistances.splice(i,1);\n          groupedShapes.splice(i,1);\n          \n          this.updateNaration(grp)\n        }else{\n          i=i+1;\n        }\n      }\n    },\n\n    //say of {x,y} is a point from the line\n    isCoordinateOnLine(x,y,id_grp){\n      const grp=this.groups.find((r) => r.id===id_grp);\n      const line=grp.line;\n      let is_not_on_straight_line=true;\n      let coord_y1=line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x1=line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let coord_y2= line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x2=line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let a=(coord_y1-coord_y2)/(coord_x2-coord_x1);\n      let b=line.y-a*line.x;\n      if(Math.abs(coord_x1-coord_x2)>1){\n        is_not_on_straight_line=(Math.abs(a*x+b-y)>1);\n      }else{\n        is_not_on_straight_line=(Math.abs(x-line.x)>1)\n      }\n      if(\n        (is_not_on_straight_line)\n\n      ||((line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<y\n      ||line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>y)\n      && ((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<x\n        ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>x)\n      &&((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<y\n        ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>y)\n      &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>-Math.PI)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>x)\n      &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>-Math.PI)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>y)\n      &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>x)\n      &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>y)\n      &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>=0)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>x)\n      &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>=0)))\n\n      ||(!is_not_on_straight_line && Math.sqrt((line.x-x)**2+(line.y-y)**2)>line.points[4]*line.scaleX/2)\n\n      )\n      {\n        return false; \n      } else{\n        return true;\n      }\n    },\n\n    //update a group with the id id_grp\n    updateGrp(e,id_grp){\n      const grep=this.groups.find((r)=>r.id===id_grp);\n      const line= grep.line;\n      grep.offsetX=line.offsetX;\n      grep.offsetY=line.offsetY;\n      \n      line.x=e.target.x();\n      line.y=e.target.y();\n      this.center.x=line.x;\n      this.center.y=line.y;\n      /*\n      if(line.keepDistribution){\n        this.updateOccupiedDistance(line.id);\n      }\n      */\n      this.updateAllPosInGrp(line.id); \n      this.checkIfShapesOnLine(line.id);\n    },\n\n\n    //update the position of all shapes that are on the line of the group with the id id_grp.\n    updateAllPosInGrp(id_grp){\n      const grp= this.groups.find((r) => r.id===id_grp);     \n      const line= grp.line;\n      const shapes_g = grp.shapes_g;\n      for (let i=0;i<shapes_g.length;i++){\n          if(line.keepDistribution){\n            shapes_g[i].x=line.x+line.occupiedDistances[i]*Math.cos(line.rotation*(Math.PI/180));\n            shapes_g[i].y=line.y+line.occupiedDistances[i]*Math.sin(line.rotation*(Math.PI/180));\n            shapes_g[i].distance_to_line_center=line.occupiedDistances[i];\n            shapes_g[i].rotation=shapes_g[i].personalRotation+line.rotation;\n            \n          } else{\n            shapes_g[i].x=line.x+line.occupiedDistances[i]*Math.cos(line.rotation*(Math.PI/180));\n            shapes_g[i].y=line.y+line.occupiedDistances[i]*Math.sin(line.rotation*(Math.PI/180));\n            shapes_g[i].distance_to_line_center=line.occupiedDistances[i];\n            shapes_g[i].rotation=shapes_g[i].personalRotation+line.rotation;\n          }\n          line.positionPoints[i].x=shapes_g[i].x;\n          line.positionPoints[i].y=shapes_g[i].y;\n          line.positionPoints[i].distance_to_line_center=shapes_g[i].distance_to_line_center;\n      }\n      let i=shapes_g.length;\n      while(i<line.positionPoints.length){\n        if(line.keepDistribution){\n          line.positionPoints.splice(i,1);\n        }else{\n        line.positionPoints[i].x=line.x+line.freeDistances[i-shapes_g.length]*Math.cos(line.rotation*(Math.PI/180));\n        line.positionPoints[i].y=line.y+line.freeDistances[i-shapes_g.length]*Math.sin(line.rotation*(Math.PI/180));\n        line.positionPoints[i].distance_to_line_center=line.freeDistances[i-shapes_g.length];\n        i++;\n        }\n        \n      }\n    \n    },\n    isOutsideTheLine(shape,line){\n      let coord_y1=line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x1=line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let coord_y2= line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x2=line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let a=(coord_y1-coord_y2)/(coord_x2-coord_x1);\n      let b=line.y-a*line.x;\n      let is_on_straight_line=false;\n      if(Math.abs(coord_x1-coord_x2)>=1){\n        is_on_straight_line=(Math.abs(a*shape.x+b-shape.y)<1);\n      }else{\n        is_on_straight_line=(Math.abs(shape.x-line.x)<1);\n      }\n      if(\n        !(is_on_straight_line)\n      ||((line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n        ||line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      && ((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>-Math.PI)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>-Math.PI)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>=0)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>=0)))\n      ){\n        return true;\n      }else{ return false}\n    },\n    \n    //update the canvas\n    update(){\n      const shapes = this.shapes\n      \n      //const lengthToCapture=10; //bigger is the number, bigger is the intervals of x and y where a shape can be added to a line.\n      let is_on_straight_line=false;\n      for (let i=0;i<shapes.length;i++){\n        let x=shapes[i].x;\n        let y=shapes[i].y;\n      for (let j=0;j<this.groups.length;j++){\n      \n        let line=this.groups[j].line;\n\n        \n        let coord_y1=line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n        let coord_x1=line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n        let coord_y2= line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n        let coord_x2=line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n        let a=(coord_y1-coord_y2)/(coord_x2-coord_x1);\n        let b=line.y-a*line.x;\n        if(Math.abs(coord_x1-coord_x2)>1){\n          is_on_straight_line=(Math.abs(a*x+b-y)<=this.lengthToCapture);\n        }else{\n          is_on_straight_line=(Math.abs(x-line.x)<=this.lengthToCapture);\n          //is_on_straight_line=true;\n        }\n        if(\n        (\n          is_on_straight_line\n      &&(line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToCapture>=y\n      && line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToCapture<=y)\n      &&(line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToCapture>=x\n      && line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToCapture<=x)\n      &&(line.rotation*(Math.PI/180)<=0 \n      && line.rotation*(Math.PI/180)>-Math.PI/2))\n\n      ||(\n        is_on_straight_line\n      &&(line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))+this.lengthToCapture>=y\n      && line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))-this.lengthToCapture<=y) \n      &&(line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))+this.lengthToCapture>=x\n      && line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))-this.lengthToCapture<=x)\n      &&(line.rotation*(Math.PI/180)<=-Math.PI/2 \n      && line.rotation*(Math.PI/180)>=-Math.PI))\n\n      ||(\n        is_on_straight_line\n      &&(line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))+this.lengthToCapture>=y\n      &&line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))-this.lengthToCapture<=y)\n      &&(line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))+this.lengthToCapture>=x\n      && line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))-this.lengthToCapture<=x)\n      &&(line.rotation*(Math.PI/180)<=Math.PI \n      && line.rotation*(Math.PI/180)>Math.PI/2))\n\n      ||(\n        is_on_straight_line\n      &&(line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToCapture>=y\n      && line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToCapture<=y)\n      &&(line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToCapture>=x\n      && line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToCapture<=x)\n      &&(line.rotation*(Math.PI/180)<=Math.PI/2\n      && line.rotation*(Math.PI/180)>=0))\n      )\n       {\n          shapes[i].isGrouped=1;\n          this.makeGroup(line.id);\n          \n        }\n      }\n      }\n    },\n\n    CheckIfNeedToDetach(e){\n      let grp=this.groups.find((r)=>r.id===e.target.getParent().attrs.id);\n      let shape= grp.shapes_g.find((r)=>r.id==e.target.id());\n      let dist=Math.sqrt((e.target.getStage().getPointerPosition().y-e.target.y())**2+(e.target.getStage().getPointerPosition().x-e.target.x())**2);\n      if(e.target.className==\"Rect\"){\n        dist-=e.target.attrs.height*e.target.attrs.scaleY;\n      } else if(e.target.className==\"Circle\"){\n        dist-=(2*e.target.attrs.radius)*e.target.attrs.scaleY;\n      } else if(e.target.className==\"Text\"){\n        dist-=e.target.attrs.length_y*e.target.attrs.scaleY;\n      } else if(e.target.className==\"Image\"){\n        dist-=e.target.height()*e.target.scaleY();\n      } else if(e.target.attrs.className==\"Triangle\"){\n        dist-=e.target.height()*e.target.scaleY();\n      } \n      \n      if (dist>50){\n        //let shape= this.groups.find((r)=>r.id===e.target.getParent().attrs.id).shapes_g.find((r)=>r.id==e.target.id());\n        //this.groups.find((r)=>r.id===e.target.getParent().attrs.id).shapes_g.find((r)=>r.id==e.target.id()).needToBeDetach=1;\n        /*\n        shape.dragBoundFunc= function (pos) {\n              return {\n                x: pos.x,\n                y: pos.y,\n              };\n        }\n        */\n        //shape.x=e.target.getStage().getPointerPosition().x;\n        //shape.y=e.target.getStage().getPointerPosition().y;\n        //if (Math.abs(e.target.getStage().getPointerPosition().y-e.target.y())>220){\n        \n        //shape.x=e.target.getStage().getPointerPosition().x;\n        //shape.y=e.target.getStage().getPointerPosition().y;\n        this.groups.find((r)=>r.id===e.target.getParent().attrs.id).aShapeHasBeenDetach=1;\n        this.DetachShape(shape,e.target.getStage().getPointerPosition().x,e.target.getStage().getPointerPosition().y);\n        //}\n        \n        \n        \n      }\n    },\n\n    //Give the sign of the distance of shape from the center of a line.\n    GiveSignOfDistance(shape,line){\n      let result;\n      let angle=line.rotation*(Math.PI/180);\n      let distX=shape.x-line.x;\n      let distY=shape.y-line.y;\n      /*\n      \n      if(angle<=-Math.PI/4 || angle>=-Math.PI/2){\n        result=-Math.sign(distY);\n      }\n      else if(angle<=-Math.PI/2 || angle>=-3*Math.PI/4){\n        result=Math.sign(distY);\n      }\n      else if(angle<=-3*Math.PI/4 || angle>=-Math.PI){\n        result=-Math.sign(distX);\n      }else if(angle>=3*Math.PI/4 || angle<=Math.PI){\n        result=Math.sign(distX);\n      }else if(angle>=Math.PI/2 || angle<3*Math.PI/4){\n        result=-Math.sign(distY);\n      } else if(angle<=Math.PI/2 || angle>Math.PI/4){\n        result=-Math.sign(distY);\n      } else if(angle<=Math.PI/4 || angle>=0){\n        result=Math.sign(distX);\n      }\n      */\n      \n      \n      if(Math.abs(distX)<=this.lengthToCapture && line.rotation==-90){\n        \n        result=-Math.sign(distY);\n      } else if (Math.abs(distX)<=this.lengthToCapture && line.rotation==90){\n        result=Math.sign(distY);\n      }\n      else{\n        result=Math.sign(distX);\n      }\n      if(angle<-Math.PI/2 || angle>Math.PI/2){\n        result=-result;\n      }\n      \n      return result;\n    },\n\n    //Different from the previous function bcs the straight line of the center is perdendicular to the line\n    GiveSignOfDistanceBtwCenterAndShape(center,shape){\n      let result;\n      let angle=shape.rotation*(Math.PI/180);\n      let distX=center.x-shape.x;\n      let distY=center.y-shape.y;\n      /*\n      \n      if(angle<=-Math.PI/4 || angle>=-Math.PI/2){\n        result=-Math.sign(distY);\n      }\n      else if(angle<=-Math.PI/2 || angle>=-3*Math.PI/4){\n        result=Math.sign(distY);\n      }\n      else if(angle<=-3*Math.PI/4 || angle>=-Math.PI){\n        result=-Math.sign(distX);\n      }else if(angle>=3*Math.PI/4 || angle<=Math.PI){\n        result=Math.sign(distX);\n      }else if(angle>=Math.PI/2 || angle<3*Math.PI/4){\n        result=-Math.sign(distY);\n      } else if(angle<=Math.PI/2 || angle>Math.PI/4){\n        result=-Math.sign(distY);\n      } else if(angle<=Math.PI/4 || angle>=0){\n        result=Math.sign(distX);\n      }\n      */\n      \n      \n      if(Math.abs(distY)<=this.lengthToCapture && shape.rotation==-90){\n        \n        result=Math.sign(distX);\n      } else if (Math.abs(distY)<=this.lengthToCapture && shape.rotation==90){\n        result=-Math.sign(distX);\n      }\n      else{\n        result=Math.sign(distY);\n      }\n      if(angle<-Math.PI/2 || angle>Math.PI/2){\n        result=-result;\n      }\n      \n      return result;\n    },\n\n    /*add shapes with isGrouped==1 to the group with the id id_grp.\n    */\n    makeGroup(id_grp){\n      this.eraseNodefromTransformer(\"shapeTransformer\");\n      this.eraseNodefromTransformer(\"lineTransformer\");\n      const grp=this.groups.find((r)=> r.id===id_grp);\n      const line=grp.line;\n      const shapes = this.shapes;\n      line.freeDistances.sort(this.isSmaller); //we will give the shortest available distance to the added shape\n      shapes.sort(this.isBeforeRegardingX);\n      for (let i=0;i<shapes.length;i++){\n        if(shapes[i].isGrouped==1){\n          const positionPoint=Object.assign({},this.positionPoint);\n          let distX=shapes[i].x-line.x;\n          let distY=shapes[i].y-line.y; \n          shapes[i].personalRotation=0;\n          //let pot_dist=this.GiveSignOfDistance(shapes[i],line)*Math.sqrt((distX)**2+(distY)**2);\n          /*\n          if(line.keepDistribution && line.freeDistances.length>0){\n          let distances=line.freeDistances+line.occupiedDistances;\n          console.log(distances);\n           let freeDistance=this.isNearest(line.freeDistances,pot_dist);\n           //shapes[i].distance_to_line_center=freeDistance.res; \n           shapes[i].distance_to_line_center=this.GiveSignOfDistance(shapes[i],line)*Math.sqrt((distX)**2+(distY)**2);\n            \n           line.occupiedDistances.push(shapes[i].distance_to_line_center,);\n           line.freeDistances.splice(freeDistance.indice,1);\n\n          } else{\n            */\n            //let distX=shapes[i].x-line.x;\n            //let distY=shapes[i].y-line.y;\n            shapes[i].distance_to_line_center=this.GiveSignOfDistance(shapes[i],line)*Math.sqrt((distX)**2+(distY)**2);\n            /*If the distance is a little bit to far from the center \n            we adjust it so that the shape can be at one of the border of the stickyline*/\n            if(Math.abs(shapes[i].distance_to_line_center)>=line.points[4]*line.scaleX/2){\n              shapes[i].distance_to_line_center=Math.sign(shapes[i].distance_to_line_center)*line.points[4]*line.scaleX/2\n            }\n            this.ChangeCenterRegardingCommand(shapes[i].id,grp.line.defaultAlignment);\n            if(!line.keepDistribution && line.freeDistances.length>0){\n              let indice=this.isNearest(line,shapes[i]);\n              //console.log(indice);\n              //shapes[i].distance_to_line_center=line.freeDistances[indice];\n              //line.freeDistances.splice(indice,1);\n              //shapes[i].isGrouped=0;\n              this.updateDragFunc(shapes[i],line);\n              grp.shapes_g.push(shapes[i],);\n              grp.line.occupiedDistances.push(grp.line.freeDistances[indice]);\n              grp.line.freeDistances.splice(indice,1);\n              //this.updateOccupiedDistance(grp.line.id);\n\n            }else{\n              //shapes[i].isGrouped=0;\n              this.updateDragFunc(shapes[i],line);\n              grp.shapes_g.push(shapes[i],);\n              console.log(\"no 'free distance' anymore\")\n              grp.line.occupiedDistances.push(shapes[i].distance_to_line_center,);\n              positionPoint.id=\"positionPoint\"+grp.id+grp.line.positionPoints.length;\n              grp.line.positionPoints.push(positionPoint,);\n              //shapes[i].distance_to_line_center=this.GiveSignOfDistance(shapes[i],line)*Math.sqrt((distX)**2+(distY)**2);\n            }\n            //line.occupiedDistances.push(shapes[i].distance_to_line_center,);\n          //}\n          console.log(\"A new shape has been added with a distance\"+shapes[i].distance_to_line_center);\n          //shapes[i].isGrouped=0;\n          //this.updateDragFunc(shapes[i],line);\n          //grp.shapes_g.push(shapes[i],);\n          this.updateOccupiedDistance(line.id);\n          \n          this.updateAllPosInGrp(id_grp);\n          shapes.splice(i,1);\n        }\n      }\n      \n      this.updateNaration(grp)\n      this.center.x=line.x;\n      this.center.y=line.y;\n    },\n\n    updateOccupiedDistance(id_grp){\n      \n      const grp=this.groups.find((r)=> r.id===id_grp);\n      //this.updateAllPosInGrp(id_grp);\n      this.sortByDistToLineCenter(grp);\n      \n      //let l=grp.line.points[4]/2;\n      if(grp.line.keepDistribution){\n      let L=grp.line.points[4];\n      let nb_shapes=grp.shapes_g.length;\n      let d=(L/(nb_shapes-1))*grp.line.scaleX;\n      if(nb_shapes%2==0){\n        \n      for (let i =1;i<=nb_shapes/2-1;i++){\n        //grp.line.occupiedDistances[i-1]=-(l/i);\n        grp.line.occupiedDistances[i-1]=-((nb_shapes/2-1)-i+1)*d-d/2\n      }\n      for (let i =1;i<=nb_shapes/2-1;i++){\n        grp.line.occupiedDistances[nb_shapes/2+i]=i*d+d/2;\n      }\n      grp.line.occupiedDistances[nb_shapes/2-1]=-d/2\n      grp.line.occupiedDistances[nb_shapes/2]=d/2\n      } else{\n        for (let i =1;i<=(nb_shapes-1)/2;i++){\n          grp.line.occupiedDistances[i-1]=-d*(((nb_shapes-1)/2)-i+1);\n        }\n        for (let i =1;i<=(nb_shapes-1)/2;i++){\n          grp.line.occupiedDistances[((nb_shapes-1)/2)+i]=d*i;\n        }\n        grp.line.occupiedDistances[(nb_shapes-1)/2]=0;\n      }\n      \n      for (let i=0;i<grp.shapes_g.length;i++){\n        grp.shapes_g[i].distance_to_line_center=grp.line.occupiedDistances[i];\n      }\n      }\n      else{\n        grp.line.occupiedDistances.sort(this.isSmaller);\n      }\n      \n      \n      \n    \n\n    },\n\n   isSmaller(a,b){\n    if(a<b){\n      return -1;\n    }else{\n      return 1\n    }\n   },\n\n   isBeforeRegardingX(a,b){\n    if(a.x<b.x){\n      return -1;\n    }else{\n      return 1;\n    }\n   },\n\n    \n   updateOccDist(grp,shape){\n    let res=this.isNearest(grp.line,shape);\n    //let grp=this.groups.find((r)=>r.id===line.id);\n    if(res.isFree){\n      shape.distance_to_line_center=grp.line.freeDistances[res.indice];\n      grp.line.freeDistances.splice(res.indice,1);\n      this.sortByDistToLineCenter(grp);\n      for(let l=0;l<grp.shapes_g.length;l++){\n        if(grp.line.occupiedDistances.length==l){\n          grp.line.occupiedDistances.push(grp.shapes_g[l].distance_to_line_center,);\n        }else{\n          grp.line.occupiedDistances[l]=grp.shapes_g[l].distance_to_line_center;\n        }\n      } \n    } else{\n      grp.shapes_g.find((r)=>r.id==shape.id).distance_to_line_center=grp.line.occupiedDistances[res.indice];\n      grp.line.occupiedDistances.splice(res.indice,1);\n      //line.occupiedDistances.push(shape.distance_to_line_center,);\n      //line.freeDistances.splice(res.indice,1);   \n      this.updateOccDist(grp,grp.shapes_g[res.indice]);\n    }\n   },\n   isNearest(line,shape){\n    let ecart;\n    let invx=line.x+line.freeDistances[0]*Math.cos(line.rotation*(Math.PI/180));\n    let invy=line.y+line.freeDistances[0]*Math.sin(line.rotation*(Math.PI/180));\n    let ecart_min=Math.sqrt((invx-shape.x)**2+(invy-shape.y)**2);\n    let indice=0;\n    for(let i=1;i<line.freeDistances.length;i++){\n      invx=line.x+line.freeDistances[i]*Math.cos(line.rotation*(Math.PI/180));\n      invy=line.y+line.freeDistances[i]*Math.sin(line.rotation*(Math.PI/180));\n      ecart=Math.sqrt((invx-shape.x)**2+(invy-shape.y)**2);\n      if(ecart<ecart_min){\n        //res=line.freeDistances[i];\n        ecart_min=ecart;\n        indice=i;\n      }\n    }\n    return indice;\n    /*\n    let allDist=line.freeDistances.concat(line.occupiedDistances);\n    console.log(allDist);\n    \n    let ecart;\n    let invx=line.x+allDist[0]*Math.cos(line.rotation*(Math.PI/180));\n    let invy=line.y+allDist[0]*Math.sin(line.rotation*(Math.PI/180));\n    let ecart_min=Math.sqrt((invx-shape.x)**2+(invy-shape.y)**2)\n    let indice=0;\n    console.log(ecart_min);\n    for(let i=1;i<allDist.length;i++){\n      invx=line.x+allDist[i]*Math.cos(line.rotation*(Math.PI/180));\n      invy=line.y+allDist[i]*Math.sin(line.rotation*(Math.PI/180));\n      ecart=Math.sqrt((invx-shape.x)**2+(invy-shape.y)**2);\n      if(this.groups.find((r)=>r.id==line.id).shapes_g.indexOf(shape)!=-1){\n        console.log(ecart_min);\n        console.log(ecart);\n        if(ecart<ecart_min && ecart!=0){\n          //res=allDist[i];\n          ecart_min=ecart;\n          indice=i;\n        }\n      }else if(ecart<ecart_min){\n        //res=allDist[i];\n        ecart_min=ecart;\n        indice=i;\n      }\n    }\n    console.log(indice);\n    if(indice>=line.freeDistances.length){\n      return{\n        isFree: false,\n        indice: indice-line.freeDistances.length,\n      }\n    }else{\n      return{\n        isFree: true,\n        indice: indice,\n      }\n    }\n    */\n\n    /*\n    line.freeDistances.sort(this.isSmaller);\n    let ecart;\n    let invx=line.x+line.freeDistances[0]*Math.cos(line.rotation*(Math.PI/180));\n    let invy=line.y+line.freeDistances[0]*Math.sin(line.rotation*(Math.PI/180));\n    let ecart_min=Math.sqrt((invx-shape.x)**2+(invy-shape.y)**2)\n    let indice=0;\n    for(let i=0;i<line.freeDistances.length;i++){\n      invx=line.x+line.freeDistances[i]*Math.cos(line.rotation*(Math.PI/180));\n      invy=line.y+line.freeDistances[i]*Math.sin(line.rotation*(Math.PI/180));\n      ecart=Math.sqrt((invx-shape.x)**2+(invy-shape.y)**2)\n      if(ecart<ecart_min){\n        //res=freeDistances[i];\n        ecart_min=ecart;\n        indice=i;\n      }\n    }\n    return indice;\n    */\n    /*\n    if(shapeDistance>=0){\n      for(let i=0;i<freeDistances.length;i++){\n        if(freeDistances[i]>shapeDistance){\n          return i;\n        }\n      }\n      return freeDistances.length-1;\n    }else{\n      let ecart_min=Math.abs(Math.abs(freeDistances[0])-Math.abs(shapeDistance))\n      let indice=0;\n      for(let i=0;i<freeDistances.length;i++){\n        let ecart=Math.abs(Math.abs(freeDistances[i])-Math.abs(shapeDistance));\n        if(ecart<ecart_min){\n          //res=freeDistances[i];\n          ecart_min=ecart;\n          indice=i;\n        }\n      }\n      return indice;\n    }\n    */\n    /*\n    //let res=freeDistances[0];\n    let ecart_min=Math.abs(Math.abs(freeDistances[0])-Math.abs(shapeDistance))\n    let indice=0;\n    for(let i=0;i<freeDistances.length;i++){\n      let ecart=Math.abs(Math.abs(freeDistances[i])-Math.abs(shapeDistance));\n      if(ecart<ecart_min){\n        //res=freeDistances[i];\n        ecart_min=ecart;\n        indice=i;\n      }\n    }\n    return indice;\n    */\n   },\n   \n\n   sortByDistToLineCenter(grp){\n    //this.updateAllPosInGrp(grp.id)\n    //let last_distX=new Array(grp.shapes_g.length);\n    \n    //let distX;\n    //let distY;\n    //let sign;\n    //let dist=new Array(grp.shapes_g.length);\n    //let angle;\n    if(grp.line.keepDistribution){\n      for (let l=0;l<grp.shapes_g.length;l++){\n          let distX=grp.shapes_g[l].x-grp.line.x;\n          let distY=grp.shapes_g[l].y-grp.line.y;\n          //dist[l]=this.GiveSignOfDistance(grp.shapes_g[l],grp.line)*Math.sqrt((distX)**2+(distY)**2);\n          grp.shapes_g[l].distance_to_line_center=this.GiveSignOfDistance(grp.shapes_g[l],grp.line)*Math.sqrt((distX)**2+(distY)**2);\n          //last_distX[l]=distX;\n        }\n    }\n    for(let i=1;i<grp.shapes_g.length;i++){\n      \n     \n      let shape=grp.shapes_g[i];\n      //let distance=dist[i];\n      let j=i\n      while(j>0 && grp.shapes_g[j-1].distance_to_line_center>shape.distance_to_line_center){\n        grp.shapes_g[j]=grp.shapes_g[j-1];\n        //dist[j]=dist[j-1]\n        j=j-1;\n      }\n      grp.shapes_g[j]=shape;\n      //dist[j]=distance;\n    }\n   },\n   \n\n   sortAnyShapesByDistToLineCenter(shapes,line){\n    //this.updateAllPosInGrp(grp.id)\n    //let last_distX=new Array(grp.shapes_g.length);\n    \n    //let distX;\n    //let distY;\n    //let sign;\n    //let dist=new Array(grp.shapes_g.length);\n    //let angle;\n    for (let l=0;l<shapes.length;l++){\n        let distX=shapes[l].x-line.x;\n        let distY=shapes[l].y-line.y;\n        /*\n        angle=grp.shapes_g[l].rotation*(Math.PI/180);\n\n      \n      if(angle<=-Math.PI/4 || angle>=-Math.PI/2){\n        sign=-Math.sign(distY);\n      }\n      else if(angle<=-Math.PI/2 || angle>=-3*Math.PI/4){\n        sign=Math.sign(distY);\n      }\n      else if(angle<=-3*Math.PI/4 || angle>=-Math.PI){\n        sign=-Math.sign(distX);\n      }else if(angle>=3*Math.PI/4 || angle<=Math.PI){\n        sign=Math.sign(distX);\n      }else if(angle>=Math.PI/2 || angle<3*Math.PI/4){\n        sign=-Math.sign(distY);\n      } else if(angle<=Math.PI/2 || angle>Math.PI/4){\n        sign=-Math.sign(distY);\n      } else if(angle<=Math.PI/4 || angle>=0){\n        sign=Math.sign(distX);\n      }\n       console.log(sign);\n        */\n       \n        /*\n        if(Math.sin(grp.line.rotation*(Math.PI/180))==0){\n            grp.shapes_g[l].distance_to_line_center=grp.shapes_g[l].x-grp.line.x;\n        }else{\n            grp.shapes_g[l].distance_to_line_center=Math.sign(distX)*Math.sqrt((distX)**2+(distY)**2);\n          \n            if(grp.line.rotation*(Math.PI/180)<=-Math.PI/2 || grp.line.rotation*(Math.PI/180)<=Math.PI/2 &&grp.line.rotation*(Math.PI/180)>=0){\n              grp.shapes_g[l].distance_to_line_center=-grp.shapes_g[l].distance_to_line_center\n            }\n        }\n        */\n        //dist[l]=this.GiveSignOfDistance(grp.shapes_g[l],grp.line)*Math.sqrt((distX)**2+(distY)**2);\n        shapes.distance_to_line_center=this.GiveSignOfDistance(shapes,line)*Math.sqrt((distX)**2+(distY)**2);\n        /*\n        if((grp.line.rotation*(Math.PI/180)<=-Math.PI/2 || (grp.line.rotation*(Math.PI/180)<=Math.PI/2 && grp.line.rotation*(Math.PI/180)>=0)) && (Math.sign(last_distX[l])!=Math.sign(distX))){\n          grp.shapes_g[l].distance_to_line_center=-grp.shapes_g[l].distance_to_line_center\n        }\n        */\n        //last_distX[l]=distX;\n      }\n    for(let i=1;i<shapes.length;i++){\n      \n     \n      let shape=shapes[i];\n      //let distance=dist[i];\n      let j=i\n      while(j>0 && shapes[j-1].distance_to_line_center>shape.distance_to_line_center){\n        shapes[j]=shapes[j-1];\n        //dist[j]=dist[j-1]\n        j=j-1;\n      }\n      shapes[j]=shape;\n      //dist[j]=distance;\n    }\n   },\n\n  \n\n   /*\n   update the drag function of a shape which is on a line. \n   */\n   updateDragFunc(shape,line){\n          let angle=line.rotation*(Math.PI/180);\n          if (angle<=0 && angle>=-Math.PI/4){\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x +(pos.x-line.x)*Math.cos(angle),\n                y: line.y+(pos.x-line.x)*Math.sin(angle),\n              };\n            }\n          } else if (angle<-Math.PI/4 && angle>=-Math.PI/2){\n            // We prefer, in this case, moving the shape of the line regarding the y of the mouse position instead of the x.\n            // So that the user can move the shape more intuitively\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x-(pos.y-line.y)*Math.cos(angle),\n                y: line.y-(pos.y-line.y)*Math.sin(angle),\n              };\n            }\n          }\n          else if (angle<-Math.PI/2 && angle>=-3*Math.PI/4){\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x-(pos.y-line.y)*Math.cos(angle),\n                y: line.y-(pos.y-line.y)*Math.sin(angle),\n              };\n            }\n          } else if (angle<-3*Math.PI/4 && angle>=-Math.PI){\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x-(pos.x-line.x)*Math.cos(angle),\n                y: line.y-(pos.x-line.x)*Math.sin(angle),\n              };\n            }\n          }else if (angle<=Math.PI && angle>=3*Math.PI/4){\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x-(pos.x-line.x)*Math.cos(angle),\n                y: line.y-(pos.x-line.x)*Math.sin(angle),\n              };\n            }\n          } else if (angle<3*Math.PI/4 && angle>=Math.PI/2){\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x+(pos.y-line.y)*Math.cos(angle),\n                y: line.y+(pos.y-line.y)*Math.sin(angle),\n              };\n            }\n          } else if (angle<Math.PI/2 && angle>=Math.PI/4){\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x+(pos.y-line.y)*Math.cos(angle),\n                y: line.y+(pos.y-line.y)*Math.sin(angle),\n              };\n            }\n          }else if (angle<Math.PI/4 && angle>=0){\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x+(pos.x-line.x)*Math.cos(angle),\n                y: line.y+(pos.x-line.x)*Math.sin(angle),\n              };\n            }\n          }\n   },\n\n   /*\n   Update the position of a free shape when it is dragging.\n   */\n    updatePos(e){\n      const shape = this.shapes.find(i => i.id === e.target.id());\n      shape.x=e.target.x();\n      shape.y=e.target.y();\n      this.center.x=e.target.x();\n      this.center.y=e.target.y();\n\n      let pos = { x: shape.x, y: shape.y };\n      e.target.position(pos);\n      e.target.getLayer().batchDraw();\n      \n    },\n\n    /*\n    Update the positio  of shape attached to a line (from the group with id=id_grp) when it is dragging.\n     */\n    updatePosInGrp(e,id_grp){\n      let distX;\n      let distY;\n      let distance_to_line_center;\n      const grp=this.groups.find((r)=> r.id===id_grp);\n      \n      if(grp.aShapeHasBeenDetach==1){\n        grp.aShapeHasBeenDetach=0;\n        return;\n      }\n      const line=grp.line;\n      const shape = grp.shapes_g.find(i => i.id === e.target.id());\n      const shapes_g = grp.shapes_g; \n      //const lengthToDetach=10;\n      if(shape.needToBeDetach==1){\n        shape.needToBeDetach=0;\n        this.DetachShape(shape);\n        this.updateAllPosInGrp(e.target.getParent().attrs.id);\n      }\n      if(line.keepDistribution){\n        if(this.isCoordinateOnLine(e.target.x(),e.target.y(),line.id)){\n          distX=shape.x-e.target.x();\n          distY=shape.y -e.target.y();\n          let L=grp.line.points[4];\n          let nb_shapes=grp.shapes_g.length;\n          let d=(L/(nb_shapes-1))*grp.line.scaleX;\n          let dist=Math.sqrt(distX**2 +distY**2);\n          if(dist>=d){\n            shape.x=e.target.x();\n            shape.y=e.target.y();\n            this.updateOccupiedDistance(line.id)\n            shape.x=line.x+line.occupiedDistances[shapes_g.indexOf(shape)]*Math.cos(line.rotation*(Math.PI/180));\n            shape.y=line.y+line.occupiedDistances[shapes_g.indexOf(shape)]*Math.sin(line.rotation*(Math.PI/180));\n            shape.distance_to_line_center=line.occupiedDistances[shapes_g.indexOf(shape)];\n            shape.rotation=line.rotation;\n            this.updateAllPosInGrp(line.id);\n          }else{\n            shape.x=line.x+line.occupiedDistances[shapes_g.indexOf(shape)]*Math.cos(line.rotation*(Math.PI/180));\n            shape.y=line.y+line.occupiedDistances[shapes_g.indexOf(shape)]*Math.sin(line.rotation*(Math.PI/180));\n            shape.distance_to_line_center=line.occupiedDistances[shapes_g.indexOf(shape)];\n            shape.rotation=line.rotation; \n          }   \n        }else{\n          shape.x=e.target.x();\n          shape.y=e.target.y();\n        }\n        line.positionPoints[grp.shapes_g.indexOf(shape)].x=shape.x;\n        line.positionPoints[grp.shapes_g.indexOf(shape)].y=shape.y;\n        line.positionPoints[grp.shapes_g.indexOf(shape)].distance_to_line_center=shape.distance_to_line_center; \n      } else{\n        \n          line.positionPoints[grp.shapes_g.indexOf(shape)].x=shape.x;\n          line.positionPoints[grp.shapes_g.indexOf(shape)].y=shape.y;\n          shape.x=e.target.x();\n          shape.y=e.target.y();\n          \n          if(Math.sin(line.rotation*(Math.PI/180))==0){\n            distance_to_line_center=shape.x-line.x;\n          }else{\n            if(Math.sign(shape.x-line.x)!=0){\n              distance_to_line_center=Math.sign(-shape.rotation)*Math.sign(shape.x-line.x)*Math.sqrt((shape.x-line.x)**2+(shape.y-line.y)**2);\n            } else{\n             distance_to_line_center=Math.sign(-shape.rotation)*Math.sign(shape.y-line.y)*Math.sqrt((shape.x-line.x)**2+(shape.y-line.y)**2); \n            }\n          \n            if(shape.rotation*(Math.PI/180)<=-Math.PI/2 || (shape.rotation*(Math.PI/180)<=Math.PI/2 && shape.rotation*(Math.PI/180)>=0)){\n              distance_to_line_center=-distance_to_line_center\n            }\n          }\n          //shape.distance_to_line_center=distance_to_line_center;\n          //grp.line.occupiedDistances[shapes_g.indexOf(shape)]=shape.distance_to_line_center;\n        line.positionPoints[grp.shapes_g.indexOf(shape)].distance_to_line_center=shape.distance_to_line_center;\n          \n      }\n      let pos = { x: shape.x, y: shape.y };\n      this.center.x=shape.x;\n      this.center.y=shape.y;\n      e.target.position(pos);\n      e.target.getLayer().batchDraw();\n      if(!this.isCoordinateOnLine(shape.x,shape.y,line.id)){\n        shape.dragBoundFunc= dragFunc;\n        shape.isGrouped=0;\n        this.shapes.push(shape,)\n        for (let i=0;i<shapes_g.length;i++){\n          if(shapes_g[i].id==shape.id){\n            line.freeDistances.push(line.occupiedDistances[i]);\n            line.occupiedDistances.splice(i,1);\n            shapes_g.splice(i,1);\n            console.log(\"a shape has been removed from the line\");\n          }\n        } \n      }else{\n        if(!line.keepDistribution){\n          grp.line.occupiedDistances[shapes_g.indexOf(shape)]=distance_to_line_center;\n        }else{\n        grp.line.occupiedDistances[shapes_g.indexOf(shape)]=shape.distance_to_line_center;\n        }\n        \n      line.positionPoints[grp.shapes_g.indexOf(shape)].x=shape.x;\n      line.positionPoints[grp.shapes_g.indexOf(shape)].y=shape.y;\n      line.positionPoints[grp.shapes_g.indexOf(shape)].distance_to_line_center=shape.distance_to_line_center;\n       \n      }\n      /*\n      let coord_y1=line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x1=line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let coord_y2= line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x2=line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let a=(coord_y1-coord_y2)/(coord_x2-coord_x1);\n      let b=line.y-a*line.x;\n      let is_on_straight_line=false;\n      if(Math.abs(coord_x1-coord_x2)>=1){\n        is_on_straight_line=(Math.abs(a*shape.x+b-shape.y)<1);\n      }else{\n        is_on_straight_line=(Math.abs(shape.x-line.x)<1);\n      }\n      if(\n        !(is_on_straight_line)\n      ||((line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n        ||line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      && ((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>-Math.PI)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>-Math.PI)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>=0)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>=0)))\n      )\n      {\n        shape.dragBoundFunc= dragFunc;\n        this.shapes.push(shape,)\n        for (let i=0;i<shapes_g.length;i++){\n          if(shapes_g[i].id==shape.id){\n            line.freeDistances.push(line.occupiedDistances[i]);\n            line.occupiedDistances.splice(i,1);\n            shapes_g.splice(i,1);\n            console.log(\"a shape has been removed from the line\");\n          }\n        } \n      }else{\n        if(!line.keepDistribution){\n          grp.line.occupiedDistances[shapes_g.indexOf(shape)]=distance_to_line_center;\n        }else{\n        grp.line.occupiedDistances[shapes_g.indexOf(shape)]=shape.distance_to_line_center;\n        }\n      }\n      */\n      //this.updateOccupiedDistance(line.id);\n      \n          if(line.keepDistribution){\n            this.updateOccupiedDistance(line.id);\n          }\n          \n          this.updateAllPosInGrp(line.id);\n          this.updateNaration(grp)\n    },\n    \n    /*\n    Function called when the transformation of a shape with a transfomer is finished.\n    */\n    updateTransformedShape(e) {\n      \n\n      let res;\n      let shape; //Object concerned by the transformation\n      if(e.target.className==\"Line\"){\n        shape=this.groups.find(\n        (r) => r.id === this.selectedShapeId\n      ).line;\n      }else{\n        res=this.findShape(this.selectedShapeId)\n        shape=res.shape_data;\n        if(shape== undefined){\n          return;\n        }\n      }\n\n      \n      let last_shapex= shape.x;\n      let last_shapey= shape.y;\n\n      //update data of the transformed object.\n      shape.x = e.target.x();\n      shape.y = e.target.y();\n      shape.rotation = e.target.rotation();\n      let last_scaleX= shape.scaleX;\n      shape.scaleX = e.target.scaleX();\n      shape.scaleY = e.target.scaleY();\n\n      if(e.target.className==\"Line\"){\n        const grp=this.groups.find((r)=> r.id===shape.id);\n        if(shape.keepDistribution){\n          for (let i=0;i<shape.occupiedDistances.length;i++){\n            shape.occupiedDistances[i]=(shape.occupiedDistances[i]/last_scaleX)*shape.scaleX;\n          }\n          /*\n          for (let i=0;i<shape.freeDistances.length;i++){\n            shape.freeDistances[i]=(shape.freeDistances[i]/last_scaleX)*shape.scaleX;\n          }\n          */\n          \n          //this.updateOccupiedDistance(shape.id)\n          this.update();\n          this.updateGrp(e, this.selectedShapeId);\n          this.checkIfShapesOnLine(this.selectedShapeId);        \n        }else{\n          \n          \n          \n         if(last_scaleX!=shape.scaleX){\n          for(let i=0;i<grp.shapes_g.length;i++){\n          \n          //If the width of the line has been changed, we update the distance from the shape to the center of the line\n            \n              let distX=grp.shapes_g[i].x-shape.x;\n              let distY=grp.shapes_g[i].y-shape.y;\n              /*\n              if(Math.sign(grp.shapes_g[i].distance_to_line_center)==0){\n                grp.shapes_g[i].distance_to_line_center=-this.GiveSignOfDistance(grp.shapes_g[i],shape)*Math.sqrt((distX)**2 +(distY)**2);\n              \n              }else{\n                grp.shapes_g[i].distance_to_line_center=Math.sign(grp.shapes_g[i].distance_to_line_center)*Math.sqrt((distX)**2 +(distY)**2);\n              }\n              if(Math.sign((grp.shapes_g[i].x-last_shapex))!=Math.sign(distX)){\n                grp.shapes_g[i].distance_to_line_center=-grp.shapes_g[i].distance_to_line_center;\n              }\n              */\n             if(Math.sign(grp.line.occupiedDistances[i])==0){\n                //if(grp.line.rotation!=-90 && grp.line.rotation!=90){\n                  //grp.line.occupiedDistances[i]=-this.GiveSignOfDistance(grp.shapes_g[i],shape)*Math.sqrt((distX)**2 +(distY)**2);\n                //}else{\n                  grp.line.occupiedDistances[i]=this.GiveSignOfDistance(grp.shapes_g[i],shape)*Math.sqrt((distX)**2 +(distY)**2);\n                  \n                //}\n              \n              }else{\n                grp.line.occupiedDistances[i]=Math.sign(grp.line.occupiedDistances[i])*Math.sqrt((distX)**2 +(distY)**2);\n              }\n\n              \n              if(Math.sign((grp.shapes_g[i].x-last_shapex))!=Math.sign(distX) && Math.sign((grp.shapes_g[i].x-last_shapex))!=0 && grp.line.rotation!=90 && grp.line.rotation!=-90){\n                \n                grp.line.occupiedDistances[i]=-grp.line.occupiedDistances[i];\n              }\n              if(Math.sign((grp.shapes_g[i].y-last_shapey))!=Math.sign(distY) && Math.sign((grp.shapes_g[i].y-last_shapey))!=0 && (grp.line.rotation==90 || grp.line.rotation==-90)){\n                grp.line.occupiedDistances[i]=-grp.line.occupiedDistances[i];\n              }\n              //this.checkIfShapesOnLine(this.selectedShapeId);  \n            \n            //this.checkIfShapesOnLine(this.selectedShapeId);\n            //grp.line.occupiedDistances[i]=grp.shapes_g[i].distance_to_line_center;\n            \n          }\n          for (let i=0;i<shape.freeDistances.length;i++){\n            let distX=last_shapex-shape.x;\n            let distY=last_shapey-shape.y; \n            let dist=Math.sqrt(distX**2+distY**2);\n            if(shape.rotation<-90 ||shape.rotation>90){\n              shape.freeDistances[i]=shape.freeDistances[i]-Math.sign(last_shapex-shape.x)*dist;\n            } else if(shape.rotation==90 || shape.rotation==-90){\n              shape.freeDistances[i]=shape.freeDistances[i]-distY\n            } else{\n              shape.freeDistances[i]=shape.freeDistances[i]+Math.sign(last_shapex-shape.x)*dist;\n            \n            }\n          }\n         }\n          this.update();\n          this.updateGrp(e, this.selectedShapeId);\n          this.checkIfShapesOnLine(this.selectedShapeId);\n\n          // We now see if freeDistances need to be delete(so if they are bigger than the half of the stickyline);\n          \n        }\n        for(let i=0;i<grp.shapes_g.length;i++){\n            \n          this.updateDragFunc(grp.shapes_g[i],shape);\n\n        }\n      }else if(res.grp_id!='-1'){\n        //this.update();\n        //let layer=e.target.getParent().getLayer();\n        //layer.batchDraw();\n        this.updateAllPosInGrp(res.grp_id);\n        this.updateOccupiedDistance(res.grp_id);\n        e.target.x(e.target.getParent().attrs.shapes_g.find((r)=>r.id===e.target.id()).x);\n        e.target.y(e.target.getParent().attrs.shapes_g.find((r)=>r.id===e.target.id()).y);\n        this.groups.find((r)=>r.id===res.grp_id).shapes_g.find((r)=>r.id===e.target.id()).personalRotation=e.target.rotation()-e.target.getParent().attrs.line.rotation;\n        \n        \n        this.updateAllPosInGrp(res.grp_id);\n        this.checkIfShapesOnLine(res.grp_id);\n        this.updateDragFuncOfCenter();\n      \n      }\n      else{\n        this.update();\n        \n        this.updateDragFuncOfCenter();\n      }\n      this.center.x=e.target.attrs.x;\n      this.center.y=e.target.attrs.y;\n    },\n    \n    handleTransformation(e) {\n      if (e.evt==undefined) {\n        return;\n      }\n      if(this.eraseMode==1){\n        this.eraserAction(e);\n        return;\n      }\n      \n      //If we click on the stage, we have to remove the transformer from the node where it was.\n      if (e.target === e.target.getStage()) {\n        this.selectedShapeId = 'NoId';\n        this.eraseNodefromTransformer(\"lineTransformer\");\n        this.eraseNodefromTransformer(\"shapeTransformer\");\n        this.center.opacity=0;\n        return;\n      }\n\n      // If we click on a transformer, nothing happen.\n      const clickedOnTransformer = e.target.getParent().className === 'Transformer';\n      if (clickedOnTransformer) {\n        return;\n      }\n      \n      const id = e.target.id();\n      let transformer_id;\n      let shape=this.findShape(id).shape_data;\n\n      //if it is a line, we need the transformer dedicated to the line (ie transformer with id=\"lineTransformer\")\n      //if it is a classic shape, we need the transformer dedicated to the shape (ie transformer with id=\"shapeTransformer\")\n      if(e.target.attrs.id==\"center\"){\n        return;\n      }\n      if(e.target.className==\"Line\"){\n        transformer_id=\"lineTransformer\"\n        shape = this.groups.find((r) => r.id === id).line;\n        this.center.draggable=false;\n        this.selectedShapeAlignment=shape.defaultAlignment;\n        this.eraseNodefromTransformer(\"shapeTransformer\");\n      }else{\n        transformer_id=\"shapeTransformer\"\n        this.center.draggable=true;\n        this.selectedShapeAlignment=shape.centerPosition;\n        this.eraseNodefromTransformer(\"lineTransformer\");\n      }\n      \n      if (shape!=undefined) {\n        this.selectedShapeId = id;\n        this.center.opacity=1;\n        this.updateTransformer(transformer_id);\n      } else{\n        /*Only if the center is not selected.\n        When the center is dragged, this function is called.\n        But a shape is actualy selected (the one of the center).\n        */\n        this.selectedShapeId = 'NoId';\n      }\n      //this.updateTransformer(transformer_id);\n      \n      this.updateDragFuncOfCenter()\n    },\n\n    //remove node from transformer with id=transformer_id\n    eraseNodefromTransformer(transformer_id) {\n      let stage= this.$refs.stage.getStage();      \n      const transformerNode = stage.find(\"#\"+transformer_id)[0]; \n      transformerNode.nodes([]);\n    },\n\n    //Update transformer with id=transformer_id\n    //It places the transformer regarding what node is selected\n    updateTransformer(transformer_id) {\n\n      let stage= this.$refs.stage.getStage();\n      const transformerNode = stage.find(\"#\"+transformer_id)[0];\n      let selectedNode;\n      if (transformer_id==\"lineTransformer\"){\n        selectedNode = stage.children[0].getChildren().filter((r)=> r.attrs.className==\"Group\" && r.attrs.id==this.selectedShapeId)[0]\n        .getChildren().filter(r=>r.attrs.className==\"Line\" && r.attrs.id==this.selectedShapeId)[0];\n      }else{\n      selectedNode = stage.children[0].getChildren().filter((r)=>r.attrs.className!=\"Group\" && r.attrs.id==this.selectedShapeId)[0];\n\n      let isFunded=true;\n      if(selectedNode==undefined){\n        isFunded=false;\n      }\n      let i=0;\n      while(!isFunded){\n        if(i<this.groups.length){\n          selectedNode=stage.children[0].getChildren().filter((r)=>r.attrs.className==\"Group\")[i].getChildren().find((r)=>r.attrs.id==this.selectedShapeId && r.attrs.className!=\"Line\");\n        if(selectedNode==undefined){\n          isFunded=false;\n        }else{\n          isFunded=true;\n        }\n        i++;\n        }else{        \n          isFunded=true;\n        }\n      }\n      }\n      /*\n      if (transformer_id==\"lineTransformer\"){\n        selectedNode = stage.children[0].getChildren().filter((r)=> r.attrs.className==\"Group\" && r.attrs.id==this.selectedShapeId)[0]\n        .getChildren().filter(r=>r.attrs.className==\"Line\" && r.attrs.id==this.selectedShapeId)[0];\n      }\n      */\n     \n      //If the selected node has already the transformer on it, nothing happen\n      if (selectedNode === transformerNode.node()) {\n        return;\n      }\n\n      //If a node is selected\n      if (selectedNode!=undefined) {\n        //We attach the transformer to the node\n        transformerNode.nodes([selectedNode]);\n      } else {\n        //if no node is selected, we remove the transformer from its node.\n        transformerNode.nodes([]);\n      }\n      this.center.x=selectedNode.attrs.x;\n      this.center.y=selectedNode.attrs.y;\n      \n    },\n/*\n  DisplayCenterMenu(e){\n    CenterMenu.props.ConcernedShape=e.target;\n   document.getElementById(\"center_menu\").style.display=\"initial\";\n   document.getElementById(\"center_menu\").style.top=e.target.getStage().getPointerPosition().y+8+\"px\";\n  document.getElementById(\"center_menu\").style.left=e.target.getStage().getPointerPosition().x+8+\"px\";\n  },\n  */\n\n  //display context menu according to the target\n  \n  DisplayContextMenu(e){\n    e.evt.preventDefault()\n    if (e.target.className!=undefined && e.target.attrs.id!=\"center\"){\n      this.isStageOnlySelected=false;\n      ContextMenu.data().dM='initial';\n      this.$emit('needmenu');\n      this.needMenu=true;\n      ContextMenu.props.ConcernedShape=e.target;\n      if (e.target.attrs.className==\"Line\"){\n        this.isALineSelected=true;\n        this.isAGroupedShapeSelected=true;\n        //We precise the text which depends on the line where we clicked.\n        this.keepDistanceButtonText=e.target.attrs.keepDistanceButtonText;\n      } else if(e.target.getParent().attrs.className==\"Group\"){\n        this.isAGroupedShapeSelected=true;\n      }\n      else{\n        this.isALineSelected=false;\n        this.isAGroupedShapeSelected=false;\n      }\n      document.getElementById(\"activeReuse\").style.display=\"initial\";\n      document.getElementById(\"activeReuse\").style.top=document.getElementById(\"reusedemo\").getBoundingClientRect().top+document.documentElement.scrollTop+e.target.getStage().getPointerPosition().y+\"px\";\n      document.getElementById(\"activeReuse\").style.left=document.getElementById(\"reusedemo\").getBoundingClientRect().left+document.documentElement.scrollLeft+e.target.getStage().getPointerPosition().x+\"px\";\n    }\n    if (e.target === e.target.getStage()) {\n      this.needMenu=true;\n      this.isALineSelected=false;\n      this.isAGroupedShapeSelected=false;\n      this.isStageOnlySelected=true;\n      document.getElementById(\"activeReuse\").style.display=\"initial\";\n      document.getElementById(\"activeReuse\").style.top=document.getElementById(\"reusedemo\").getBoundingClientRect().top+document.documentElement.scrollTop+e.target.getStage().getPointerPosition().y+\"px\";\n      document.getElementById(\"activeReuse\").style.left=document.getElementById(\"reusedemo\").getBoundingClientRect().left+document.documentElement.scrollLeft+e.target.getStage().getPointerPosition().x+\"px\";\n    }\n  },\n\n  //hide context menu\n  HideContextMenu(){\n    this.needMenu=false;\n    document.getElementById(\"activeReuse\").style.display=\"none\";\n  },\n\n\n  \n ChangeCenter(e){\n  let res=this.findShape(this.selectedShapeId);\n  let shape=res.shape_data;\n  let threshold1;\n  let threshold2;\n  let dist=this.GiveSignOfDistanceBtwCenterAndShape(e.target.attrs,shape)*Math.sqrt((e.target.y()-(shape.y))**2+(e.target.x()-shape.x)**2)+shape.offsetY*shape.scaleY;\n  \n  //let last_offsetX=shape.offsetX;\n  let last_offsetY=shape.offsetY;\n  if(shape==undefined){\n    shape=this.groups.find((r)=>r.id==this.selectedShapeId).line;\n\n  }else{\n    \n      if(shape.className==\"Rect\") {\n        threshold1=shape.height*shape.scaleY/3;\n        threshold2=shape.height*shape.scaleY*2/3;\n        if(dist>=threshold1 && dist<=threshold2){\n          shape.offsetX=shape.width/2;\n          shape.offsetY=shape.height/2;\n          shape.centerPosition=\"Middle\";\n        }else if(dist>threshold2){\n          shape.offsetX=shape.width/2;\n          shape.offsetY=shape.height;\n          shape.centerPosition=\"Bottom\";\n        }\n        else{\n          shape.offsetX=shape.width/2;\n          shape.offsetY=0;\n          shape.centerPosition=\"Top\";\n        }\n      }\n      else if(shape.className==\"Circle\") {\n        dist=dist+shape.radius*shape.scaleY;\n        threshold1=shape.radius*shape.scaleY*2/3;\n        threshold2=shape.radius*shape.scaleY*4/3;\n        if(dist>=threshold1 && dist<=threshold2){\n          shape.offsetX=0;\n          shape.offsetY=0;\n          shape.centerPosition=\"Middle\";\n        }else if(dist>threshold2){\n          shape.offsetX=0;\n          shape.offsetY=shape.radius;\n          shape.centerPosition=\"Bottom\";\n        }else{\n          shape.offsetX=0;\n          shape.offsetY=-shape.radius;\n          shape.centerPosition=\"Top\";\n        } \n      }\n      else if(shape.className==\"Image\") {\n        threshold1=shape.image.height*shape.scaleY/3;\n        threshold2=shape.image.height*shape.scaleY*2/3;\n        if(dist>=threshold1 && dist<=threshold2){\n          shape.offsetX=shape.image.width/2;\n          shape.offsetY=shape.image.height/2;\n          shape.centerPosition=\"Middle\";\n        }else if(dist>threshold2){\n          shape.offsetX=shape.image.width/2;\n          shape.offsetY=shape.image.height;\n          shape.centerPosition=\"Bottom\";\n        }\n        else {\n          shape.offsetX=shape.image.width/2;\n          shape.offsetY=0;\n          shape.centerPosition=\"Top\";\n        }\n      }\n      else if(shape.className==\"Text\") {\n        threshold1=shape.length_y*shape.scaleY/3;\n        threshold2=shape.length_y*shape.scaleY*2/3;\n        if(dist>=threshold1 && dist<=threshold2){\n          shape.offsetX=shape.length_x/2;\n          shape.offsetY=shape.length_y/2;\n          shape.centerPosition=\"Middle\";\n        }else if(dist>threshold2){\n          shape.offsetX=shape.length_x/2;\n          shape.offsetY=shape.length_y;\n          shape.centerPosition=\"Bottom\";\n        }\n        else{\n          shape.offsetX=shape.length_x/2;\n          shape.offsetY=0;\n          shape.centerPosition=\"Top\";\n        }\n      }\n      else if(shape.className==\"Triangle\") {\n        dist=dist+shape.radius*shape.scaleY;\n        threshold1=shape.radius*shape.scaleY/2;\n        threshold2=shape.radius*shape.scaleY*5/4;\n        if(dist>=threshold1 && dist<=threshold2){\n          shape.offsetX=0;\n          shape.offsetY=0;\n        }else if(dist>threshold2){\n          shape.offsetX=0;\n          shape.offsetY=shape.radius/2\n          shape.centerPosition=\"Bottom\";\n        }\n        else{\n          shape.offsetX=0;\n          shape.offsetY=-shape.radius;\n          shape.centerPosition=\"Top\";\n        }\n      }\n      shape.y=shape.y-(last_offsetY-shape.offsetY)*shape.scaleY*Math.cos(shape.rotation*(Math.PI/180));\n      shape.x=shape.x+(last_offsetY-shape.offsetY)*shape.scaleY*Math.sin(shape.rotation*(Math.PI/180));\n      this.selectedShapeAlignment=shape.centerPosition;\n\n      if (res.grp_id!='-1'){\n        this.updateAllPosInGrp(res.grp_id);\n      }\n        \n      e.target.x(shape.x);\n      e.target.y(shape.y);\n\n     \n\n      \n  }\n  },\n  /*\n  ChangeAlignCenter(align_choice){\n    let center=CenterMenu.props.ConcernedShape;\n    let grp=this.groups.find((r)=>r.id===this.selectedShapeId);\n    let shape;\n    if(grp!=undefined){\n      for(let i=0;i<grp.shapes_g.length;i++){\n        this.ChangeCenterRegardingCommand(grp.shapes_g[i].id,align_choice)\n      }\n      center.x(grp.line.x);\n      center.y(grp.line.y);\n      if(grp.line.defaultAlignment==align_choice){\n        grp.line.defaultAlignment='' //If we select again the same alogn_choice, we deselect it, no alignement center is fixed.\n      }else{\n        grp.line.defaultAlignment=align_choice;\n      }\n      this.selectedShapeAlignment=grp.line.defaultAlignment;\n    }else{\n      shape=this.findShape(this.selectedShapeId).shape_data;\n      this.ChangeCenterRegardingCommand(shape.id,align_choice)\n      this.selectedShapeAlignment=shape.centerPosition;\n      center.x(shape.x);\n      center.y(shape.y);\n    }\n  },\n  */\n  //Allow to change the center regarding a text command (Top,Middle or Bottom)\n  ChangeCenterRegardingCommand(shape_id,command){\n    let res=this.findShape(shape_id);\n    let shape=res.shape_data;\n    let last_offsetY=shape.offsetY;\n    if(shape.className==\"Rect\" ){\n      if(command==\"Top\"){\n        shape.offsetY=0;\n        shape.offsetX=shape.width/2;\n      }\n      else if(command==\"Middle\"){\n          shape.offsetX=shape.width/2;\n          shape.offsetY=shape.height/2;\n      }else if(command==\"Bottom\"){\n            shape.offsetX=shape.width/2;\n            shape.offsetY=shape.height;\n      }\n    }\n      else if(shape.className==\"Circle\") {\n        if(command==\"Top\"){\n          shape.offsetX=0;\n          shape.offsetY=-shape.radius;\n        }else if(command==\"Middle\"){\n          shape.offsetX=0;\n          shape.offsetY=0\n        }else if(command==\"Bottom\"){\n          shape.offsetX=0;\n          shape.offsetY=shape.radius;\n        } \n      }\n      else if(shape.className==\"Image\") {\n        if(command==\"Middle\"){\n          shape.offsetX=shape.image.width/2;\n          shape.offsetY=shape.image.height/2;\n        }else if(command==\"Bottom\"){\n          shape.offsetX=shape.image.width/2;\n          shape.offsetY=shape.image.height;\n        }\n        else if (command==\"Top\"){\n          shape.offsetX=shape.image.width/2;\n          shape.offsetY=0;\n        }\n      }\n      else if(shape.className==\"Text\") {\n        if(command==\"Middle\"){\n          shape.offsetX=shape.length_x/2;\n          shape.offsetY=shape.length_y/2;\n        }else if(command==\"Bottom\"){\n          shape.offsetX=shape.length_x/2;\n          shape.offsetY=shape.length_y;\n        }\n        else if(command==\"Top\"){\n          shape.offsetX=shape.length_x/2;\n          shape.offsetY=0;\n        }\n      }\n      else if(shape.className==\"Triangle\") {\n        if(command==\"Middle\"){\n          shape.offsetX=0;\n          shape.offsetY=0;\n        }else if(command==\"Bottom\"){\n          shape.offsetX=0;\n          shape.offsetY=shape.radius/2;\n        }\n        else if(command==\"Top\"){\n          shape.offsetX=0;\n          shape.offsetY=-shape.radius;\n        }\n      }\n      shape.centerPosition=command;\n      shape.y=shape.y-(last_offsetY-shape.offsetY)*shape.scaleY*Math.cos(shape.rotation*(Math.PI/180));\n      shape.x=shape.x+(last_offsetY-shape.offsetY)*shape.scaleY*Math.sin(shape.rotation*(Math.PI/180));\n\n      if (res.grp_id!='-1'){\n        this.updateAllPosInGrp(res.grp_id);\n      }\n        \n      //center.x(shape.x);\n      //center.y(shape.y);\n  },\n  updateDragFuncOfCenter(){\n    let shape=this.findShape(this.selectedShapeId).shape_data\n    let center=this.center;\n    let angle=shape.rotation*(Math.PI/180);\n    if(angle>=-Math.PI/2 && angle<=0){\n      angle-=90*(Math.PI/180);\n    }else if(angle<-Math.PI/2){\n      angle+=(Math.PI/2);\n      angle=Math.PI+angle;\n    } else if(angle<=Math.PI && angle>0){\n      angle-=90*(Math.PI/180);\n    } \n    if (angle<=0 && angle>=-Math.PI/4){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x +(pos.x-shape.x)*Math.cos(angle),\n          y: shape.y+(pos.x-shape.x)*Math.sin(angle),\n        };\n      }\n    } else if (angle<-Math.PI/4 && angle>=-Math.PI/2){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x-(pos.y-shape.y)*Math.cos(angle),\n          y: shape.y-(pos.y-shape.y)*Math.sin(angle),\n        };\n      }\n    }\n    else if (angle<-Math.PI/2 && angle>=-3*Math.PI/4){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x-(pos.y-shape.y)*Math.cos(angle),\n          y: shape.y-(pos.y-shape.y)*Math.sin(angle),\n        };\n      }\n    } else if (angle<-3*Math.PI/4 && angle>=-Math.PI){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x-(pos.x-shape.x)*Math.cos(angle),\n          y: shape.y-(pos.x-shape.x)*Math.sin(angle),\n        };\n      }\n    }else if (angle<=Math.PI && angle>=3*Math.PI/4){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x-(pos.x-shape.x)*Math.cos(angle),\n          y: shape.y-(pos.x-shape.x)*Math.sin(angle),\n        };\n      }\n    } else if (angle<3*Math.PI/4 && angle>=Math.PI/2){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x+(pos.y-shape.y)*Math.cos(angle),\n          y: shape.y+(pos.y-shape.y)*Math.sin(angle),\n        };\n      }\n    } else if (angle<Math.PI/2 && angle>=Math.PI/4){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x+(pos.y-shape.y)*Math.cos(angle),\n          y: shape.y+(pos.y-shape.y)*Math.sin(angle),\n        };\n      }\n    }else if (angle<Math.PI/4 && angle>=0){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x+(pos.x-shape.x)*Math.cos(angle),\n          y: shape.y+(pos.x-shape.x)*Math.sin(angle),\n        };\n      }\n    }\n  },\n  MovingCenter(){\n    //let shape=this.findShape(this.selectedShapeId)\n    //console.log(e.target)\n  },\n  /*\n  //called when the \"Change Center\" button is clicked\n  ChangeCenterButtonAction(){\n      let shape= ContextMenu.props.ConcernedShape;\n      if(shape.attrs.className==\"Line\"){\n        let shapes_g=shape.getParent().attrs.shapes_g //the list of the shapes which are on the line is in the corresponding group.\n        for (let j=0;j<shapes_g.length;j++){\n          this.ChangeCenter(shapes_g[j]);\n        }\n      }else{\n        let shape_data=this.shapes.find(i => i.id ===shape.attrs.id);\n        let isFunded=true;\n        if(shape_data==undefined){\n          isFunded=false;\n        }\n        let i=0;\n        while(!isFunded){\n          if(i<this.groups.length){\n            shape_data=this.groups[i].shapes_g.find(i => i.id === shape.attrs.id);\n          if(shape_data==undefined){\n            isFunded=false;\n          }else{\n            isFunded=true;\n          }\n          i++;\n          }else{        \n            isFunded=true;\n          }\n        }\n        this.ChangeCenter(shape_data)\n      }\n    },\n    */\n    \n    //allow to copy a target\n    \n    Copy(){\n      ContextMenu.props.CopiedShape=ContextMenu.props.ConcernedShape;\n      ContextMenu.props.pastOneObject=true;\n    },\n    /*\n    CopyAll(){\n      ContextMenu.props.CopiedShape=ContextMenu.props.ConcernedShape;\n      ContextMenu.props.pastOneObject=false;\n    },\n    */\n    Past(){   \n      //Prevent error when no shape is copied\n      if(ContextMenu.props.CopiedShape.attrs==undefined){\n        return;\n      }\n      let clone=ContextMenu.props.CopiedShape.clone({\n        id: ''+this.max_id_figures,\n      })\n      //let layer=ContextMenu.props.CopiedShape.getLayer();\n      let i= this.groups.length\n      //let new_id=i+1;\n      if(ContextMenu.props.CopiedShape.attrs.className==\"Line\"){\n        this.max_id_figures=this.max_id_figures+1;\n        if(!ContextMenu.props.pastOneObject){\n          //let i= this.groups.length;\n          //let new_id=i+1;\n        \n          clone=ContextMenu.props.CopiedShape.getParent().clone({\n            id: ''+ this.max_id_figures,\n            name: \"group\"+this.max_id_figures,\n            shapes_g:[],\n          })\n          clone.attrs.line.id=''+this.max_id_figures;\n          clone.attrs.line.x=ContextMenu.props.ConcernedShape.getStage().getPointerPosition().x;\n          clone.attrs.line.y=ContextMenu.props.ConcernedShape.getStage().getPointerPosition().y;\n          let positionPoints=Object.assign([],clone.attrs.line.positionPoints);\n            let length=positionPoints.length;\n            clone.attrs.line.positionPoints=[];\n            for(let i=0;i<length.valueOf();i++){\n              let clone_positionPoint=ContextMenu.props.CopiedShape.getParent().getChildren().find((r)=>r.attrs.id===positionPoints[i].id).clone({\n              id:'positionPoint'+clone.attrs.line.id+i,\n              });\n              clone.attrs.line.positionPoints.push(clone_positionPoint.attrs,);\n            }\n          \n          //layer= ContextMenu.props.CopiedShape.getParent().getLayer();\n          this.groups.push(clone.attrs,);\n          let shapesg=this.groups[this.groups.indexOf(this.groups.find((r)=> r.id==ContextMenu.props.CopiedShape.getParent().attrs.id))].shapes_g;\n          let shapesg_length=shapesg.length;\n          for (let j=0; j<shapesg_length;j++){\n            this.max_id_figures=this.max_id_figures + 1;\n            let clone_shape=ContextMenu.props.CopiedShape.getParent().getChildren().find((r)=>r.attrs.id===shapesg[j].id).clone({\n              id:''+this.max_id_figures,\n            });\n           // this.updateDragFunc(clone_shape,clone_line);\n            this.groups[i].shapes_g.push(clone_shape.attrs,);\n            this.updateDragFunc(this.groups[i].shapes_g[this.groups[i].shapes_g.length-1],this.groups[i].line);\n          }\n          this.updateAllPosInGrp(clone.attrs.id);\n        }else{\n          //let i= this.groups.length;\n          //let new_id=i+1;\n        \n          clone=ContextMenu.props.CopiedShape.getParent().clone({\n            id: ''+this.max_id_figures,\n            name: \"group\"+this.max_id_figures,\n            shapes_g:[],\n          })\n          clone.attrs.line.id=''+this.max_id_figures;\n          clone.attrs.line.x=ContextMenu.props.ConcernedShape.getStage().getPointerPosition().x;\n          clone.attrs.line.y=ContextMenu.props.ConcernedShape.getStage().getPointerPosition().y;\n          for(let j=0;j<clone.attrs.line.occupiedDistances.length;j++){\n            clone.attrs.line.freeDistances.push(clone.attrs.line.occupiedDistances[j],);\n          }\n          clone.attrs.line.occupiedDistances=[];\n          if(clone.attrs.line.keepDistribution!=1){\n            let positionPoints=Object.assign([],clone.attrs.line.positionPoints);\n            let length=positionPoints.length;\n            clone.attrs.line.positionPoints=[];\n            for(let i=0;i<length.valueOf();i++){\n              let clone_positionPoint=ContextMenu.props.CopiedShape.getParent().getChildren().find((r)=>r.attrs.id===positionPoints[i].id).clone({\n              id:'positionPoint'+clone.attrs.line.id+i,\n              });\n              clone.attrs.line.positionPoints.push(clone_positionPoint.attrs,);\n            }\n          }\n          //layer= ContextMenu.props.CopiedShape.getParent().getLayer();\n          this.groups.push(clone.attrs,)\n        }\n        this.updateNaration(this.groups[this.groups.length-1])\n        //In order to actualize the new line (in particular to show the positionPoints):\n        this.updateAllPosInGrp(clone.attrs.id)\n      } \n      else{\n        this.max_id_figures=this.max_id_figures + 1;\n        clone=ContextMenu.props.CopiedShape.clone({\n          id: ''+this.max_id_figures,  \n          x:ContextMenu.props.ConcernedShape.getStage().getPointerPosition().x,\n          y:ContextMenu.props.ConcernedShape.getStage().getPointerPosition().y,\n        });\n        clone.attrs.dragBoundFunc=function (pos) {\n          return {\n            x: pos.x,\n            y: pos.y,\n          };\n        };\n        clone.attrs.isGrouped=0;\n        this.shapes.push(clone.attrs,); \n         \n      }\n      //layer.batchDraw(); \n      \n    },\n    //RemoveShape(shape)\n    Remove(shape){\n      //let shape=ContextMenu.props.ConcernedShape;\n      if(shape.attrs.className==\"Line\"){\n        let grp=this.groups.find((r)=>r.id===shape.attrs.id);\n        const length=grp.shapes_g.length;\n        for(let i=0;i<length;i++){\n          grp.shapes_g[i].dragBoundFunc= dragFunc;\n          grp.shapes_g[i].isGrouped=0;\n          this.shapes.push(grp.shapes_g[i],);\n        }\n        this.eraseNodefromTransformer(\"lineTransformer\");\n        this.groups.splice(this.groups.indexOf(grp),1);\n        shape.getParent().destroy();\n\n        //We give to the circle (representing center of shapes) a default position\n        if(this.groups[0]!=undefined){\n          this.center.x=this.groups[0].line.x;\n          this.center.y=this.groups[0].line.y;\n        } else if(this.shapes[0]!=undefined){\n          this.center.x=this.shapes[0].x;\n          this.center.y=this.shapes[0].y;\n        }\n        this.center.opacity=0;\n        \n      }else if(shape.attrs.className==\"positionPoint\"){\n        let line=shape.getParent().attrs.line;\n        let target_positionPoint=line.positionPoints.find((r)=>r.id===shape.attrs.id);\n        let index=line.freeDistances.indexOf(shape.attrs.distance_to_line_center);\n        \n        if(line.keepDistribution!=1 && index!=-1){\n          line.freeDistances.splice(index,1);\n          line.positionPoints.splice(line.positionPoints.indexOf(target_positionPoint),1)\n        }\n      }\n      else{\n        let res=this.findShape(shape.attrs.id)\n        let shape_data=res.shape_data;\n        let grp_id=res.grp_id;\n        if(shape_data!=undefined){\n        if(grp_id!='-1'){\n        //let shape_data=this.shapes.find(i => i.id ===shape.attrs.id);\n        let grp=this.groups.find((r)=>r.id===grp_id);\n          grp.line.freeDistances.push(grp.line.occupiedDistances[grp.shapes_g.indexOf(shape_data)],)\n          grp.line.occupiedDistances.splice(grp.shapes_g.indexOf(shape_data),1)\n          \n          grp.shapes_g.splice(grp.shapes_g.indexOf(shape_data),1);\n          this.updateOccupiedDistance(grp.id);\n          \n          this.updateAllPosInGrp(grp.id);\n          \n      \n        } else{\n          this.eraseNodefromTransformer(\"shapeTransformer\");\n          this.shapes.splice(this.shapes.indexOf(shape_data),1);\n          //We give to the circle (representing center of shapes) a default position\n          if(this.groups[0]!=undefined){\n            this.center.x=this.groups[0].line.x;\n            this.center.y=this.groups[0].line.y;\n          } else if(this.shapes[0]!=undefined){\n            this.center.x=this.shapes[0].x;\n            this.center.y=this.shapes[0].y;\n          }\n          this.center.opacity=0;\n        }\n        shape.destroy();\n        }\n      }\n    },\n\n    RemoveAll(){\n      let shape=ContextMenu.props.ConcernedShape;\n      if(shape.className==\"Line\"){\n        let grp=this.groups.find((r)=>r.id===shape.attrs.id);\n        while(grp.shapes_g.length!=0){\n          grp.shapes_g[0].dragBoundFunc= dragFunc;\n          grp.shapes_g.splice(0,1);\n        }\n        this.eraseNodefromTransformer(\"lineTransformer\");\n        this.groups.splice(this.groups.indexOf(grp),1);\n        shape.getParent().destroy();\n\n        //We give to the circle (representing center of shapes) a default position\n        if(this.groups[0]!=undefined){\n          this.center.x=this.groups[0].line.x;\n          this.center.y=this.groups[0].line.y;\n        } else if(this.shapes[0]!=undefined){\n          this.center.x=this.shapes[0].x;\n          this.center.y=this.shapes[0].y;\n        }\n        \n      }else{\n        return;\n      }\n    },\n    \n\n    findShape(id){\n      let shape_data=this.shapes.find(i => i.id ===id);\n      let grp_id='-1'; // return grp_id=-1 if the shape doesn't belong to attached group.\n      let isFunded=true;\n      if(shape_data==undefined){\n        isFunded=false;\n      }\n      let i=0;\n      while(!isFunded){\n        if(i<this.groups.length){\n          shape_data=this.groups[i].shapes_g.find(i => i.id === id);\n        if(shape_data==undefined){\n          isFunded=false;\n        }else{\n          grp_id=this.groups[i].id; \n          isFunded=true;\n        }\n        i++;\n        }else{        \n          isFunded=true;\n        }\n      }\n      return {shape_data, grp_id}\n    },\n\n    //detach a shape from its line.\n     DetachShape(shape,target_x,target_y){\n      \n      \n      const added_distance=this.lengthToCapture+5;\n      let grp=this.groups.find((r)=>r.shapes_g.indexOf(shape)!=-1);\n      let i=grp.shapes_g.indexOf(shape);\n      \n      shape.dragBoundFunc= dragFunc;\n\n      let coord_y1=grp.line.y-grp.line.points[4]*(1/2)*grp.line.scaleX*Math.sin(grp.line.rotation*(Math.PI/180));\n      let coord_x2=grp.line.x+grp.line.points[4]*(1/2)*grp.line.scaleX*Math.cos(grp.line.rotation*(Math.PI/180));\n      let coord_y2= grp.line.y+grp.line.points[4]*(1/2)*grp.line.scaleX*Math.sin(grp.line.rotation*(Math.PI/180));\n      let coord_x1=grp.line.x-grp.line.points[4]*(1/2)*grp.line.scaleX*Math.cos(grp.line.rotation*(Math.PI/180));\n      let a=(coord_y2-coord_y1)/(coord_x2-coord_x1);\n      //let b=grp.line.y-a*grp.line.x;\n      let b=shape.x*(1/a)+shape.y;\n      if (grp.line.rotation<0 && grp.line.rotation>-45){\n        \n        shape.x=shape.x+Math.sign(shape.y-target_y)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } else if (grp.line.rotation<=-45 && grp.line.rotation>-90){\n        \n        shape.x=shape.x+Math.sign(shape.x-target_x)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      }\n      \n      else if(grp.line.rotation<-90 && grp.line.rotation>-135){\n        shape.x=shape.x+Math.sign(shape.x-target_x)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } \n      else if(grp.line.rotation<=-135 && grp.line.rotation>-180){\n        shape.x=shape.x-Math.sign(shape.y-target_y)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } \n      \n      else if( grp.line.rotation>135 && grp.line.rotation<180){\n        \n        shape.x=shape.x-Math.sign(shape.y-target_y)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } else if( grp.line.rotation>90 && grp.line.rotation<=135){\n        \n        shape.x=shape.x-Math.sign(shape.x-target_x)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } else if( grp.line.rotation>45 && grp.line.rotation<=90){\n        \n        shape.x=shape.x-Math.sign(shape.x-target_x)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } else if( grp.line.rotation>0 && grp.line.rotation<=45){\n        \n        shape.x=shape.x+Math.sign(shape.y-target_y)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } \n      else if(grp.line.rotation==-90){\n        shape.x=shape.x-Math.sign(shape.x-target_x)*added_distance\n      } else if(grp.line.rotation==90){\n        shape.x=shape.x+Math.sign(shape.x-target_x)*added_distance\n      } else if(grp.line.rotation==180 || grp.line.rotation==-180){\n        shape.y=shape.y-Math.sign(shape.y-target_y)*added_distance\n      } else if(grp.line.rotation==0){\n        shape.y=shape.y-Math.sign(shape.y-target_y)*added_distance\n      }  \n      //shape.rotation=shape.rotation+shape.personalRotation;\n      shape.isGrouped=0;\n      this.shapes.push(shape,)\n      this.center.x=shape.x;\n      this.center.y=shape.y;\n      grp.line.freeDistances.push(grp.line.occupiedDistances[i]);\n      grp.line.occupiedDistances.splice(i,1);\n      grp.shapes_g.splice(i,1);\n      if(grp.line.keepDistribution){\n        grp.line.positionPoints.splice(i,1)\n      }\n      this.updateOccupiedDistance(grp.id)\n      this.updateAllPosInGrp(grp.id)\n      this.updateNaration(grp)\n      \n      this.eraseNodefromTransformer(\"shapeTransformer\");\n    \n    }, \n    /*\n    DetachShape(shape){\n      \n      \n      const added_distance=this.lengthToCapture+5;\n      let grp=this.groups.find((r)=>r.shapes_g.indexOf(shape)!=-1);\n      let i=grp.shapes_g.indexOf(shape);\n      \n      shape.dragBoundFunc= dragFunc;\n\n      let coord_y1=grp.line.y-grp.line.points[4]*(1/2)*grp.line.scaleX*Math.sin(grp.line.rotation*(Math.PI/180));\n      let coord_x2=grp.line.x+grp.line.points[4]*(1/2)*grp.line.scaleX*Math.cos(grp.line.rotation*(Math.PI/180));\n      let coord_y2= grp.line.y+grp.line.points[4]*(1/2)*grp.line.scaleX*Math.sin(grp.line.rotation*(Math.PI/180));\n      let coord_x1=grp.line.x-grp.line.points[4]*(1/2)*grp.line.scaleX*Math.cos(grp.line.rotation*(Math.PI/180));\n      let a=(coord_y2-coord_y1)/(coord_x2-coord_x1);\n      //let b=grp.line.y-a*grp.line.x;\n      let b=shape.x*(1/a)+shape.y;\n      if (grp.line.rotation<0 && grp.line.rotation>-90){\n        \n        shape.x=shape.x-added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } else if(grp.line.rotation<-90){\n        shape.x=shape.x-added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } else if( grp.line.rotation>0 && grp.line.rotation<180){\n        \n        shape.x=shape.x+added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } \n      else if(grp.line.rotation==-90){\n        shape.x=shape.x+added_distance\n      } else if(grp.line.rotation==90){\n        shape.x=shape.x-added_distance\n      } else if(grp.line.rotation==180 || grp.line.rotation==-180){\n        shape.y=shape.y-added_distance\n      } else if(grp.line.rotation==0){\n        shape.y=shape.y+added_distance\n      } \n      //shape.rotation=shape.rotation+shape.personalRotation;\n      shape.isGrouped=0;\n      this.shapes.push(shape,)\n      this.center.x=shape.x;\n      this.center.y=shape.y;\n      grp.line.freeDistances.push(grp.line.occupiedDistances[i]);\n      grp.line.occupiedDistances.splice(i,1);\n      grp.shapes_g.splice(i,1);\n      if(grp.line.keepDistribution){\n        grp.line.positionPoints.splice(i,1)\n      }\n      this.updateOccupiedDistance(grp.id)\n      this.updateAllPosInGrp(grp.id)\n    \n    }, \n    */\n    /*\n\n    //called when the button \"Detach Shape\" is clicked\n    DetachShapeButtonAction(){\n      let shape= ContextMenu.props.ConcernedShape;\n      if(shape.attrs.className==\"Line\"){\n        let shapes_g=shape.getParent().attrs.shapes_g;\n        while(shapes_g.length!=0){\n          this.DetachShape(shapes_g[0]);\n        }\n      }else{\n        let shape_data=this.shapes.find(i => i.id ===shape.attrs.id);\n        let isFunded=true;\n        if(shape_data==undefined){\n          isFunded=false;\n        }\n        let i=0;\n        while(!isFunded){\n          if(i<this.groups.length){\n            shape_data=this.groups[i].shapes_g.find(i => i.id === shape.attrs.id);\n          if(shape_data==undefined){\n            isFunded=false;\n          }else{\n            isFunded=true;\n          }\n          i++;\n          }else{        \n            isFunded=true;\n          }\n        }\n        this.DetachShape(shape_data)\n      }\n    },\n\n    //called when the button \"keep/liberate distribution\" is clicked.\n    KeepDistribution(){\n      let grp=this.groups.find(i => i.id === ContextMenu.props.ConcernedShape.attrs.id);\n      let line=grp.line;\n      if(line==undefined){\n        return;\n      }else{\n        if(line.keepDistribution){\n          line.keepDistribution=false;\n          for (let i=0;i<grp.shapes_g.length;i++){\n            grp.shapes_g[i].distance_to_line_center=line.occupiedDistances[i]\n          }\n          line.freeDistances=[];\n\n          line.stroke='blue'\n          grp.line.keepDistanceButtonText=\"Keep Distribution\";\n          //ContextMenu.props.ConcernedShape.attrs.keepDistanceButtonText=\"Keep Distribution\";\n        }else{\n          line.keepDistribution=true;\n          for (let i=0;i<grp.shapes_g.length;i++){\n            line.occupiedDistances[i]=grp.shapes_g[i].distance_to_line_center;\n          }\n          line.stroke='black'\n          grp.line.keepDistanceButtonText=\"Liberate Distribution\";\n          //ContextMenu.props.ConcernedShape.attrs.keepDistanceButtonText=\"Liberate Distribution\";\n          this.updateOccupiedDistance(line.id);\n          this.updateAllPosInGrp(line.id);\n        }\n      }\n    },\n    */\n    createNewShape(shape){\n      if(shape.attrs.className==\"Line\"){\n        \n        this.max_id_figures=this.max_id_figures+1;\n\n          let clone=shape.getParent().clone({\n            id: ''+this.max_id_figures,\n            name: \"group\"+this.max_id_figures,\n            shapes_g:[],\n          })\n          clone.attrs.line.id=''+this.max_id_figures;\n          clone.attrs.line.x=shape.getStage().getPointerPosition().x;\n          clone.attrs.line.y=shape.getStage().getPointerPosition().y;\n          clone.attrs.line.draggable=true;\n          this.groups.push(clone.attrs,)\n          \n        \n      }else{\n        \n        this.max_id_figures=this.max_id_figures+1\n        let clone=shape.clone({\n          id: ''+this.max_id_figures,\n          draggable: true,\n        })\n        clone.attrs.isGrouped=0;\n        this.shapes.push(clone.attrs,);\n      }\n      \n\n    },\n    \n  \n  eraserAction(e){\n    this.Remove(e.target);\n    \n  },\n  unshowSelectedShape(e){\n    if(e.target.attrs.className==\"Line\" && this.eraseMode==0){\n      e.target.opacity(0.5)\n    }\n    else if(e.target.attrs.className==\"Line\" && this.eraseMode==1){\n      if(e.target.attrs.keepDistribution==1){\n        e.target.stroke(\"rgb(48,48,48)\")\n      }else{\n        e.target.stroke(\"blue\")\n      }\n    }\n    else if(e.target.attrs.className==\"positionPoint\" && this.eraseMode==1){\n      if(e.target.getParent().attrs.line.keepDistribution!=1){\n        e.target.strokeWidth(0)\n      }\n    }\n    else if(this.eraseMode==1){\n      e.target.strokeWidth(0)\n    }\n  },\n  showSelectedShape(e){\n    if(e.target.attrs.className==\"Line\" && this.eraseMode==0){\n      e.target.opacity(1)\n    }\n    else if(e.target.attrs.className==\"Line\" && this.eraseMode==1){\n      e.target.stroke('rgb(200, 59, 218)')\n    }\n    else if(e.target.attrs.className==\"positionPoint\" && this.eraseMode==1){\n      let line=e.target.getParent().attrs.line;\n      if(line.freeDistances.indexOf(e.target.attrs.distance_to_line_center)!=-1){\n        if(line.keepDistribution!=1){\n          e.target.stroke('rgb(200, 59, 218)')\n          e.target.strokeWidth(3)\n        }\n      }\n    }\n    else if(this.eraseMode==1){\n      e.target.stroke('rgb(200, 59, 218)')\n      e.target.strokeWidth(3)\n    }\n    /*\n    let shape=e.target;\n    if(this.eraseMode==1){\n    let shape_data=this.shapes.find(i => i.id ===shape.attrs.id);\n    let isFunded=true;\n    if(shape_data==undefined){\n      isFunded=false;\n      let i=0;\n      while(!isFunded){\n        if(i<this.groups.length){\n          shape_data=this.groups[i].shapes_g.find(i => i.id === shape.attrs.id);\n        if(shape_data==undefined){\n          isFunded=false;\n          i++;\n        }else{\n          isFunded=true;\n        }\n        }else{        \n          isFunded=true;\n        }\n      }\n    }\n    if (shape_data!=undefined){\n      shape_data.opacity=0.3\n    }\n    */\n\n  },\n  editText(e){\n    //let valuey=document.getElementById(\"stage\").style.top+e.target.y()\n    //let valuex=document.getElementById(\"stage\").style.left+e.target.x()\n    let stageBox=e.target.getStage().attrs.container.getBoundingClientRect();\n    document.getElementById(\"input\").style.top=stageBox.y+e.target.getAbsolutePosition().y+'px';\n    document.getElementById(\"input\").style.left=stageBox.x+e.target.getAbsolutePosition().x-document.getElementById(\"input\").size*5+'px';\n    document.getElementById(\"input\").style.display=\"initial\"\n    this.editedText=e.target\n  },\n  updateText(e){\n    let shape=this.shapes.find(i => i.id ===this.editedText.attrs.id);\n    let isFunded=true;\n    if(shape==undefined){\n      isFunded=false;\n    }\n    let i=0;\n    while(!isFunded){\n      if(i<this.groups.length){\n        shape=this.groups[i].shapes_g.find(i => i.id === this.editedText.attrs.id);\n      if(shape==undefined){\n        isFunded=false;\n      }else{\n        isFunded=true;\n      }\n      i++;\n      }else{        \n        isFunded=true;\n      }\n    }\n    if(shape!=undefined){\n    let last_width;\n    let last_height;\n    let diff_width;\n    let diff_height;\n\n    last_width=this.editedText.width();\n    last_height=this.editedText.height();\n\n    shape.text=e.target.value;\n\n    this.editedText.text(e.target.value);\n    diff_width=this.editedText.width()-last_width;\n    diff_height=this.editedText.height()-last_height;\n\n    \n    shape.offsetX=shape.offsetX+diff_width/2\n    shape.offsetY=shape.offsetY+diff_height/2\n    shape.length_x=this.editedText.width()\n    shape.length_y=this.editedText.height()\n    document.getElementById(\"input\").style.display=\"none\"\n    }\n\n  },\n  updateNaration(grp){\n      let text=\"<strong>Substrate with id=\"+grp.id+\":</strong><br>\"\n      if(grp.line.id==1){\n      text=text+\"- <mark class='blue'> StickyLine\"+\" with id=\"+ grp.line.id+\"</mark><br>\";\n      }else{\n       text=text+\"- <mark class='blue'> copied StickyLine\"+\" with id=\"+ grp.line.id+\"</mark><br>\"; \n      }\n      text=text+\"Relation: <i>alignement and distance with</i>:\";\n      for(let j=0;j<grp.shapes_g.length;j++){\n        text=text+\"<br>\"+\"- \"+grp.shapes_g[j].className+\" with id=\"+grp.shapes_g[j].id\n      }\n      text=text+\"<br>Distance kept in memory:\"\n      //+grp.line.occupiedDistances+\",<mark class='green'>\"+grp.line.freeDistances+\"</mark>\";\n      for(let i=0;i<grp.line.occupiedDistances.length;i++){\n        text=text+grp.line.occupiedDistances[i].toFixed(1)+\",\";\n      }\n      text=text+\"<mark class='green'>\"\n      for(let i=0;i<grp.line.freeDistances.length-1;i++){\n        text=text+grp.line.freeDistances[i].toFixed(1)+\",\";\n      }if(grp.line.freeDistances.length>0){\n      text=text+grp.line.freeDistances[grp.line.freeDistances.length-1].toFixed(1);\n      }\n      text=text+\"</mark>\"\n      this.$emit('explain',{origin:\"Instrument - Reuse<br><mark class='blue'> The Stickyline preserving alignment and distances can be reused to apply to other objects. </mark>\",text:text});\n      \n  },\n  //This function has been added so that when there is more than on groups and a mouseenter event occured, \n  //we show state of all the groups.\n  initialNaration(groups){\n    if(!this.narationHasBeenInitialized){\n      let grp; \n      let text='';\n    for(let i=0;i<groups.length-1;i++){\n      grp=groups[i];\n      if(grp.line.id==1){\n      text=text+\"<strong>Substrate with id=\"+grp.id+\":</strong><br>\"\n      text=text+\"- <mark class='blue'> StickyLine\"+\" with id=\"+ grp.line.id+\"</mark><br>\";\n      }else{\n       text=text+\"<strong>Substrate with id=\"+grp.id+\":</strong><br>\";\n       text=text+\"- <mark class='blue'> copied StickyLine\"+\" with id=\"+ grp.line.id+\"</mark><br>\"; \n      }\n      text=text+\"Relation: <i>alignement and distance with</i>:\";\n      for(let j=0;j<grp.shapes_g.length;j++){\n        text=text+\"<br>\"+\"- \"+grp.shapes_g[j].className+\" with id=\"+grp.shapes_g[j].id\n      }\n      text=text+\"<br>Distance kept in memory:\"\n      //+grp.line.occupiedDistances+\",<mark class='green'>\"+grp.line.freeDistances+\"</mark>\";\n      for(let i=0;i<grp.line.occupiedDistances.length;i++){\n        text=text+grp.line.occupiedDistances[i].toFixed(1)+\",\";\n      }\n      text=text+\"<mark class='green'>\"\n      for(let i=0;i<grp.line.freeDistances.length-1;i++){\n        text=text+grp.line.freeDistances[i].toFixed(1)+\",\";\n      }if(grp.line.freeDistances.length>0){\n      text=text+grp.line.freeDistances[grp.line.freeDistances.length-1].toFixed(1);\n      }\n      text=text+\"</mark>\"\n      text=text+\"<br>***<br>\"\n    }\n    grp=groups[groups.length-1]\n      if(grp.line.id==1){\n      text=text+\"<strong>Substrate with id=\"+grp.id+\":</strong><br>\"\n      text=text+\"- <mark class='blue'> StickyLine\"+\" with id=\"+ grp.line.id+\"</mark><br>\";\n      }else{\n       text=text+\"<strong>Substrate with id=\"+grp.id+\":</strong><br>\";\n       text=text+\"- <mark class='blue'> copied StickyLine\"+\" with id=\"+ grp.line.id+\"</mark><br>\"; \n      }\n      text=text+\"Relation: <i>alignement and distance with</i>:\";\n      for(let j=0;j<grp.shapes_g.length;j++){\n        text=text+\"<br>\"+\"- \"+grp.shapes_g[j].className+\" with id=\"+grp.shapes_g[j].id\n      }\n      text=text+\"<br>Distance kept in memory:\"\n      //+grp.line.occupiedDistances+\",<mark class='green'>\"+grp.line.freeDistances+\"</mark>\";\n      for(let i=0;i<grp.line.occupiedDistances.length;i++){\n        text=text+grp.line.occupiedDistances[i].toFixed(1)+\",\";\n      }\n      text=text+\"<mark class='green'>\"\n      for(let i=0;i<grp.line.freeDistances.length-1;i++){\n        text=text+grp.line.freeDistances[i].toFixed(1)+\",\";\n      }if(grp.line.freeDistances.length>0){\n      text=text+grp.line.freeDistances[grp.line.freeDistances.length-1].toFixed(1);\n      }\n      text=text+\"</mark>\"\n      \n      \n    this.narationHasBeenInitialized=true;\n      this.$emit('explain',{origin:\"Instrument - Reuse<br><mark class='blue'> The Stickyline preserving alignment and distances can be reused to apply to other objects. </mark>\",text:text});\n      //In order to avoid the copy of things from one cell to another.\n      //ContextMenu.props.CopiedShape=undefined;\n    }\n  },\n  stopInitialisation(e){\n      //this.narationHasBeenInitialized=true;\n      //console.log(e)\n      e.stopPropagation(); \n    },\n},\n};\n\n</script>\n<style>\n#playground{\n  cursor: default\n}\n#activeReuse{\n  position:absolute;\n  display: none;\n  top: 0px;\n  left: 0px;\n  width: 60px;\n  background-color: white;\n  box-shadow: 0 0 5px grey;\n  border-radius: 3px;\n}\n#center_menu{\n  position: absolute;\n  display: none;\n  top: 0px;\n  left: 0px;\n  width: 60px;\n  background-color: white;\n  box-shadow: 0 0 5px grey;\n  border-radius: 3px;\n}\ninput{\n  position:absolute;\n  display: none;\n  top:0px;\n  left:0px; \n}\n</style> ","<template>\n\n<!--This component is the one of the context menu that can pop on canvas such as the playground-->\n\n<div id=\"menu\">\n<!--<button id=\"ChangeCenter\" @click=\"GenerateButtonEvent\" v-if=\"!menuOfStage\">Change Center</button>-->\n<!--<button id=\"DetachShape\" @click=\"GenerateButtonEvent\" v-if=\"menuOfGroupedShape\">Detach</button>-->\n<button id=\"KeepDistance\" @click=\"GenerateButtonEvent\" v-if=\"menuOfLine && needSwitchDistributionModeButton\">{{ keepDistanceButtonText}}</button>\n<button id=\"Copy\" @click=\"GenerateButtonEvent\" v-if=\"!menuOfStage && needCopyButton\">Copy Stickyline</button>\n<button id=\"CopyAll\" @click=\"GenerateButtonEvent\" v-if=\"menuOfLine && needCopyAllButton\">Copy All</button>\n<button id=\"Past\" @click=\"GenerateButtonEvent\" v-if=\"menuOfStage && needPastButton\">Paste</button>\n<!--<button id=\"Remove\" @click=\"GenerateButtonEvent\" v-if=\"!menuOfStage\">Remove</button>\n<button id=\"RemoveAll\" @click=\"GenerateButtonEvent\" v-if=\"menuOfGroupedShape\">Remove All</button>-->\n</div>\n</template>\n<script>\n\nexport default {\n    props: {\n      \n        //displayMenu: String,\n        ConcernedShape: Object, //Target object (where user right click to make the context menu appear)\n        CopiedShape: Object, //Copied object (if Copy or CopyAll button is selected)\n        pastOneObject:{ //Say if we want to past only one object (after Copy) or all objects of a group (after CopyAll)\n          type: Boolean,\n          default: true,\n        },\n        \n        menuOfStage: { //Say if the context menu is the one of the stage\n          type: Boolean,\n          default:false,\n        },\n        menuOfLine:{ //Say if the context menu is the one of a stickyline\n          type:  Boolean,\n          default: false,\n        },\n        menuOfGroupedShape:{ //Say if the context menu is the one of an attached shape\n          type:  Boolean,\n          default: false,\n        },\n        needCopyButton:{ //Say if we need the copy button\n          type:  Boolean,\n          default: true,\n        },\n        needPastButton:{ //Say if we need the past button\n          type:  Boolean,\n          default: true,\n        },\n        needCopyAllButton:{ //Say if we need the copy All button\n          type:  Boolean,\n          default: true,\n        },\n        needSwitchDistributionModeButton:{ //Say if we need the \"switch distribution mode\" button\n          type:  Boolean,\n          default: true,\n        },\n        keepDistanceButtonText: { //text of the \"switch distribution mode\" button\n          type: String,\n          default: \"Keep Distribution\"\n        }\n    },\n    \n    data(){\n        return{\n            dM: this.displayMenu,\n            cS: \"${this.ConcernedShape.className} ==='Line'\",\n        }\n    },\n    \n    \n    methods:{\n        GenerateButtonEvent(e){\n          if(e.target.id==\"ChangeCenter\"){\n            this.$emit('changecenter-button',this.ConcernedShape);\n          }\n          if(e.target.id==\"DetachShape\"){\n            this.$emit('detachshape-button',this.ConcernedShape);\n          }\n          if(e.target.id==\"KeepDistance\"){\n            this.$emit('keepdistance-button',this.ConcernedShape);\n          }\n          if(e.target.id==\"Copy\"){\n            this.$emit('copy-button',this.ConcernedShape);\n          }\n          if(e.target.id==\"CopyAll\"){\n            this.$emit('copy-all-button',this.ConcernedShape);\n          }\n          if(e.target.id==\"Past\"){\n            this.$emit('past-button',this.CopiedShape);\n          }\n          if(e.target.id==\"Remove\"){\n            this.$emit('remove-button',this.ConcernedShape);\n          }\n          if(e.target.id==\"RemoveAll\"){\n            this.$emit('remove-all-button',this.ConcernedShape);\n          }\n\n        }\n    },\n}\n</script>\n<style scoped>\n     body {\n        margin: 0;\n        padding: 0;\n        overflow: hidden;\n        background-color: #f0f0f0;\n      }\n\n      #menu {\n        display: initial;\n        position: absolute;\n        overflow-y: scroll;\n        max-height:300px;\n        background-color: white;\n        box-shadow: 0 0 5px grey;\n        border-radius: 3px;\n      }\n\n      #menu button {\n        width: 100%;\n        background-color: white;\n        border: none;\n        margin: 0;\n        padding: 10px;\n      }\n\n      #menu button:hover {\n        background-color: lightgray;\n      }\n</style>","import { render } from \"./ContextMenu.vue?vue&type=template&id=07ec8de3&scoped=true\"\nimport script from \"./ContextMenu.vue?vue&type=script&lang=js\"\nexport * from \"./ContextMenu.vue?vue&type=script&lang=js\"\n\nimport \"./ContextMenu.vue?vue&type=style&index=0&id=07ec8de3&scoped=true&lang=css\"\n\nimport exportComponent from \"/Users/junhangyu/Desktop/PE code/github/teachingApp/node_modules/vue-loader/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render],['__scopeId',\"data-v-07ec8de3\"]])\n\nexport default __exports__","import { render } from \"./ReuseDemo.vue?vue&type=template&id=1773eaa2\"\nimport script from \"./ReuseDemo.vue?vue&type=script&lang=js\"\nexport * from \"./ReuseDemo.vue?vue&type=script&lang=js\"\n\nimport \"./ReuseDemo.vue?vue&type=style&index=0&id=1773eaa2&lang=css\"\n\nimport exportComponent from \"/Users/junhangyu/Desktop/PE code/github/teachingApp/node_modules/vue-loader/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render]])\n\nexport default __exports__","<template>\n\n<div @click=\"HideContextMenu\" id=\"playground\"\n@mousedown=\"updateNaration(this.groups[0])\">\n<!--\n  <ToolBar :height=\"100\" :width=\"400\"\n  @need_new_shape=\"createNewShape\" @eraser_is_selected=\"switchEraseMode\"></ToolBar>\n  -->\n  <v-stage\n    ref=\"stage\"\n    id=\"stage\"\n    :config=\"stageSize\"\n    @dragmove=\"update\"\n    @mousedown=\"handleTransformation\"\n    @touchstart=\"handleTransformation\"\n    @fusion=\"makeGroup\"\n    @contextMenu=\"DisplayContextMenu\"\n  >\n    <v-layer ref=\"layer\">\n      <!--\n        see if a group should contain more than one line\n      -->\n      <!--\n      <v-circle :key=\"center.id\" :config=\"center\"/>\n      -->\n      <v-group ref=\"groups\" v-for=\"step in groups\" :key=\"step.id\" :config=\"step\">\n      \n      \n      \n        <v-rect\n        v-for=\"item in step.shapes_g.filter(i=>i.className=='Rect')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        \n       \n        @transformend=\"updateTransformedShape\"\n        @dragend= \"updatePosInGrp($event,step.id) \"\n        @dragmove=\"CheckIfNeedToDetach\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n      />\n      <v-circle\n        v-for=\"item in step.shapes_g.filter(i=>i.className=='Circle')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragend=\"updatePosInGrp($event,step.id)\"\n        @dragmove=\"CheckIfNeedToDetach\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n      />\n      \n      <v-image\n        v-for=\"item in step.shapes_g.filter(i=>i.className=='Image')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragend=\"updatePosInGrp($event,step.id)\"\n        @dragmove=\"CheckIfNeedToDetach\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n      />\n      <v-text\n        v-for=\"item in step.shapes_g.filter(i=>i.className=='Text')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragend=\"updatePosInGrp($event,step.id)\"\n        @dragmove=\"CheckIfNeedToDetach\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n\n        @dblclick=\"editText\"\n        />\n        <v-regular-polygon\n        v-for=\"item in step.shapes_g.filter(i=>i.className=='Triangle')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragend=\"updatePosInGrp($event,step.id)\"\n        @dragmove=\"CheckIfNeedToDetach\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n      />\n        <v-line \n        :key=\"step.line.id\"\n        :config=\"step.line\"\n        @transformend=\"updateTransformedShape\"\n        @dragmove=\"updateGrp($event,step.id)\"\n        @mouseout=\"unshowSelectedShape\"\n        @mouseenter=\"showSelectedShape\"\n        />\n    <v-circle\n        v-for=\"item in step.line.positionPoints\"\n        :key=\"item.id\"\n        :config=\"item\"\n        \n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n      />\n      </v-group>\n      <v-rect\n        v-for=\"item in shapes.filter(i=>i.className=='Rect')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragmove=\"updatePos\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n        \n      />\n      \n      <v-circle\n        v-for=\"item in shapes.filter(i=>i.className=='Circle')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragmove=\"updatePos\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n        \n      />\n      \n      <v-image\n        v-for=\"item in shapes.filter(i=>i.className=='Image')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragmove=\"updatePos\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n        />\n     \n      <v-text\n        v-for=\"item in shapes.filter(i=>i.className=='Text')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragmove=\"updatePos\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n        \n        @dblclick=\"editText\"\n        /> \n      \n      <v-regular-polygon\n        v-for=\"item in shapes.filter(i=>i.className=='Triangle')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragmove=\"updatePos\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n        />\n      \n      \n      <v-transformer  v-for=\"item in transformers\" :key=\"item.id\" :config=\"item\"/>\n      <v-circle :key=\"center.id\" :config=\"center\"\n      @dragend=\"ChangeCenter\"\n      @click=\"DisplayCenterMenu\"/>\n    </v-layer>\n    \n  </v-stage>\n  \n  <input type=\"text\" id=\"input1\" \n        size=\"10\" value=\"the logo\"\n       @keyup.enter=\"updateText\"\n       >\n  </div>\n</template>\n\n<script>\n\n//import ContextMenu from \"./ContextMenu.vue\"\n//import CenterMenu from \"./CenterMenu.vue\"\n//import ToolBar from \"./ToolBar.vue\";\n\nconst dragFunc=function (pos) {\n  let width=this.getStage().width();\n  let height=this.getStage().height();\n  let strokeSize=10\n    if(pos.x>width-strokeSize && pos.y>height-strokeSize){\n      return{\n        x: width-strokeSize,\n        y: height-strokeSize,\n      }\n    } else if(pos.x>width-strokeSize && pos.y<strokeSize){\n      return{\n        x: width-strokeSize,\n        y: strokeSize,\n      }\n    } else if(pos.y>height-strokeSize && pos.x<strokeSize){\n      return{\n        x: strokeSize,\n        y: height-strokeSize,\n      }\n    } else if(pos.x<strokeSize && pos.y<strokeSize){\n      return{\n        x: strokeSize,\n        y: strokeSize,\n      }\n    } else if(pos.x<strokeSize){\n      return{\n        x: strokeSize,\n        y: pos.y,\n      }\n    }else if(pos.y<strokeSize){\n      return{\n        x: pos.x,\n        y: strokeSize,\n      }\n    }else if(pos.x>width-strokeSize){\n      return{\n        x: width-strokeSize,\n        y: pos.y,\n      }\n    }else if(pos.y>height-strokeSize){\n      return{\n        x: pos.x,\n        y: height-strokeSize,\n      }\n    } else{\n      return {\n        x: pos.x,\n        y: pos.y,\n      };\n    }\n};\n\n\nexport default {\n  props:{\n    width:{\n      type: Number,\n      default:window.innerWidth,\n    },\n    height:{\n      type: Number,\n      default:window.innerHeight,\n    }\n  },\n  components:{\n    //ContextMenu,\n    //CenterMenu,\n    //ToolBar,\n},\n  data() {\n    return {\n      stageSize: {\n        width: this.width,\n        height: this.height,\n      },\n      lengthToCapture:10,\n      lengthToDetach:15,\n      editedText:null,\n\n      eraseMode:0,\n\n      selectedShapeAlignment:'',\n      \n      needMenu: 'initial', //say if the context menu has to be \"active\" or not.\n      isALineSelected:false, \n      isAGroupedShapeSelected:false,\n      isStageOnlySelected: false,\n      //dragItemId: null, //id of the item which is dragging.\n      //text which will appear on the button corresponding to the management of the distribution\n      keepDistanceButtonText:\"Liberate Distribution\",\n      max_id_figures: 6, //max among id of shapes and line since the canvas exist (line excluded) \n      //max_id_lines: 2, //max among id of lines since the canvas exist (line excluded) \n      //groups of shapes (ie a line with shapes on it)\n      groups:[{\n        //rotation: 20,\n        name: \"group\",\n        className: \"Group\",\n        id: '6',\n        x:0,\n        y:0,\n        offsetX:0,\n        offsetY:0,\n        rotation: 0,\n        draggable: false,\n        shapes_g:[], //list of shapes that are on the line\n        //the line of the group:\n        aShapeHasBeenDetach:0,\n        line:{\n          x:150,\n          y:250,\n          points: [0, 0, 0, 0, 250, 0],\n          positionPoints:[],\n          strokeWidth: 10,\n          rotation: 0,\n          tension:0,\n          closed: true,\n          draggable: true,\n          scaleX:1,\n          scaleY:1,\n          opacity:0.5,\n          offset:{\n            x:125,\n            y:0,\n          },\n          name: \"ligne\",\n          className: \"Line\",\n          stroke: 'red',\n          id:'6',\n          //distShapesToCenter:[],\n          keepDistribution: false, //say of we keep the distribution on the line or not\n          freeDistances:[], // distance that can be taken by other shapes (if we keep distribution on the line).\n          occupiedDistances:[], //distance already \"taken\" by shapes on the line.       \n          //text which will appear on the button corresponding to the management of the distribution:\n          keepDistanceButtonText:\"Liberate Distribution\",\n          //function which determine how the line can be dragged:\n          defaultAlignment:\"Bottom\",\n          dragBoundFunc: dragFunc,\n        },\n      },\n      /*{\n        name: \"group2\",\n        className: \"Group\",\n        id: '7',\n        x:0,\n        y:0,\n        offsetX:0,\n        offsetY:0,\n        rotation: 0,\n        draggable: false,\n        shapes_g:[],\n        line:{\n        x:500,\n        y:300,\n        points: [0, 0, 0, 0, 300, 0],\n        positionPoints:[],\n        strokeWidth: 10,\n        rotation: 0,\n        tension:0,\n        closed: true,\n        draggable: true,\n        scaleX:1,\n        scaleY:1,\n        opacity:0.5,\n        offset:{\n          x:150,\n          y:0,\n        },\n        //draggable:true,\n        name: \"ligne\",\n        className: \"Line\",\n        stroke: 'black',\n        id:'7',\n        distShapesToCenter:[],\n        keepDistribution: true,\n        freeDistances:[],\n        occupiedDistances:[],\n        keepDistanceButtonText:\"Liberate Distribution\",\n        defaultAlignment:\"Middle\",\n        dragBoundFunc: dragFunc,\n      },\n      \n      }*/\n      ],\n      transformers:[\n        {\n          id: 'lineTransformer',\n          enabledAnchors: [],\n          rotateEnabled: false,\n          borderEnabled:false,\n          flipEnabled: false, // in order to not have a rotation of the transformer which lead to problem related to shapes position on a line\n          nodes: [],\n\n        },\n        {\n          id: 'shapeTransformer',\n          nodes: [],\n        }\n      ],\n      shapes: [\n        /*\n        {\n          rotation: 0,\n          id: '1',\n          x: 100,\n          y: 10,\n          width: 130,\n          height: 100,\n          scaleX: 1,\n          scaleY: 1,\n          strokeWidth: 0,\n          stroke: 'black',\n          fill: 'red',\n          name: 'rect1',\n          draggable: true,\n          className:\"Rect\",\n          isGrouped: 0, //if =0 the shape is not attached to a stickyline. if=1, it does.\n          offsetX:130/2,\n          offsetY:0,\n          personalRotation:0, \n          centerPosition:'Top',\n          dragBoundFunc: dragFunc\n          \n        },\n        */\n        /*\n        {\n          rotation: 0,\n          id:'2',\n          x: 200,\n          y: 260,\n          width: 100,\n          height: 100,\n          scaleX: 1,\n          scaleY: 1,\n          strokeWidth: 0,\n          stroke: 'black',\n          fill: 'green',\n          name: 'rect2',\n          draggable: true,\n          className:\"Rect\",\n          isGrouped: 0,\n          dragBoundFunc: dragFunc,\n          offsetX: 100/2,\n          offsetY: 100,\n          personalRotation:0, \n          centerPosition: 'Bottom',\n        },\n        */\n        /*\n        {\n        rotation:0,\n        x: 100,\n        y: 150,\n        scaleX:1,\n        scaleY:1,\n        offsetX: 0,\n        offsetY: 50,\n        radius: 50,\n        fill: 'orange',\n        strokeWidth: 0,\n        stroke: 'black',\n        draggable:true,\n        isGrouped: 0,\n        className:\"Circle\",\n        personalRotation:0, \n        id:'3',\n        dragBoundFunc: dragFunc,\n        centerPosition:'Bottom',\n      },\n      */\n      \n        {\n            text: 'the logo',\n            rotation: 0,\n            x: 150,\n            y: 190,           \n            scaleX:1,\n            scaleY:1,\n            offsetY:0,\n            offsetX: 36,\n            length_x:72,\n            length_y:30,\n            draggable: true,\n            isGrouped: 0,\n            className:\"Text\",    \n            fontSize: 30,\n            fontFamily: 'Calibri',\n          personalRotation:0,\n            id:'4',\n            dragBoundFunc:dragFunc,\n            centerPosition:'Top',\n        },\n        \n        {\n            rotation: 0,\n            x: 50,\n            y: 100,           \n            scaleX:0.66,\n            scaleY:0.66,\n            offsetY:0,\n            offsetX:0,\n            //width:72,\n            //height:30,\n            image: null,\n            draggable: true,\n            isGrouped: 0,\n            className:\"Image\", \n               \n            fontSize: 30,\n          personalRotation:0, \n            id:'5',\n            dragBoundFunc:dragFunc,\n            centerPosition:'Bottom',\n        },\n        \n        \n         {\n          rotation: 0,\n          id:'8',\n          x: 250,\n          y: 100,\n          sides:3,\n          radius:45,\n          width: 90,\n          height: 90,\n          scaleX: 1,\n          scaleY: 1,\n          strokeWidth: 0,\n          stroke: 'black',\n          fill: 'purple',\n          name: 'triangle1',\n          draggable: true,\n          className:\"Triangle\",\n          isGrouped: 0,\n          dragBoundFunc: dragFunc,\n          offsetX: 0,\n          offsetY: 22.5,\n          personalRotation:0, \n          centerPosition:'Bottom',\n        },\n      ],\n      center:{\n        x: 300,\n        y: 500,\n        scaleX:1,\n        scaleY:1,\n        offsetX: 0,\n        offsetY: 0,\n        radius: 4,\n        fill: 'black',\n        opacity:1,\n        draggable:true,\n        isGrouped: 0,\n        className:\"Circle\",\n        id:'center',\n        dragBoundFunc:dragFunc,\n      },\n      positionPoint:{\n        x: 300,\n        y: 500,\n        scaleX:1,\n        scaleY:1,\n        offsetX: 0,\n        offsetY: 0,\n        radius: 3,\n        fill: 'yellow',\n        opacity:1,\n        draggable:false,\n        isGrouped: 0,\n        className:\"positionPoint\",\n        id:'positionPoint',\n        distance_to_line_center:undefined,\n      },\n      selectedShapeId: '',\n    };\n  },\n  mounted(){\n    let texts=this.$refs.stage.getStage().getChildren()[0].getChildren().filter((r)=>r.attrs.className=='Text');\n    \n    \n    for(let i=0;i<texts.length;i++){\n      texts[i].attrs.length_x=texts[i].width();\n      texts[i].attrs.length_y=texts[i].height();\n      texts[i].offsetX(texts[i].attrs.length_x/2);\n      texts[i].offsetY(texts[i].height())\n    }\n  },\n  created(){\n    //nb of shapes on the canvas (line excluded), we consider that there is no shape on line:\n    this.max_id_figures=this.shapes.length +this.groups.length; \n    //this.max_id_lines=this.groups.length;\n    const image = new window.Image();\n    image.src = require(\"@/assets/exsitu.png\");\n    // set image only when it is loaded\n    image.height=150;\n    image.width=150;\n    image.onload = () => {\n      this.shapes.find((r)=>r.className===\"Image\").image= image;\n      this.shapes.find((r)=>r.className===\"Image\").offsetX=image.width/2;\n      this.shapes.find((r)=>r.className===\"Image\").offsetY=image.height; \n    };\n  },\n  methods: {\n\n    switchEraseMode(){\n      if(this.eraseMode==0){\n        this.eraseMode=1;\n        document.getElementById(\"playground\").style.cursor='url('+require('@/assets/ugly_eraser.png')+'),default';\n        \n      this.eraseNodefromTransformer(\"shapeTransformer\");\n      this.eraseNodefromTransformer(\"lineTransformer\");\n      } else{\n        this.eraseMode=0;\n        document.getElementById(\"playground\").style.cursor=\"default\";\n      }\n    },\n    /*\n    Check if all shapes that are supposed to be on a line still in this line.\n    id_grp is the id of the group which contains the line.\n    */\n    checkIfShapesOnLine(id_grp){\n      const grp= this.groups.find((r) => r.id===id_grp);\n      const line=grp.line;\n      const groupedShapes = grp.shapes_g;\n      //const lengthToDetach=10;\n      \n      /*\n      To determine if a shape is on a line, we see if the point is not on the corresponding\n      straight line y=a*x+b regarding certains intervals for x and y.Those intervals depends of the rotation of\n      the line. \n      */\n     /*\n      let coord_y1=line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x1=line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let coord_y2= line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x2=line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let a=(coord_y1-coord_y2)/(coord_x2-coord_x1);\n      let b=line.y-a*line.x;\n      let is_on_straight_line=false;\n      */\n      \n      let i=0;\n      while(i<groupedShapes.length){\n        /*\n        if(Math.abs(coord_x1-coord_x2)>1){\n        is_on_straight_line=(Math.abs(a*groupedShapes[i].x+b-groupedShapes[i].y)<this.lengthToDetach);\n      }else{\n        is_on_straight_line=(Math.abs(groupedShapes[i].x-line.x)<this.lengthToDetach);\n      }\n        if (\n          !(is_on_straight_line)\n        ||((line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].y\n        ||line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].y)\n        && ((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n        ||((line.x+line.points[4]*line.scaleX*(1/2)*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].x\n        ||line.x-line.points[4]*line.scaleX*(1/2)*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].x)\n        &&((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n        ||((line.y+line.points[4]*line.scaleX*(1/2)*Math.sin(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].y\n        ||line.y-line.points[4]*line.scaleX*(1/2)*Math.sin(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].y)\n        &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>=-Math.PI)))\n\n        ||((line.x+line.points[4]*line.scaleX*(1/2)*Math.cos(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].x\n        ||line.x-line.points[4]*line.scaleX*(1/2)*Math.cos(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].x)\n        &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>=-Math.PI)))\n\n        ||((line.y+line.points[4]*line.scaleX*(1/2)*Math.sin(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].y\n        ||line.y-line.points[4]*line.scaleX*(1/2)*Math.sin(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].y)\n        &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n        ||((line.x+line.points[4]*line.scaleX*(1/2)*Math.cos(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].x\n        ||line.x-line.points[4]*line.scaleX*(1/2)*Math.cos(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].x)\n        &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n        ||((line.y+line.points[4]*line.scaleX*(1/2)*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].y\n        ||line.y-line.points[4]*line.scaleX*(1/2)*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].y)\n        &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>0)))\n\n        ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].x\n        ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].x)\n        &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>0)))\n        )\n        */\n       if(!this.isCoordinateOnLine(groupedShapes[i].x,groupedShapes[i].y,line.id)){\n          console.log(\"a shape is not on a line\");\n          groupedShapes[i].dragBoundFunc= dragFunc;\n          groupedShapes[i].isGrouped=0;\n          line.positionPoints.splice(i,1)\n          \n          this.shapes.push(groupedShapes[i],)\n          line.freeDistances.push(line.occupiedDistances[i]);\n          line.occupiedDistances.splice(i,1);\n          groupedShapes.splice(i,1);\n          this.updateNaration(grp);\n        }else{\n          i=i+1;  \n        }\n      }\n    },\n\n    //say of {x,y} is a point from the line\n    isCoordinateOnLine(x,y,id_grp){\n      const grp=this.groups.find((r) => r.id===id_grp);\n      const line=grp.line;\n      let is_not_on_straight_line=true;\n      let coord_y1=line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x1=line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let coord_y2= line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x2=line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let a=(coord_y1-coord_y2)/(coord_x2-coord_x1);\n      let b=line.y-a*line.x;\n      if(Math.abs(coord_x1-coord_x2)>1){\n        is_not_on_straight_line=(Math.abs(a*x+b-y)>1);\n      }else{\n        is_not_on_straight_line=(Math.abs(x-line.x)>1)\n      }\n      if(\n        (is_not_on_straight_line)\n\n      ||((line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<y\n      ||line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>y)\n      && ((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<x\n        ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>x)\n      &&((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<y\n        ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>y)\n      &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>-Math.PI)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>x)\n      &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>-Math.PI)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>y)\n      &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>x)\n      &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>y)\n      &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>=0)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>x)\n      &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>=0)))\n\n      ||(!is_not_on_straight_line && Math.sqrt((line.x-x)**2+(line.y-y)**2)>line.points[4]*line.scaleX/2)\n\n      )\n      {\n        return false; \n      } else{\n        return true;\n      }\n    },\n\n    //update a group with the id id_grp\n    updateGrp(e,id_grp){\n      const grep=this.groups.find((r)=>r.id===id_grp);\n      const line= grep.line;\n      grep.offsetX=line.offsetX;\n      grep.offsetY=line.offsetY;\n      \n      line.x=e.target.x();\n      line.y=e.target.y();\n      this.center.x=line.x;\n      this.center.y=line.y;\n      /*\n      if(line.keepDistribution){\n        this.updateOccupiedDistance(line.id);\n      }\n      */\n      this.updateAllPosInGrp(line.id); \n      this.checkIfShapesOnLine(line.id);\n    },\n\n\n    //update the position of all shapes that are on the line of the group with the id id_grp.\n    updateAllPosInGrp(id_grp){\n      const grp= this.groups.find((r) => r.id===id_grp);     \n      const line= grp.line;\n      const shapes_g = grp.shapes_g;\n      for (let i=0;i<shapes_g.length;i++){\n          if(line.keepDistribution){\n            shapes_g[i].x=line.x+line.occupiedDistances[i]*Math.cos(line.rotation*(Math.PI/180));\n            shapes_g[i].y=line.y+line.occupiedDistances[i]*Math.sin(line.rotation*(Math.PI/180));\n            shapes_g[i].distance_to_line_center=line.occupiedDistances[i];\n            shapes_g[i].rotation=shapes_g[i].personalRotation+line.rotation;\n            \n          } else{\n            shapes_g[i].x=line.x+line.occupiedDistances[i]*Math.cos(line.rotation*(Math.PI/180));\n            shapes_g[i].y=line.y+line.occupiedDistances[i]*Math.sin(line.rotation*(Math.PI/180));\n            shapes_g[i].distance_to_line_center=line.occupiedDistances[i];\n            shapes_g[i].rotation=shapes_g[i].personalRotation+line.rotation;\n          }\n          line.positionPoints[i].x=shapes_g[i].x;\n          line.positionPoints[i].y=shapes_g[i].y;\n          line.positionPoints[i].distance_to_line_center=shapes_g[i].distance_to_line_center;\n      }\n      let i=shapes_g.length;\n      while(i<line.positionPoints.length){\n        if(line.keepDistribution){\n          line.positionPoints.splice(i,1);\n        }else{\n        line.positionPoints[i].x=line.x+line.freeDistances[i-shapes_g.length]*Math.cos(line.rotation*(Math.PI/180));\n        line.positionPoints[i].y=line.y+line.freeDistances[i-shapes_g.length]*Math.sin(line.rotation*(Math.PI/180));\n        line.positionPoints[i].distance_to_line_center=line.freeDistances[i-shapes_g.length];\n        i++;\n        }\n        \n      }\n    \n    },\n    isOutsideTheLine(shape,line){\n      let coord_y1=line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x1=line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let coord_y2= line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x2=line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let a=(coord_y1-coord_y2)/(coord_x2-coord_x1);\n      let b=line.y-a*line.x;\n      let is_on_straight_line=false;\n      if(Math.abs(coord_x1-coord_x2)>=1){\n        is_on_straight_line=(Math.abs(a*shape.x+b-shape.y)<1);\n      }else{\n        is_on_straight_line=(Math.abs(shape.x-line.x)<1);\n      }\n      if(\n        !(is_on_straight_line)\n      ||((line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n        ||line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      && ((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>-Math.PI)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>-Math.PI)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>=0)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>=0)))\n      ){\n        return true;\n      }else{ return false}\n    },\n    \n    //update the canvas\n    update(){\n      const shapes = this.shapes\n      \n      //const lengthToCapture=10; //bigger is the number, bigger is the intervals of x and y where a shape can be added to a line.\n      let is_on_straight_line=false;\n      for (let i=0;i<shapes.length;i++){\n        let x=shapes[i].x;\n        let y=shapes[i].y;\n      for (let j=0;j<this.groups.length;j++){\n      \n        let line=this.groups[j].line;\n\n        \n        let coord_y1=line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n        let coord_x1=line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n        let coord_y2= line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n        let coord_x2=line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n        let a=(coord_y1-coord_y2)/(coord_x2-coord_x1);\n        let b=line.y-a*line.x;\n        if(Math.abs(coord_x1-coord_x2)>1){\n          is_on_straight_line=(Math.abs(a*x+b-y)<=this.lengthToCapture);\n        }else{\n          is_on_straight_line=(Math.abs(x-line.x)<=this.lengthToCapture);\n          //is_on_straight_line=true;\n        }\n        if(\n        (\n          is_on_straight_line\n      &&(line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToCapture>=y\n      && line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToCapture<=y)\n      &&(line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToCapture>=x\n      && line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToCapture<=x)\n      &&(line.rotation*(Math.PI/180)<=0 \n      && line.rotation*(Math.PI/180)>-Math.PI/2))\n\n      ||(\n        is_on_straight_line\n      &&(line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))+this.lengthToCapture>=y\n      && line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))-this.lengthToCapture<=y) \n      &&(line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))+this.lengthToCapture>=x\n      && line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))-this.lengthToCapture<=x)\n      &&(line.rotation*(Math.PI/180)<=-Math.PI/2 \n      && line.rotation*(Math.PI/180)>=-Math.PI))\n\n      ||(\n        is_on_straight_line\n      &&(line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))+this.lengthToCapture>=y\n      &&line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))-this.lengthToCapture<=y)\n      &&(line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))+this.lengthToCapture>=x\n      && line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))-this.lengthToCapture<=x)\n      &&(line.rotation*(Math.PI/180)<=Math.PI \n      && line.rotation*(Math.PI/180)>Math.PI/2))\n\n      ||(\n        is_on_straight_line\n      &&(line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToCapture>=y\n      && line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToCapture<=y)\n      &&(line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToCapture>=x\n      && line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToCapture<=x)\n      &&(line.rotation*(Math.PI/180)<=Math.PI/2\n      && line.rotation*(Math.PI/180)>=0))\n      )\n       {\n          shapes[i].isGrouped=1;\n          this.makeGroup(line.id);\n        }\n      }\n      }\n    },\n\n    CheckIfNeedToDetach(e){\n      let grp=this.groups.find((r)=>r.id===e.target.getParent().attrs.id);\n      let shape= grp.shapes_g.find((r)=>r.id==e.target.id());\n      let dist=Math.sqrt((e.target.getStage().getPointerPosition().y-e.target.y())**2+(e.target.getStage().getPointerPosition().x-e.target.x())**2);\n      if(e.target.className==\"Rect\"){\n        dist-=e.target.attrs.height*e.target.attrs.scaleY;\n      } else if(e.target.className==\"Circle\"){\n        dist-=(2*e.target.attrs.radius)*e.target.attrs.scaleY;\n      } else if(e.target.className==\"Text\"){\n        dist-=e.target.attrs.length_y*e.target.attrs.scaleY;\n      } else if(e.target.className==\"Image\"){\n        dist-=e.target.height()*e.target.scaleY();\n      } else if(e.target.attrs.className==\"Triangle\"){\n        dist-=e.target.height()*e.target.scaleY();\n      } \n      \n      if (dist>50){\n        //let shape= this.groups.find((r)=>r.id===e.target.getParent().attrs.id).shapes_g.find((r)=>r.id==e.target.id());\n        //this.groups.find((r)=>r.id===e.target.getParent().attrs.id).shapes_g.find((r)=>r.id==e.target.id()).needToBeDetach=1;\n        /*\n        shape.dragBoundFunc= function (pos) {\n              return {\n                x: pos.x,\n                y: pos.y,\n              };\n        }\n        */\n        //shape.x=e.target.getStage().getPointerPosition().x;\n        //shape.y=e.target.getStage().getPointerPosition().y;\n        //if (Math.abs(e.target.getStage().getPointerPosition().y-e.target.y())>220){\n        //shape.x=e.target.getStage().getPointerPosition().x;\n        //shape.y=e.target.getStage().getPointerPosition().y;\n        this.groups.find((r)=>r.id===e.target.getParent().attrs.id).aShapeHasBeenDetach=1;\n        this.DetachShape(shape,e.target.getStage().getPointerPosition().x,e.target.getStage().getPointerPosition().y);\n        //}\n        \n        \n        \n      }\n    },\n\n    //Give the sign of the distance of shape from the center of a line.\n    GiveSignOfDistance(shape,line){\n      let result;\n      let angle=line.rotation*(Math.PI/180);\n      let distX=shape.x-line.x;\n      let distY=shape.y-line.y;\n      /*\n      \n      if(angle<=-Math.PI/4 || angle>=-Math.PI/2){\n        result=-Math.sign(distY);\n      }\n      else if(angle<=-Math.PI/2 || angle>=-3*Math.PI/4){\n        result=Math.sign(distY);\n      }\n      else if(angle<=-3*Math.PI/4 || angle>=-Math.PI){\n        result=-Math.sign(distX);\n      }else if(angle>=3*Math.PI/4 || angle<=Math.PI){\n        result=Math.sign(distX);\n      }else if(angle>=Math.PI/2 || angle<3*Math.PI/4){\n        result=-Math.sign(distY);\n      } else if(angle<=Math.PI/2 || angle>Math.PI/4){\n        result=-Math.sign(distY);\n      } else if(angle<=Math.PI/4 || angle>=0){\n        result=Math.sign(distX);\n      }\n      */\n      \n      \n      if(Math.abs(distX)<=this.lengthToCapture && line.rotation==-90){\n        \n        result=-Math.sign(distY);\n      } else if (Math.abs(distX)<=this.lengthToCapture && line.rotation==90){\n        result=Math.sign(distY);\n      }\n      else{\n        result=Math.sign(distX);\n      }\n      if(angle<-Math.PI/2 || angle>Math.PI/2){\n        result=-result;\n      }\n      \n      return result;\n    },\n\n    //Different from the previous function bcs the straight line of the center is perdendicular to the line\n    GiveSignOfDistanceBtwCenterAndShape(center,shape){\n      let result;\n      let angle=shape.rotation*(Math.PI/180);\n      let distX=center.x-shape.x;\n      let distY=center.y-shape.y;\n      /*\n      \n      if(angle<=-Math.PI/4 || angle>=-Math.PI/2){\n        result=-Math.sign(distY);\n      }\n      else if(angle<=-Math.PI/2 || angle>=-3*Math.PI/4){\n        result=Math.sign(distY);\n      }\n      else if(angle<=-3*Math.PI/4 || angle>=-Math.PI){\n        result=-Math.sign(distX);\n      }else if(angle>=3*Math.PI/4 || angle<=Math.PI){\n        result=Math.sign(distX);\n      }else if(angle>=Math.PI/2 || angle<3*Math.PI/4){\n        result=-Math.sign(distY);\n      } else if(angle<=Math.PI/2 || angle>Math.PI/4){\n        result=-Math.sign(distY);\n      } else if(angle<=Math.PI/4 || angle>=0){\n        result=Math.sign(distX);\n      }\n      */\n      \n      \n      if(Math.abs(distY)<=this.lengthToCapture && shape.rotation==-90){\n        \n        result=Math.sign(distX);\n      } else if (Math.abs(distY)<=this.lengthToCapture && shape.rotation==90){\n        result=-Math.sign(distX);\n      }\n      else{\n        result=Math.sign(distY);\n      }\n      if(angle<-Math.PI/2 || angle>Math.PI/2){\n        result=-result;\n      }\n      \n      return result;\n    },\n\n    /*add shapes with isGrouped==1 to the group with the id id_grp.\n    */\n    makeGroup(id_grp){\n      this.eraseNodefromTransformer(\"shapeTransformer\");\n      this.eraseNodefromTransformer(\"lineTransformer\");\n      const grp=this.groups.find((r)=> r.id===id_grp);\n      const line=grp.line;\n      const shapes = this.shapes;\n      line.freeDistances.sort(this.isSmaller); //we will give the shortest available distance to the added shape\n      shapes.sort(this.isBeforeRegardingX);\n      for (let i=0;i<shapes.length;i++){\n        if(shapes[i].isGrouped==1){\n          const positionPoint=Object.assign({},this.positionPoint);\n          let distX=shapes[i].x-line.x;\n          let distY=shapes[i].y-line.y; \n          shapes[i].personalRotation=0;\n          //let pot_dist=this.GiveSignOfDistance(shapes[i],line)*Math.sqrt((distX)**2+(distY)**2);\n          /*\n          if(line.keepDistribution && line.freeDistances.length>0){\n          let distances=line.freeDistances+line.occupiedDistances;\n          console.log(distances);\n           let freeDistance=this.isNearest(line.freeDistances,pot_dist);\n           //shapes[i].distance_to_line_center=freeDistance.res; \n           shapes[i].distance_to_line_center=this.GiveSignOfDistance(shapes[i],line)*Math.sqrt((distX)**2+(distY)**2);\n            \n           line.occupiedDistances.push(shapes[i].distance_to_line_center,);\n           line.freeDistances.splice(freeDistance.indice,1);\n\n          } else{\n            */\n            //let distX=shapes[i].x-line.x;\n            //let distY=shapes[i].y-line.y;\n            shapes[i].distance_to_line_center=this.GiveSignOfDistance(shapes[i],line)*Math.sqrt((distX)**2+(distY)**2);\n            /*If the distance is a little bit to far from the center \n            we adjust it so that the shape can be at one of the border of the stickyline*/\n            if(Math.abs(shapes[i].distance_to_line_center)>=line.points[4]*line.scaleX/2){\n              shapes[i].distance_to_line_center=Math.sign(shapes[i].distance_to_line_center)*line.points[4]*line.scaleX/2\n            }\n            this.ChangeCenterRegardingCommand(shapes[i].id,grp.line.defaultAlignment);\n            \n              //shapes[i].isGrouped=0;\n              this.updateDragFunc(shapes[i],line);\n              grp.shapes_g.push(shapes[i],);\n              console.log(\"no 'free distance' anymore\")\n              grp.line.occupiedDistances.push(shapes[i].distance_to_line_center,);\n              positionPoint.id=\"positionPoint\"+grp.id+grp.line.positionPoints.length;\n              grp.line.positionPoints.push(positionPoint,);\n              //shapes[i].distance_to_line_center=this.GiveSignOfDistance(shapes[i],line)*Math.sqrt((distX)**2+(distY)**2);\n            \n            //line.occupiedDistances.push(shapes[i].distance_to_line_center,);\n          //}\n          console.log(\"A new shape has been added with a distance\"+shapes[i].distance_to_line_center);\n          \n          \n          //shapes[i].isGrouped=0;\n          //this.updateDragFunc(shapes[i],line);\n          //grp.shapes_g.push(shapes[i],);\n          this.updateOccupiedDistance(line.id);\n          \n          this.updateAllPosInGrp(id_grp);\n          this.updateNaration(grp);\n          shapes.splice(i,1);\n        }\n      }\n      this.center.x=line.x;\n      this.center.y=line.y;\n    },\n\n    updateOccupiedDistance(id_grp){\n      \n      const grp=this.groups.find((r)=> r.id===id_grp);\n      //this.updateAllPosInGrp(id_grp);\n      this.sortByDistToLineCenter(grp);\n      \n      //let l=grp.line.points[4]/2;\n      if(grp.line.keepDistribution){\n      let L=grp.line.points[4];\n      let nb_shapes=grp.shapes_g.length;\n      let d=(L/(nb_shapes-1))*grp.line.scaleX;\n      if(nb_shapes%2==0){\n        \n      for (let i =1;i<=nb_shapes/2-1;i++){\n        //grp.line.occupiedDistances[i-1]=-(l/i);\n        grp.line.occupiedDistances[i-1]=-((nb_shapes/2-1)-i+1)*d-d/2\n      }\n      for (let i =1;i<=nb_shapes/2-1;i++){\n        grp.line.occupiedDistances[nb_shapes/2+i]=i*d+d/2;\n      }\n      grp.line.occupiedDistances[nb_shapes/2-1]=-d/2\n      grp.line.occupiedDistances[nb_shapes/2]=d/2\n      } else{\n        for (let i =1;i<=(nb_shapes-1)/2;i++){\n          grp.line.occupiedDistances[i-1]=-d*(((nb_shapes-1)/2)-i+1);\n        }\n        for (let i =1;i<=(nb_shapes-1)/2;i++){\n          grp.line.occupiedDistances[((nb_shapes-1)/2)+i]=d*i;\n        }\n        grp.line.occupiedDistances[(nb_shapes-1)/2]=0;\n      }\n      \n      for (let i=0;i<grp.shapes_g.length;i++){\n        grp.shapes_g[i].distance_to_line_center=grp.line.occupiedDistances[i];\n      }\n      }\n      else{\n        grp.line.occupiedDistances.sort(this.isSmaller);\n      }\n      \n      \n      \n    \n\n    },\n\n   isSmaller(a,b){\n    if(a<b){\n      return -1;\n    }else{\n      return 1\n    }\n   },\n\n   isBeforeRegardingX(a,b){\n    if(a.x<b.x){\n      return -1;\n    }else{\n      return 1;\n    }\n   },\n\n    \n   updateOccDist(grp,shape){\n    let res=this.isNearest(grp.line,shape);\n    //let grp=this.groups.find((r)=>r.id===line.id);\n    if(res.isFree){\n      shape.distance_to_line_center=grp.line.freeDistances[res.indice];\n      grp.line.freeDistances.splice(res.indice,1);\n      this.sortByDistToLineCenter(grp);\n      for(let l=0;l<grp.shapes_g.length;l++){\n        if(grp.line.occupiedDistances.length==l){\n          grp.line.occupiedDistances.push(grp.shapes_g[l].distance_to_line_center,);\n        }else{\n          grp.line.occupiedDistances[l]=grp.shapes_g[l].distance_to_line_center;\n        }\n      } \n    } else{\n      grp.shapes_g.find((r)=>r.id==shape.id).distance_to_line_center=grp.line.occupiedDistances[res.indice];\n      grp.line.occupiedDistances.splice(res.indice,1);\n      //line.occupiedDistances.push(shape.distance_to_line_center,);\n      //line.freeDistances.splice(res.indice,1);   \n      this.updateOccDist(grp,grp.shapes_g[res.indice]);\n    }\n   },\n   isNearest(line,shape){\n    let ecart;\n    let invx=line.x+line.freeDistances[0]*Math.cos(line.rotation*(Math.PI/180));\n    let invy=line.y+line.freeDistances[0]*Math.sin(line.rotation*(Math.PI/180));\n    let ecart_min=Math.sqrt((invx-shape.x)**2+(invy-shape.y)**2);\n    let indice=0;\n    for(let i=1;i<line.freeDistances.length;i++){\n      invx=line.x+line.freeDistances[i]*Math.cos(line.rotation*(Math.PI/180));\n      invy=line.y+line.freeDistances[i]*Math.sin(line.rotation*(Math.PI/180));\n      ecart=Math.sqrt((invx-shape.x)**2+(invy-shape.y)**2);\n      if(ecart<ecart_min){\n        //res=line.freeDistances[i];\n        ecart_min=ecart;\n        indice=i;\n      }\n    }\n    return indice;\n    /*\n    let allDist=line.freeDistances.concat(line.occupiedDistances);\n    console.log(allDist);\n    \n    let ecart;\n    let invx=line.x+allDist[0]*Math.cos(line.rotation*(Math.PI/180));\n    let invy=line.y+allDist[0]*Math.sin(line.rotation*(Math.PI/180));\n    let ecart_min=Math.sqrt((invx-shape.x)**2+(invy-shape.y)**2)\n    let indice=0;\n    console.log(ecart_min);\n    for(let i=1;i<allDist.length;i++){\n      invx=line.x+allDist[i]*Math.cos(line.rotation*(Math.PI/180));\n      invy=line.y+allDist[i]*Math.sin(line.rotation*(Math.PI/180));\n      ecart=Math.sqrt((invx-shape.x)**2+(invy-shape.y)**2);\n      if(this.groups.find((r)=>r.id==line.id).shapes_g.indexOf(shape)!=-1){\n        console.log(ecart_min);\n        console.log(ecart);\n        if(ecart<ecart_min && ecart!=0){\n          //res=allDist[i];\n          ecart_min=ecart;\n          indice=i;\n        }\n      }else if(ecart<ecart_min){\n        //res=allDist[i];\n        ecart_min=ecart;\n        indice=i;\n      }\n    }\n    console.log(indice);\n    if(indice>=line.freeDistances.length){\n      return{\n        isFree: false,\n        indice: indice-line.freeDistances.length,\n      }\n    }else{\n      return{\n        isFree: true,\n        indice: indice,\n      }\n    }\n    */\n\n    /*\n    line.freeDistances.sort(this.isSmaller);\n    let ecart;\n    let invx=line.x+line.freeDistances[0]*Math.cos(line.rotation*(Math.PI/180));\n    let invy=line.y+line.freeDistances[0]*Math.sin(line.rotation*(Math.PI/180));\n    let ecart_min=Math.sqrt((invx-shape.x)**2+(invy-shape.y)**2)\n    let indice=0;\n    for(let i=0;i<line.freeDistances.length;i++){\n      invx=line.x+line.freeDistances[i]*Math.cos(line.rotation*(Math.PI/180));\n      invy=line.y+line.freeDistances[i]*Math.sin(line.rotation*(Math.PI/180));\n      ecart=Math.sqrt((invx-shape.x)**2+(invy-shape.y)**2)\n      if(ecart<ecart_min){\n        //res=freeDistances[i];\n        ecart_min=ecart;\n        indice=i;\n      }\n    }\n    return indice;\n    */\n    /*\n    if(shapeDistance>=0){\n      for(let i=0;i<freeDistances.length;i++){\n        if(freeDistances[i]>shapeDistance){\n          return i;\n        }\n      }\n      return freeDistances.length-1;\n    }else{\n      let ecart_min=Math.abs(Math.abs(freeDistances[0])-Math.abs(shapeDistance))\n      let indice=0;\n      for(let i=0;i<freeDistances.length;i++){\n        let ecart=Math.abs(Math.abs(freeDistances[i])-Math.abs(shapeDistance));\n        if(ecart<ecart_min){\n          //res=freeDistances[i];\n          ecart_min=ecart;\n          indice=i;\n        }\n      }\n      return indice;\n    }\n    */\n    /*\n    //let res=freeDistances[0];\n    let ecart_min=Math.abs(Math.abs(freeDistances[0])-Math.abs(shapeDistance))\n    let indice=0;\n    for(let i=0;i<freeDistances.length;i++){\n      let ecart=Math.abs(Math.abs(freeDistances[i])-Math.abs(shapeDistance));\n      if(ecart<ecart_min){\n        //res=freeDistances[i];\n        ecart_min=ecart;\n        indice=i;\n      }\n    }\n    return indice;\n    */\n   },\n   \n\n   sortByDistToLineCenter(grp){\n    //this.updateAllPosInGrp(grp.id)\n    //let last_distX=new Array(grp.shapes_g.length);\n    \n    //let distX;\n    //let distY;\n    //let sign;\n    //let dist=new Array(grp.shapes_g.length);\n    //let angle;\n    if(grp.line.keepDistribution){\n      for (let l=0;l<grp.shapes_g.length;l++){\n          let distX=grp.shapes_g[l].x-grp.line.x;\n          let distY=grp.shapes_g[l].y-grp.line.y;\n          //dist[l]=this.GiveSignOfDistance(grp.shapes_g[l],grp.line)*Math.sqrt((distX)**2+(distY)**2);\n          grp.shapes_g[l].distance_to_line_center=this.GiveSignOfDistance(grp.shapes_g[l],grp.line)*Math.sqrt((distX)**2+(distY)**2);\n          //last_distX[l]=distX;\n        }\n    }\n    for(let i=1;i<grp.shapes_g.length;i++){\n      \n     \n      let shape=grp.shapes_g[i];\n      //let distance=dist[i];\n      let j=i\n      while(j>0 && grp.shapes_g[j-1].distance_to_line_center>shape.distance_to_line_center){\n        grp.shapes_g[j]=grp.shapes_g[j-1];\n        //dist[j]=dist[j-1]\n        j=j-1;\n      }\n      grp.shapes_g[j]=shape;\n      //dist[j]=distance;\n    }\n   },\n   \n\n   sortAnyShapesByDistToLineCenter(shapes,line){\n    //this.updateAllPosInGrp(grp.id)\n    //let last_distX=new Array(grp.shapes_g.length);\n    \n    //let distX;\n    //let distY;\n    //let sign;\n    //let dist=new Array(grp.shapes_g.length);\n    //let angle;\n    for (let l=0;l<shapes.length;l++){\n        let distX=shapes[l].x-line.x;\n        let distY=shapes[l].y-line.y;\n        /*\n        angle=grp.shapes_g[l].rotation*(Math.PI/180);\n\n      \n      if(angle<=-Math.PI/4 || angle>=-Math.PI/2){\n        sign=-Math.sign(distY);\n      }\n      else if(angle<=-Math.PI/2 || angle>=-3*Math.PI/4){\n        sign=Math.sign(distY);\n      }\n      else if(angle<=-3*Math.PI/4 || angle>=-Math.PI){\n        sign=-Math.sign(distX);\n      }else if(angle>=3*Math.PI/4 || angle<=Math.PI){\n        sign=Math.sign(distX);\n      }else if(angle>=Math.PI/2 || angle<3*Math.PI/4){\n        sign=-Math.sign(distY);\n      } else if(angle<=Math.PI/2 || angle>Math.PI/4){\n        sign=-Math.sign(distY);\n      } else if(angle<=Math.PI/4 || angle>=0){\n        sign=Math.sign(distX);\n      }\n       console.log(sign);\n        */\n       \n        /*\n        if(Math.sin(grp.line.rotation*(Math.PI/180))==0){\n            grp.shapes_g[l].distance_to_line_center=grp.shapes_g[l].x-grp.line.x;\n        }else{\n            grp.shapes_g[l].distance_to_line_center=Math.sign(distX)*Math.sqrt((distX)**2+(distY)**2);\n          \n            if(grp.line.rotation*(Math.PI/180)<=-Math.PI/2 || grp.line.rotation*(Math.PI/180)<=Math.PI/2 &&grp.line.rotation*(Math.PI/180)>=0){\n              grp.shapes_g[l].distance_to_line_center=-grp.shapes_g[l].distance_to_line_center\n            }\n        }\n        */\n        //dist[l]=this.GiveSignOfDistance(grp.shapes_g[l],grp.line)*Math.sqrt((distX)**2+(distY)**2);\n        shapes.distance_to_line_center=this.GiveSignOfDistance(shapes,line)*Math.sqrt((distX)**2+(distY)**2);\n        /*\n        if((grp.line.rotation*(Math.PI/180)<=-Math.PI/2 || (grp.line.rotation*(Math.PI/180)<=Math.PI/2 && grp.line.rotation*(Math.PI/180)>=0)) && (Math.sign(last_distX[l])!=Math.sign(distX))){\n          grp.shapes_g[l].distance_to_line_center=-grp.shapes_g[l].distance_to_line_center\n        }\n        */\n        //last_distX[l]=distX;\n      }\n    for(let i=1;i<shapes.length;i++){\n      \n     \n      let shape=shapes[i];\n      //let distance=dist[i];\n      let j=i\n      while(j>0 && shapes[j-1].distance_to_line_center>shape.distance_to_line_center){\n        shapes[j]=shapes[j-1];\n        //dist[j]=dist[j-1]\n        j=j-1;\n      }\n      shapes[j]=shape;\n      //dist[j]=distance;\n    }\n   },\n\n  \n\n   /*\n   update the drag function of a shape which is on a line. \n   */\n   updateDragFunc(shape,line){\n          let angle=line.rotation*(Math.PI/180);\n          if (angle<=0 && angle>=-Math.PI/4){\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x +(pos.x-line.x)*Math.cos(angle),\n                y: line.y+(pos.x-line.x)*Math.sin(angle),\n              };\n            }\n          } else if (angle<-Math.PI/4 && angle>=-Math.PI/2){\n            // We prefer, in this case, moving the shape of the line regarding the y of the mouse position instead of the x.\n            // So that the user can move the shape more intuitively\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x-(pos.y-line.y)*Math.cos(angle),\n                y: line.y-(pos.y-line.y)*Math.sin(angle),\n              };\n            }\n          }\n          else if (angle<-Math.PI/2 && angle>=-3*Math.PI/4){\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x-(pos.y-line.y)*Math.cos(angle),\n                y: line.y-(pos.y-line.y)*Math.sin(angle),\n              };\n            }\n          } else if (angle<-3*Math.PI/4 && angle>=-Math.PI){\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x-(pos.x-line.x)*Math.cos(angle),\n                y: line.y-(pos.x-line.x)*Math.sin(angle),\n              };\n            }\n          }else if (angle<=Math.PI && angle>=3*Math.PI/4){\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x-(pos.x-line.x)*Math.cos(angle),\n                y: line.y-(pos.x-line.x)*Math.sin(angle),\n              };\n            }\n          } else if (angle<3*Math.PI/4 && angle>=Math.PI/2){\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x+(pos.y-line.y)*Math.cos(angle),\n                y: line.y+(pos.y-line.y)*Math.sin(angle),\n              };\n            }\n          } else if (angle<Math.PI/2 && angle>=Math.PI/4){\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x+(pos.y-line.y)*Math.cos(angle),\n                y: line.y+(pos.y-line.y)*Math.sin(angle),\n              };\n            }\n          }else if (angle<Math.PI/4 && angle>=0){\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x+(pos.x-line.x)*Math.cos(angle),\n                y: line.y+(pos.x-line.x)*Math.sin(angle),\n              };\n            }\n          }\n   },\n\n   /*\n   Update the position of a free shape when it is dragging.\n   */\n    updatePos(e){\n      const shape = this.shapes.find(i => i.id === e.target.id());\n      shape.x=e.target.x();\n      shape.y=e.target.y();\n      this.center.x=e.target.x();\n      this.center.y=e.target.y();\n\n      let pos = { x: shape.x, y: shape.y };\n      e.target.position(pos);\n      e.target.getLayer().batchDraw();\n      \n    },\n\n    /*\n    Update the positio  of shape attached to a line (from the group with id=id_grp) when it is dragging.\n     */\n    updatePosInGrp(e,id_grp){\n      let distX;\n      let distY;\n      let distance_to_line_center;\n      const grp=this.groups.find((r)=> r.id===id_grp);\n      \n      if(grp.aShapeHasBeenDetach==1){\n        grp.aShapeHasBeenDetach=0;\n        return;\n      }\n      const line=grp.line;\n      const shape = grp.shapes_g.find(i => i.id === e.target.id());\n      const shapes_g = grp.shapes_g; \n      //const lengthToDetach=10;\n      if(shape.needToBeDetach==1){\n        shape.needToBeDetach=0;\n        this.DetachShape(shape);\n        this.updateAllPosInGrp(e.target.getParent().attrs.id);\n      }\n      if(line.keepDistribution){\n        if(this.isCoordinateOnLine(e.target.x(),e.target.y(),line.id)){\n          distX=shape.x-e.target.x();\n          distY=shape.y -e.target.y();\n          let L=grp.line.points[4];\n          let nb_shapes=grp.shapes_g.length;\n          let d=(L/(nb_shapes-1))*grp.line.scaleX;\n          let dist=Math.sqrt(distX**2 +distY**2);\n          if(dist>=d){\n            shape.x=e.target.x();\n            shape.y=e.target.y();\n            this.updateOccupiedDistance(line.id)\n            shape.x=line.x+line.occupiedDistances[shapes_g.indexOf(shape)]*Math.cos(line.rotation*(Math.PI/180));\n            shape.y=line.y+line.occupiedDistances[shapes_g.indexOf(shape)]*Math.sin(line.rotation*(Math.PI/180));\n            shape.distance_to_line_center=line.occupiedDistances[shapes_g.indexOf(shape)];\n            shape.rotation=line.rotation;\n            this.updateAllPosInGrp(line.id);\n          }else{\n            shape.x=line.x+line.occupiedDistances[shapes_g.indexOf(shape)]*Math.cos(line.rotation*(Math.PI/180));\n            shape.y=line.y+line.occupiedDistances[shapes_g.indexOf(shape)]*Math.sin(line.rotation*(Math.PI/180));\n            shape.distance_to_line_center=line.occupiedDistances[shapes_g.indexOf(shape)];\n            shape.rotation=line.rotation; \n          }   \n        }else{\n          shape.x=e.target.x();\n          shape.y=e.target.y();\n        }\n        line.positionPoints[grp.shapes_g.indexOf(shape)].x=shape.x;\n        line.positionPoints[grp.shapes_g.indexOf(shape)].y=shape.y;\n        line.positionPoints[grp.shapes_g.indexOf(shape)].distance_to_line_center=shape.distance_to_line_center; \n      } else{\n        \n          line.positionPoints[grp.shapes_g.indexOf(shape)].x=shape.x;\n          line.positionPoints[grp.shapes_g.indexOf(shape)].y=shape.y;\n          shape.x=e.target.x();\n          shape.y=e.target.y();\n          \n          if(Math.sin(line.rotation*(Math.PI/180))==0){\n            distance_to_line_center=shape.x-line.x;\n          }else{\n            if(Math.sign(shape.x-line.x)!=0){\n              distance_to_line_center=Math.sign(-shape.rotation)*Math.sign(shape.x-line.x)*Math.sqrt((shape.x-line.x)**2+(shape.y-line.y)**2);\n            } else{\n             distance_to_line_center=Math.sign(-shape.rotation)*Math.sign(shape.y-line.y)*Math.sqrt((shape.x-line.x)**2+(shape.y-line.y)**2); \n            }\n          \n            if(shape.rotation*(Math.PI/180)<=-Math.PI/2 || (shape.rotation*(Math.PI/180)<=Math.PI/2 && shape.rotation*(Math.PI/180)>=0)){\n              distance_to_line_center=-distance_to_line_center\n            }\n          }\n          //shape.distance_to_line_center=distance_to_line_center;\n          //grp.line.occupiedDistances[shapes_g.indexOf(shape)]=shape.distance_to_line_center;\n        line.positionPoints[grp.shapes_g.indexOf(shape)].distance_to_line_center=shape.distance_to_line_center;\n          \n      }\n      let pos = { x: shape.x, y: shape.y };\n      this.center.x=shape.x;\n      this.center.y=shape.y;\n      e.target.position(pos);\n      e.target.getLayer().batchDraw();\n      if(!this.isCoordinateOnLine(shape.x,shape.y,line.id)){\n        shape.dragBoundFunc= dragFunc;\n        shape.isGrouped=0;\n        this.shapes.push(shape,)\n        for (let i=0;i<shapes_g.length;i++){\n          if(shapes_g[i].id==shape.id){\n            line.freeDistances.push(line.occupiedDistances[i]);\n            line.occupiedDistances.splice(i,1);\n            line.positionPoints.splice(i,1);\n            shapes_g.splice(i,1);\n            console.log(\"a shape has been removed from the line\");\n          }\n        } \n      }else{\n        if(!line.keepDistribution){\n          grp.line.occupiedDistances[shapes_g.indexOf(shape)]=distance_to_line_center;\n        }else{\n        grp.line.occupiedDistances[shapes_g.indexOf(shape)]=shape.distance_to_line_center;\n        }\n        \n      line.positionPoints[grp.shapes_g.indexOf(shape)].x=shape.x;\n      line.positionPoints[grp.shapes_g.indexOf(shape)].y=shape.y;\n      line.positionPoints[grp.shapes_g.indexOf(shape)].distance_to_line_center=shape.distance_to_line_center;\n       \n      }\n      /*\n      let coord_y1=line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x1=line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let coord_y2= line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x2=line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let a=(coord_y1-coord_y2)/(coord_x2-coord_x1);\n      let b=line.y-a*line.x;\n      let is_on_straight_line=false;\n      if(Math.abs(coord_x1-coord_x2)>=1){\n        is_on_straight_line=(Math.abs(a*shape.x+b-shape.y)<1);\n      }else{\n        is_on_straight_line=(Math.abs(shape.x-line.x)<1);\n      }\n      if(\n        !(is_on_straight_line)\n      ||((line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n        ||line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      && ((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>-Math.PI)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>-Math.PI)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>=0)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>=0)))\n      )\n      {\n        shape.dragBoundFunc= dragFunc;\n        this.shapes.push(shape,)\n        for (let i=0;i<shapes_g.length;i++){\n          if(shapes_g[i].id==shape.id){\n            line.freeDistances.push(line.occupiedDistances[i]);\n            line.occupiedDistances.splice(i,1);\n            shapes_g.splice(i,1);\n            console.log(\"a shape has been removed from the line\");\n          }\n        } \n      }else{\n        if(!line.keepDistribution){\n          grp.line.occupiedDistances[shapes_g.indexOf(shape)]=distance_to_line_center;\n        }else{\n        grp.line.occupiedDistances[shapes_g.indexOf(shape)]=shape.distance_to_line_center;\n        }\n      }\n      */\n      //this.updateOccupiedDistance(line.id);\n      \n          if(line.keepDistribution){\n            this.updateOccupiedDistance(line.id);\n          }\n          \n          this.updateAllPosInGrp(line.id);\n    },\n    \n    /*\n    Function called when the transformation of a shape with a transfomer is finished.\n    */\n    updateTransformedShape(e) {\n      \n\n      let res;\n      let shape; //Object concerned by the transformation\n      if(e.target.className==\"Line\"){\n        shape=this.groups.find(\n        (r) => r.id === this.selectedShapeId\n      ).line;\n      }else{\n        res=this.findShape(this.selectedShapeId)\n        shape=res.shape_data;\n        if(shape== undefined){\n          return;\n        }\n      }\n\n      \n      let last_shapex= shape.x;\n      let last_shapey= shape.y;\n\n      //update data of the transformed object.\n      shape.x = e.target.x();\n      shape.y = e.target.y();\n      shape.rotation = e.target.rotation();\n      let last_scaleX= shape.scaleX;\n      shape.scaleX = e.target.scaleX();\n      shape.scaleY = e.target.scaleY();\n\n      if(e.target.className==\"Line\"){\n        const grp=this.groups.find((r)=> r.id===shape.id);\n        if(shape.keepDistribution){\n          for (let i=0;i<shape.occupiedDistances.length;i++){\n            shape.occupiedDistances[i]=(shape.occupiedDistances[i]/last_scaleX)*shape.scaleX;\n          }\n          /*\n          for (let i=0;i<shape.freeDistances.length;i++){\n            shape.freeDistances[i]=(shape.freeDistances[i]/last_scaleX)*shape.scaleX;\n          }\n          */\n          \n          //this.updateOccupiedDistance(shape.id)\n          this.update();\n          this.updateGrp(e, this.selectedShapeId);\n          this.checkIfShapesOnLine(this.selectedShapeId);        \n        }else{\n          \n          \n          \n         if(last_scaleX!=shape.scaleX){\n          for(let i=0;i<grp.shapes_g.length;i++){\n          \n          //If the width of the line has been changed, we update the distance from the shape to the center of the line\n            \n              let distX=grp.shapes_g[i].x-shape.x;\n              let distY=grp.shapes_g[i].y-shape.y;\n              /*\n              if(Math.sign(grp.shapes_g[i].distance_to_line_center)==0){\n                grp.shapes_g[i].distance_to_line_center=-this.GiveSignOfDistance(grp.shapes_g[i],shape)*Math.sqrt((distX)**2 +(distY)**2);\n              \n              }else{\n                grp.shapes_g[i].distance_to_line_center=Math.sign(grp.shapes_g[i].distance_to_line_center)*Math.sqrt((distX)**2 +(distY)**2);\n              }\n              if(Math.sign((grp.shapes_g[i].x-last_shapex))!=Math.sign(distX)){\n                grp.shapes_g[i].distance_to_line_center=-grp.shapes_g[i].distance_to_line_center;\n              }\n              */\n             if(Math.sign(grp.line.occupiedDistances[i])==0){\n                //if(grp.line.rotation!=-90 && grp.line.rotation!=90){\n                  //grp.line.occupiedDistances[i]=-this.GiveSignOfDistance(grp.shapes_g[i],shape)*Math.sqrt((distX)**2 +(distY)**2);\n                //}else{\n                  grp.line.occupiedDistances[i]=this.GiveSignOfDistance(grp.shapes_g[i],shape)*Math.sqrt((distX)**2 +(distY)**2);\n                  \n                //}\n              \n              }else{\n                grp.line.occupiedDistances[i]=Math.sign(grp.line.occupiedDistances[i])*Math.sqrt((distX)**2 +(distY)**2);\n              }\n\n              \n              if(Math.sign((grp.shapes_g[i].x-last_shapex))!=Math.sign(distX) && Math.sign((grp.shapes_g[i].x-last_shapex))!=0 && grp.line.rotation!=90 && grp.line.rotation!=-90){\n                \n                grp.line.occupiedDistances[i]=-grp.line.occupiedDistances[i];\n              }\n              if(Math.sign((grp.shapes_g[i].y-last_shapey))!=Math.sign(distY) && Math.sign((grp.shapes_g[i].y-last_shapey))!=0 && (grp.line.rotation==90 || grp.line.rotation==-90)){\n                grp.line.occupiedDistances[i]=-grp.line.occupiedDistances[i];\n              }\n              //this.checkIfShapesOnLine(this.selectedShapeId);  \n            \n            //this.checkIfShapesOnLine(this.selectedShapeId);\n            //grp.line.occupiedDistances[i]=grp.shapes_g[i].distance_to_line_center;\n            \n          }\n          for (let i=0;i<shape.freeDistances.length;i++){\n            let distX=last_shapex-shape.x;\n            let distY=last_shapey-shape.y; \n            let dist=Math.sqrt(distX**2+distY**2);\n            if(shape.rotation<-90 ||shape.rotation>90){\n              shape.freeDistances[i]=shape.freeDistances[i]-Math.sign(last_shapex-shape.x)*dist;\n            } else if(shape.rotation==90 || shape.rotation==-90){\n              shape.freeDistances[i]=shape.freeDistances[i]-distY\n            } else{\n              shape.freeDistances[i]=shape.freeDistances[i]+Math.sign(last_shapex-shape.x)*dist;\n            \n            }\n          }\n         }\n          this.update();\n          this.updateGrp(e, this.selectedShapeId);\n          this.checkIfShapesOnLine(this.selectedShapeId);\n\n          // We now see if freeDistances need to be delete(so if they are bigger than the half of the stickyline);\n          \n        }\n        for(let i=0;i<grp.shapes_g.length;i++){\n            \n          this.updateDragFunc(grp.shapes_g[i],shape);\n\n        }\n      }else if(res.grp_id!='-1'){\n        //this.update();\n        //let layer=e.target.getParent().getLayer();\n        //layer.batchDraw();\n        this.updateAllPosInGrp(res.grp_id);\n        this.updateOccupiedDistance(res.grp_id);\n        e.target.x(e.target.getParent().attrs.shapes_g.find((r)=>r.id===e.target.id()).x);\n        e.target.y(e.target.getParent().attrs.shapes_g.find((r)=>r.id===e.target.id()).y);\n        this.groups.find((r)=>r.id===res.grp_id).shapes_g.find((r)=>r.id===e.target.id()).personalRotation=e.target.rotation()-e.target.getParent().attrs.line.rotation;\n        \n        \n        this.updateAllPosInGrp(res.grp_id);\n        this.checkIfShapesOnLine(res.grp_id);\n        this.updateDragFuncOfCenter();\n      \n      }\n      else{\n        this.update();\n        \n        this.updateDragFuncOfCenter();\n      }\n      this.center.x=e.target.attrs.x;\n      this.center.y=e.target.attrs.y;\n    },\n    \n    handleTransformation(e) {\n      if (e.evt==undefined) {\n        return;\n      }\n      if(this.eraseMode==1){\n        this.eraserAction(e);\n        return;\n      }\n      \n      //If we click on the stage, we have to remove the transformer from the node where it was.\n      if (e.target === e.target.getStage()) {\n        this.selectedShapeId = 'NoId';\n        this.eraseNodefromTransformer(\"lineTransformer\");\n        this.eraseNodefromTransformer(\"shapeTransformer\");\n        this.center.opacity=0;\n        return;\n      }\n\n      // If we click on a transformer, nothing happen.\n      const clickedOnTransformer = e.target.getParent().className === 'Transformer';\n      if (clickedOnTransformer) {\n        return;\n      }\n      \n      const id = e.target.id();\n      let transformer_id;\n      let shape=this.findShape(id).shape_data;\n\n      //if it is a line, we need the transformer dedicated to the line (ie transformer with id=\"lineTransformer\")\n      //if it is a classic shape, we need the transformer dedicated to the shape (ie transformer with id=\"shapeTransformer\")\n      if(e.target.attrs.id==\"center\"){\n        return;\n      }\n      if(e.target.className==\"Line\"){\n        transformer_id=\"lineTransformer\"\n        shape = this.groups.find((r) => r.id === id).line;\n        this.center.draggable=false;\n        this.selectedShapeAlignment=shape.defaultAlignment;\n        this.eraseNodefromTransformer(\"shapeTransformer\");\n      }else{\n        transformer_id=\"shapeTransformer\"\n        this.center.draggable=true;\n        this.selectedShapeAlignment=shape.centerPosition;\n        this.eraseNodefromTransformer(\"lineTransformer\");\n      }\n      \n      if (shape!=undefined) {\n        this.selectedShapeId = id;\n        this.center.opacity=1;\n        this.updateTransformer(transformer_id);\n      } else{\n        /*Only if the center is not selected.\n        When the center is dragged, this function is called.\n        But a shape is actualy selected (the one of the center).\n        */\n        this.selectedShapeId = 'NoId';\n      }\n      //this.updateTransformer(transformer_id);\n      \n      this.updateDragFuncOfCenter()\n    },\n\n    //remove node from transformer with id=transformer_id\n    eraseNodefromTransformer(transformer_id) {\n      let stage= this.$refs.stage.getStage();      \n      const transformerNode = stage.find(\"#\"+transformer_id)[0]; \n      transformerNode.nodes([]);\n    },\n\n    //Update transformer with id=transformer_id\n    //It places the transformer regarding what node is selected\n    updateTransformer(transformer_id) {\n\n      let stage= this.$refs.stage.getStage();\n      const transformerNode = stage.find(\"#\"+transformer_id)[0];\n      let selectedNode;\n      if (transformer_id==\"lineTransformer\"){\n        selectedNode = stage.children[0].getChildren().filter((r)=> r.attrs.className==\"Group\" && r.attrs.id==this.selectedShapeId)[0]\n        .getChildren().filter(r=>r.attrs.className==\"Line\" && r.attrs.id==this.selectedShapeId)[0];\n      }else{\n      selectedNode = stage.children[0].getChildren().filter((r)=>r.attrs.className!=\"Group\" && r.attrs.id==this.selectedShapeId)[0];\n\n      let isFunded=true;\n      if(selectedNode==undefined){\n        isFunded=false;\n      }\n      let i=0;\n      while(!isFunded){\n        if(i<this.groups.length){\n          selectedNode=stage.children[0].getChildren().filter((r)=>r.attrs.className==\"Group\")[i].getChildren().find((r)=>r.attrs.id==this.selectedShapeId && r.attrs.className!=\"Line\");\n        if(selectedNode==undefined){\n          isFunded=false;\n        }else{\n          isFunded=true;\n        }\n        i++;\n        }else{        \n          isFunded=true;\n        }\n      }\n      }\n      /*\n      if (transformer_id==\"lineTransformer\"){\n        selectedNode = stage.children[0].getChildren().filter((r)=> r.attrs.className==\"Group\" && r.attrs.id==this.selectedShapeId)[0]\n        .getChildren().filter(r=>r.attrs.className==\"Line\" && r.attrs.id==this.selectedShapeId)[0];\n      }\n      */\n     \n      //If the selected node has already the transformer on it, nothing happen\n      if (selectedNode === transformerNode.node()) {\n        return;\n      }\n\n      //If a node is selected\n      if (selectedNode!=undefined) {\n        //We attach the transformer to the node\n        transformerNode.nodes([selectedNode]);\n      } else {\n        //if no node is selected, we remove the transformer from its node.\n        transformerNode.nodes([]);\n      }\n      this.center.x=selectedNode.attrs.x;\n      this.center.y=selectedNode.attrs.y;\n      \n    },\n/*\n  DisplayCenterMenu(e){\n    CenterMenu.props.ConcernedShape=e.target;\n   document.getElementById(\"center_menu\").style.display=\"initial\";\n   document.getElementById(\"center_menu\").style.top=e.target.getStage().getPointerPosition().y+8+\"px\";\n  document.getElementById(\"center_menu\").style.left=e.target.getStage().getPointerPosition().x+8+\"px\";\n  },\n  */\n\n  //display context menu according to the target\n  /*\n  DisplayContextMenu(e){\n    e.evt.preventDefault()\n    if (e.target.className!=undefined && e.target.attrs.id!=\"center\"){\n      this.isStageOnlySelected=false;\n      ContextMenu.data().dM='initial';\n      this.$emit('needmenu');\n      this.needMenu=true;\n      ContextMenu.props.ConcernedShape=e.target;\n      if (e.target.attrs.className==\"Line\"){\n        this.isALineSelected=true;\n        this.isAGroupedShapeSelected=true;\n        //We precise the text which depends on the line where we clicked.\n        this.keepDistanceButtonText=e.target.attrs.keepDistanceButtonText;\n      } else if(e.target.getParent().attrs.className==\"Group\"){\n        this.isAGroupedShapeSelected=true;\n      }\n      else{\n        this.isALineSelected=false;\n        this.isAGroupedShapeSelected=false;\n      }\n      document.getElementById(\"active\").style.display=\"initial\";\n      document.getElementById(\"active\").style.top=e.target.getStage().getPointerPosition().y+8+\"px\";\n      document.getElementById(\"active\").style.left=e.target.getStage().getPointerPosition().x +8+\"px\";\n    }\n    if (e.target === e.target.getStage()) {\n      this.needMenu=true;\n      this.isALineSelected=false;\n      this.isAGroupedShapeSelected=false;\n      this.isStageOnlySelected=true;\n      document.getElementById(\"active\").style.display=\"initial\";\n      document.getElementById(\"active\").style.top=e.target.getStage().getPointerPosition().y+8+\"px\";\n      document.getElementById(\"active\").style.left=e.target.getStage().getPointerPosition().x +8+\"px\";\n    \n    }\n  },\n\n  //hide context menu\n  HideContextMenu(){\n    this.needMenu=false;\n    document.getElementById(\"active\").style.display=\"none\";\n    document.getElementById(\"center_menu\").style.display=\"none\";\n  },\n*/\n\n  \n ChangeCenter(e){\n  let res=this.findShape(this.selectedShapeId);\n  let shape=res.shape_data;\n  let threshold1;\n  let threshold2;\n  let dist=this.GiveSignOfDistanceBtwCenterAndShape(e.target.attrs,shape)*Math.sqrt((e.target.y()-(shape.y))**2+(e.target.x()-shape.x)**2)+shape.offsetY*shape.scaleY;\n  \n  //let last_offsetX=shape.offsetX;\n  let last_offsetY=shape.offsetY;\n  if(shape==undefined){\n    shape=this.groups.find((r)=>r.id==this.selectedShapeId).line;\n\n  }else{\n    \n      if(shape.className==\"Rect\") {\n        threshold1=shape.height*shape.scaleY/3;\n        threshold2=shape.height*shape.scaleY*2/3;\n        if(dist>=threshold1 && dist<=threshold2){\n          shape.offsetX=shape.width/2;\n          shape.offsetY=shape.height/2;\n          shape.centerPosition=\"Middle\";\n        }else if(dist>threshold2){\n          shape.offsetX=shape.width/2;\n          shape.offsetY=shape.height;\n          shape.centerPosition=\"Bottom\";\n        }\n        else{\n          shape.offsetX=shape.width/2;\n          shape.offsetY=0;\n          shape.centerPosition=\"Top\";\n        }\n      }\n      else if(shape.className==\"Circle\") {\n        dist=dist+shape.radius*shape.scaleY;\n        threshold1=shape.radius*shape.scaleY*2/3;\n        threshold2=shape.radius*shape.scaleY*4/3;\n        if(dist>=threshold1 && dist<=threshold2){\n          shape.offsetX=0;\n          shape.offsetY=0;\n          shape.centerPosition=\"Middle\";\n        }else if(dist>threshold2){\n          shape.offsetX=0;\n          shape.offsetY=shape.radius;\n          shape.centerPosition=\"Bottom\";\n        }else{\n          shape.offsetX=0;\n          shape.offsetY=-shape.radius;\n          shape.centerPosition=\"Top\";\n        } \n      }\n      else if(shape.className==\"Image\") {\n        threshold1=shape.image.height*shape.scaleY/3;\n        threshold2=shape.image.height*shape.scaleY*2/3;\n        if(dist>=threshold1 && dist<=threshold2){\n          shape.offsetX=shape.image.width/2;\n          shape.offsetY=shape.image.height/2;\n          shape.centerPosition=\"Middle\";\n        }else if(dist>threshold2){\n          shape.offsetX=shape.image.width/2;\n          shape.offsetY=shape.image.height;\n          shape.centerPosition=\"Bottom\";\n        }\n        else {\n          shape.offsetX=shape.image.width/2;\n          shape.offsetY=0;\n          shape.centerPosition=\"Top\";\n        }\n      }\n      else if(shape.className==\"Text\") {\n        threshold1=shape.length_y*shape.scaleY/3;\n        threshold2=shape.length_y*shape.scaleY*2/3;\n        if(dist>=threshold1 && dist<=threshold2){\n          shape.offsetX=shape.length_x/2;\n          shape.offsetY=shape.length_y/2;\n          shape.centerPosition=\"Middle\";\n        }else if(dist>threshold2){\n          shape.offsetX=shape.length_x/2;\n          shape.offsetY=shape.length_y;\n          shape.centerPosition=\"Bottom\";\n        }\n        else{\n          shape.offsetX=shape.length_x/2;\n          shape.offsetY=0;\n          shape.centerPosition=\"Top\";\n        }\n      }\n      else if(shape.className==\"Triangle\") {\n        dist=dist+shape.radius*shape.scaleY;\n        threshold1=shape.radius*shape.scaleY/2;\n        threshold2=shape.radius*shape.scaleY*5/4;\n        if(dist>=threshold1 && dist<=threshold2){\n          shape.offsetX=0;\n          shape.offsetY=0;\n        }else if(dist>threshold2){\n          shape.offsetX=0;\n          shape.offsetY=shape.radius/2\n          shape.centerPosition=\"Bottom\";\n        }\n        else{\n          shape.offsetX=0;\n          shape.offsetY=-shape.radius;\n          shape.centerPosition=\"Top\";\n        }\n      }\n      shape.y=shape.y-(last_offsetY-shape.offsetY)*shape.scaleY*Math.cos(shape.rotation*(Math.PI/180));\n      shape.x=shape.x+(last_offsetY-shape.offsetY)*shape.scaleY*Math.sin(shape.rotation*(Math.PI/180));\n      this.selectedShapeAlignment=shape.centerPosition;\n\n      if (res.grp_id!='-1'){\n        this.updateAllPosInGrp(res.grp_id);\n      }\n        \n      e.target.x(shape.x);\n      e.target.y(shape.y);\n\n     \n\n      \n  }\n  },\n  /*\n  ChangeAlignCenter(align_choice){\n    let center=CenterMenu.props.ConcernedShape;\n    let grp=this.groups.find((r)=>r.id===this.selectedShapeId);\n    let shape;\n    if(grp!=undefined){\n      for(let i=0;i<grp.shapes_g.length;i++){\n        this.ChangeCenterRegardingCommand(grp.shapes_g[i].id,align_choice)\n      }\n      center.x(grp.line.x);\n      center.y(grp.line.y);\n      if(grp.line.defaultAlignment==align_choice){\n        grp.line.defaultAlignment='' //If we select again the same alogn_choice, we deselect it, no alignement center is fixed.\n      }else{\n        grp.line.defaultAlignment=align_choice;\n      }\n      this.selectedShapeAlignment=grp.line.defaultAlignment;\n    }else{\n      shape=this.findShape(this.selectedShapeId).shape_data;\n      this.ChangeCenterRegardingCommand(shape.id,align_choice)\n      this.selectedShapeAlignment=shape.centerPosition;\n      center.x(shape.x);\n      center.y(shape.y);\n    }\n  },\n  */\n  //Allow to change the center regarding a text command (Top,Middle or Bottom)\n  ChangeCenterRegardingCommand(shape_id,command){\n    let res=this.findShape(shape_id);\n    let shape=res.shape_data;\n    let last_offsetY=shape.offsetY;\n    if(shape.className==\"Rect\" ){\n      if(command==\"Top\"){\n        shape.offsetY=0;\n        shape.offsetX=shape.width/2;\n      }\n      else if(command==\"Middle\"){\n          shape.offsetX=shape.width/2;\n          shape.offsetY=shape.height/2;\n      }else if(command==\"Bottom\"){\n            shape.offsetX=shape.width/2;\n            shape.offsetY=shape.height;\n      }\n    }\n      else if(shape.className==\"Circle\") {\n        if(command==\"Top\"){\n          shape.offsetX=0;\n          shape.offsetY=-shape.radius;\n        }else if(command==\"Middle\"){\n          shape.offsetX=0;\n          shape.offsetY=0\n        }else if(command==\"Bottom\"){\n          shape.offsetX=0;\n          shape.offsetY=shape.radius;\n        } \n      }\n      else if(shape.className==\"Image\") {\n        if(command==\"Middle\"){\n          shape.offsetX=shape.image.width/2;\n          shape.offsetY=shape.image.height/2;\n        }else if(command==\"Bottom\"){\n          shape.offsetX=shape.image.width/2;\n          shape.offsetY=shape.image.height;\n        }\n        else if (command==\"Top\"){\n          shape.offsetX=shape.image.width/2;\n          shape.offsetY=0;\n        }\n      }\n      else if(shape.className==\"Text\") {\n        if(command==\"Middle\"){\n          shape.offsetX=shape.length_x/2;\n          shape.offsetY=shape.length_y/2;\n        }else if(command==\"Bottom\"){\n          shape.offsetX=shape.length_x/2;\n          shape.offsetY=shape.length_y;\n        }\n        else if(command==\"Top\"){\n          shape.offsetX=shape.length_x/2;\n          shape.offsetY=0;\n        }\n      }\n      else if(shape.className==\"Triangle\") {\n        if(command==\"Middle\"){\n          shape.offsetX=0;\n          shape.offsetY=0;\n        }else if(command==\"Bottom\"){\n          shape.offsetX=0;\n          shape.offsetY=shape.radius/2;\n        }\n        else if(command==\"Top\"){\n          shape.offsetX=0;\n          shape.offsetY=-shape.radius;\n        }\n      }\n      shape.centerPosition=command;\n      shape.y=shape.y-(last_offsetY-shape.offsetY)*shape.scaleY*Math.cos(shape.rotation*(Math.PI/180));\n      shape.x=shape.x+(last_offsetY-shape.offsetY)*shape.scaleY*Math.sin(shape.rotation*(Math.PI/180));\n\n      if (res.grp_id!='-1'){\n        this.updateAllPosInGrp(res.grp_id);\n      }\n        \n      //center.x(shape.x);\n      //center.y(shape.y);\n  },\n  updateDragFuncOfCenter(){\n    let shape=this.findShape(this.selectedShapeId).shape_data\n    let center=this.center;\n    let angle=shape.rotation*(Math.PI/180);\n    if(angle>=-Math.PI/2 && angle<=0){\n      angle-=90*(Math.PI/180);\n    }else if(angle<-Math.PI/2){\n      angle+=(Math.PI/2);\n      angle=Math.PI+angle;\n    } else if(angle<=Math.PI && angle>0){\n      angle-=90*(Math.PI/180);\n    } \n    if (angle<=0 && angle>=-Math.PI/4){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x +(pos.x-shape.x)*Math.cos(angle),\n          y: shape.y+(pos.x-shape.x)*Math.sin(angle),\n        };\n      }\n    } else if (angle<-Math.PI/4 && angle>=-Math.PI/2){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x-(pos.y-shape.y)*Math.cos(angle),\n          y: shape.y-(pos.y-shape.y)*Math.sin(angle),\n        };\n      }\n    }\n    else if (angle<-Math.PI/2 && angle>=-3*Math.PI/4){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x-(pos.y-shape.y)*Math.cos(angle),\n          y: shape.y-(pos.y-shape.y)*Math.sin(angle),\n        };\n      }\n    } else if (angle<-3*Math.PI/4 && angle>=-Math.PI){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x-(pos.x-shape.x)*Math.cos(angle),\n          y: shape.y-(pos.x-shape.x)*Math.sin(angle),\n        };\n      }\n    }else if (angle<=Math.PI && angle>=3*Math.PI/4){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x-(pos.x-shape.x)*Math.cos(angle),\n          y: shape.y-(pos.x-shape.x)*Math.sin(angle),\n        };\n      }\n    } else if (angle<3*Math.PI/4 && angle>=Math.PI/2){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x+(pos.y-shape.y)*Math.cos(angle),\n          y: shape.y+(pos.y-shape.y)*Math.sin(angle),\n        };\n      }\n    } else if (angle<Math.PI/2 && angle>=Math.PI/4){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x+(pos.y-shape.y)*Math.cos(angle),\n          y: shape.y+(pos.y-shape.y)*Math.sin(angle),\n        };\n      }\n    }else if (angle<Math.PI/4 && angle>=0){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x+(pos.x-shape.x)*Math.cos(angle),\n          y: shape.y+(pos.x-shape.x)*Math.sin(angle),\n        };\n      }\n    }\n  },\n  MovingCenter(){\n    //let shape=this.findShape(this.selectedShapeId)\n    //console.log(e.target)\n  },\n  /*\n  //called when the \"Change Center\" button is clicked\n  ChangeCenterButtonAction(){\n      let shape= ContextMenu.props.ConcernedShape;\n      if(shape.attrs.className==\"Line\"){\n        let shapes_g=shape.getParent().attrs.shapes_g //the list of the shapes which are on the line is in the corresponding group.\n        for (let j=0;j<shapes_g.length;j++){\n          this.ChangeCenter(shapes_g[j]);\n        }\n      }else{\n        let shape_data=this.shapes.find(i => i.id ===shape.attrs.id);\n        let isFunded=true;\n        if(shape_data==undefined){\n          isFunded=false;\n        }\n        let i=0;\n        while(!isFunded){\n          if(i<this.groups.length){\n            shape_data=this.groups[i].shapes_g.find(i => i.id === shape.attrs.id);\n          if(shape_data==undefined){\n            isFunded=false;\n          }else{\n            isFunded=true;\n          }\n          i++;\n          }else{        \n            isFunded=true;\n          }\n        }\n        this.ChangeCenter(shape_data)\n      }\n    },\n    */\n    \n    //allow to copy a target\n    /*\n    Copy(){\n      ContextMenu.props.CopiedShape=ContextMenu.props.ConcernedShape;\n      ContextMenu.props.pastOneObject=true;\n    },\n    CopyAll(){\n      ContextMenu.props.CopiedShape=ContextMenu.props.ConcernedShape;\n      ContextMenu.props.pastOneObject=false;\n    },\n    Past(){   \n      //Prevent error when no shape is copied\n      if(ContextMenu.props.CopiedShape.attrs==undefined){\n        return;\n      }\n      let clone=ContextMenu.props.CopiedShape.clone({\n        id: ''+this.max_id_figures,\n      })\n      //let layer=ContextMenu.props.CopiedShape.getLayer();\n      let i= this.groups.length\n      //let new_id=i+1;\n      if(ContextMenu.props.CopiedShape.attrs.className==\"Line\"){\n        this.max_id_figures=this.max_id_figures+1;\n        if(!ContextMenu.props.pastOneObject){\n          //let i= this.groups.length;\n          //let new_id=i+1;\n        \n          clone=ContextMenu.props.CopiedShape.getParent().clone({\n            id: ''+ this.max_id_figures,\n            name: \"group\"+this.max_id_figures,\n            shapes_g:[],\n          })\n          clone.attrs.line.id=''+this.max_id_figures;\n          clone.attrs.line.x=ContextMenu.props.ConcernedShape.getStage().getPointerPosition().x;\n          clone.attrs.line.y=ContextMenu.props.ConcernedShape.getStage().getPointerPosition().y;\n          let positionPoints=Object.assign([],clone.attrs.line.positionPoints);\n            let length=positionPoints.length;\n            clone.attrs.line.positionPoints=[];\n            for(let i=0;i<length.valueOf();i++){\n              let clone_positionPoint=ContextMenu.props.CopiedShape.getParent().getChildren().find((r)=>r.attrs.id===positionPoints[i].id).clone({\n              id:'positionPoint'+clone.attrs.line.id+i,\n              });\n              clone.attrs.line.positionPoints.push(clone_positionPoint.attrs,);\n            }\n          \n          //layer= ContextMenu.props.CopiedShape.getParent().getLayer();\n          this.groups.push(clone.attrs,);\n          let shapesg=this.groups[this.groups.indexOf(this.groups.find((r)=> r.id==ContextMenu.props.CopiedShape.getParent().attrs.id))].shapes_g;\n          let shapesg_length=shapesg.length;\n          for (let j=0; j<shapesg_length;j++){\n            this.max_id_figures=this.max_id_figures + 1;\n            let clone_shape=ContextMenu.props.CopiedShape.getParent().getChildren().find((r)=>r.attrs.id===shapesg[j].id).clone({\n              id:''+this.max_id_figures,\n            });\n           // this.updateDragFunc(clone_shape,clone_line);\n            this.groups[i].shapes_g.push(clone_shape.attrs,);\n            this.updateDragFunc(this.groups[i].shapes_g[this.groups[i].shapes_g.length-1],this.groups[i].line);\n          }\n          this.updateAllPosInGrp(clone.attrs.id);\n        }else{\n          //let i= this.groups.length;\n          //let new_id=i+1;\n        \n          clone=ContextMenu.props.CopiedShape.getParent().clone({\n            id: ''+this.max_id_figures,\n            name: \"group\"+this.max_id_figures,\n            shapes_g:[],\n          })\n          clone.attrs.line.id=''+this.max_id_figures;\n          clone.attrs.line.x=ContextMenu.props.ConcernedShape.getStage().getPointerPosition().x;\n          clone.attrs.line.y=ContextMenu.props.ConcernedShape.getStage().getPointerPosition().y;\n          for(let j=0;j<clone.attrs.line.occupiedDistances.length;j++){\n            clone.attrs.line.freeDistances.push(clone.attrs.line.occupiedDistances[j],);\n          }\n          clone.attrs.line.occupiedDistances=[];\n          if(clone.attrs.line.keepDistribution!=1){\n            let positionPoints=Object.assign([],clone.attrs.line.positionPoints);\n            let length=positionPoints.length;\n            clone.attrs.line.positionPoints=[];\n            for(let i=0;i<length.valueOf();i++){\n              let clone_positionPoint=ContextMenu.props.CopiedShape.getParent().getChildren().find((r)=>r.attrs.id===positionPoints[i].id).clone({\n              id:'positionPoint'+clone.attrs.line.id+i,\n              });\n              clone.attrs.line.positionPoints.push(clone_positionPoint.attrs,);\n            }\n          }\n          //layer= ContextMenu.props.CopiedShape.getParent().getLayer();\n          this.groups.push(clone.attrs,)\n        }\n        //In order to actualize the new line (in particular to show the positionPoints):\n        this.updateAllPosInGrp(clone.attrs.id)\n      } \n      else{\n        this.max_id_figures=this.max_id_figures + 1;\n        clone=ContextMenu.props.CopiedShape.clone({\n          id: ''+this.max_id_figures,  \n          x:ContextMenu.props.ConcernedShape.getStage().getPointerPosition().x,\n          y:ContextMenu.props.ConcernedShape.getStage().getPointerPosition().y,\n        });\n        clone.attrs.dragBoundFunc=function (pos) {\n          return {\n            x: pos.x,\n            y: pos.y,\n          };\n        };\n        clone.attrs.isGrouped=0;\n        this.shapes.push(clone.attrs,); \n         \n      }\n      //layer.batchDraw(); \n      \n    },\n    //RemoveShape(shape)\n    Remove(shape){\n      //let shape=ContextMenu.props.ConcernedShape;\n      if(shape.attrs.className==\"Line\"){\n        let grp=this.groups.find((r)=>r.id===shape.attrs.id);\n        const length=grp.shapes_g.length;\n        for(let i=0;i<length;i++){\n          grp.shapes_g[i].dragBoundFunc= dragFunc;\n          grp.shapes_g[i].isGrouped=0;\n          this.shapes.push(grp.shapes_g[i],);\n        }\n        this.eraseNodefromTransformer(\"lineTransformer\");\n        this.groups.splice(this.groups.indexOf(grp),1);\n        shape.getParent().destroy();\n\n        //We give to the circle (representing center of shapes) a default position\n        if(this.groups[0]!=undefined){\n          this.center.x=this.groups[0].line.x;\n          this.center.y=this.groups[0].line.y;\n        } else if(this.shapes[0]!=undefined){\n          this.center.x=this.shapes[0].x;\n          this.center.y=this.shapes[0].y;\n        }\n        this.center.opacity=0;\n        \n      }else if(shape.attrs.className==\"positionPoint\"){\n        let line=shape.getParent().attrs.line;\n        let target_positionPoint=line.positionPoints.find((r)=>r.id===shape.attrs.id);\n        let index=line.freeDistances.indexOf(shape.attrs.distance_to_line_center);\n        console.log(line.positionPoints);\n        if(line.keepDistribution!=1 && index!=-1){\n          line.freeDistances.splice(index,1);\n          line.positionPoints.splice(line.positionPoints.indexOf(target_positionPoint),1)\n        }\n      }\n      else{\n        let res=this.findShape(shape.attrs.id)\n        let shape_data=res.shape_data;\n        let grp_id=res.grp_id;\n        if(shape_data!=undefined){\n        if(grp_id!='-1'){\n        //let shape_data=this.shapes.find(i => i.id ===shape.attrs.id);\n        let grp=this.groups.find((r)=>r.id===grp_id);\n          grp.line.freeDistances.push(grp.line.occupiedDistances[grp.shapes_g.indexOf(shape_data)],)\n          grp.line.occupiedDistances.splice(grp.shapes_g.indexOf(shape_data),1)\n          \n          grp.shapes_g.splice(grp.shapes_g.indexOf(shape_data),1);\n          this.updateOccupiedDistance(grp.id);\n          \n          this.updateAllPosInGrp(grp.id);\n          \n         console.log(grp.line.positionPoints)\n      \n        } else{\n          this.eraseNodefromTransformer(\"shapeTransformer\");\n          this.shapes.splice(this.shapes.indexOf(shape_data),1);\n          //We give to the circle (representing center of shapes) a default position\n          if(this.groups[0]!=undefined){\n            this.center.x=this.groups[0].line.x;\n            this.center.y=this.groups[0].line.y;\n          } else if(this.shapes[0]!=undefined){\n            this.center.x=this.shapes[0].x;\n            this.center.y=this.shapes[0].y;\n          }\n          this.center.opacity=0;\n        }\n        shape.destroy();\n        }\n      }\n    },\n\n    RemoveAll(){\n      let shape=ContextMenu.props.ConcernedShape;\n      if(shape.className==\"Line\"){\n        let grp=this.groups.find((r)=>r.id===shape.attrs.id);\n        while(grp.shapes_g.length!=0){\n          grp.shapes_g[0].dragBoundFunc= dragFunc;\n          grp.shapes_g.splice(0,1);\n        }\n        this.eraseNodefromTransformer(\"lineTransformer\");\n        this.groups.splice(this.groups.indexOf(grp),1);\n        shape.getParent().destroy();\n\n        //We give to the circle (representing center of shapes) a default position\n        if(this.groups[0]!=undefined){\n          this.center.x=this.groups[0].line.x;\n          this.center.y=this.groups[0].line.y;\n        } else if(this.shapes[0]!=undefined){\n          this.center.x=this.shapes[0].x;\n          this.center.y=this.shapes[0].y;\n        }\n        \n      }else{\n        return;\n      }\n    },\n    */\n\n    findShape(id){\n      let shape_data=this.shapes.find(i => i.id ===id);\n      let grp_id='-1'; // return grp_id=-1 if the shape doesn't belong to attached group.\n      let isFunded=true;\n      if(shape_data==undefined){\n        isFunded=false;\n      }\n      let i=0;\n      while(!isFunded){\n        if(i<this.groups.length){\n          shape_data=this.groups[i].shapes_g.find(i => i.id === id);\n        if(shape_data==undefined){\n          isFunded=false;\n        }else{\n          grp_id=this.groups[i].id; \n          isFunded=true;\n        }\n        i++;\n        }else{        \n          isFunded=true;\n        }\n      }\n      return {shape_data, grp_id}\n    },\n\n    //detach a shape from its line.\n     DetachShape(shape,target_x,target_y){\n      \n      \n      const added_distance=this.lengthToCapture+5;\n      let grp=this.groups.find((r)=>r.shapes_g.indexOf(shape)!=-1);\n      let i=grp.shapes_g.indexOf(shape);\n      \n      shape.dragBoundFunc= dragFunc;\n\n      let coord_y1=grp.line.y-grp.line.points[4]*(1/2)*grp.line.scaleX*Math.sin(grp.line.rotation*(Math.PI/180));\n      let coord_x2=grp.line.x+grp.line.points[4]*(1/2)*grp.line.scaleX*Math.cos(grp.line.rotation*(Math.PI/180));\n      let coord_y2= grp.line.y+grp.line.points[4]*(1/2)*grp.line.scaleX*Math.sin(grp.line.rotation*(Math.PI/180));\n      let coord_x1=grp.line.x-grp.line.points[4]*(1/2)*grp.line.scaleX*Math.cos(grp.line.rotation*(Math.PI/180));\n      let a=(coord_y2-coord_y1)/(coord_x2-coord_x1);\n      //let b=grp.line.y-a*grp.line.x;\n      let b=shape.x*(1/a)+shape.y;\n      if (grp.line.rotation<0 && grp.line.rotation>-45){\n        \n        shape.x=shape.x+Math.sign(shape.y-target_y)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } else if (grp.line.rotation<=-45 && grp.line.rotation>-90){\n        \n        shape.x=shape.x+Math.sign(shape.x-target_x)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      }\n      \n      else if(grp.line.rotation<-90 && grp.line.rotation>-135){\n        shape.x=shape.x+Math.sign(shape.x-target_x)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } \n      else if(grp.line.rotation<=-135 && grp.line.rotation>-180){\n        shape.x=shape.x-Math.sign(shape.y-target_y)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } \n      \n      else if( grp.line.rotation>135 && grp.line.rotation<180){\n        \n        shape.x=shape.x-Math.sign(shape.y-target_y)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } else if( grp.line.rotation>90 && grp.line.rotation<=135){\n        \n        shape.x=shape.x-Math.sign(shape.x-target_x)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } else if( grp.line.rotation>45 && grp.line.rotation<=90){\n        \n        shape.x=shape.x-Math.sign(shape.x-target_x)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } else if( grp.line.rotation>0 && grp.line.rotation<=45){\n        \n        shape.x=shape.x+Math.sign(shape.y-target_y)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } \n      else if(grp.line.rotation==-90){\n        shape.x=shape.x-Math.sign(shape.x-target_x)*added_distance\n      } else if(grp.line.rotation==90){\n        shape.x=shape.x+Math.sign(shape.x-target_x)*added_distance\n      } else if(grp.line.rotation==180 || grp.line.rotation==-180){\n        shape.y=shape.y-Math.sign(shape.y-target_y)*added_distance\n      } else if(grp.line.rotation==0){\n        shape.y=shape.y-Math.sign(shape.y-target_y)*added_distance\n      } \n      //shape.rotation=shape.rotation+shape.personalRotation;\n      shape.isGrouped=0;\n      this.shapes.push(shape,)\n      this.center.x=shape.x;\n      this.center.y=shape.y;\n      grp.line.freeDistances.push(grp.line.occupiedDistances[i]);\n      grp.line.occupiedDistances.splice(i,1);\n      grp.shapes_g.splice(i,1);\n      grp.line.positionPoints.splice(i,1)\n      \n      this.updateOccupiedDistance(grp.id)\n      this.updateAllPosInGrp(grp.id)\n      this.updateNaration(grp)\n      this.eraseNodefromTransformer(\"shapeTransformer\");\n    \n    },\n    /*\n    DetachShape(shape){\n      \n      \n      const added_distance=this.lengthToCapture+5;\n      let grp=this.groups.find((r)=>r.shapes_g.indexOf(shape)!=-1);\n      let i=grp.shapes_g.indexOf(shape);\n      \n      shape.dragBoundFunc= dragFunc;\n\n      let coord_y1=grp.line.y-grp.line.points[4]*(1/2)*grp.line.scaleX*Math.sin(grp.line.rotation*(Math.PI/180));\n      let coord_x2=grp.line.x+grp.line.points[4]*(1/2)*grp.line.scaleX*Math.cos(grp.line.rotation*(Math.PI/180));\n      let coord_y2= grp.line.y+grp.line.points[4]*(1/2)*grp.line.scaleX*Math.sin(grp.line.rotation*(Math.PI/180));\n      let coord_x1=grp.line.x-grp.line.points[4]*(1/2)*grp.line.scaleX*Math.cos(grp.line.rotation*(Math.PI/180));\n      let a=(coord_y2-coord_y1)/(coord_x2-coord_x1);\n      //let b=grp.line.y-a*grp.line.x;\n      let b=shape.x*(1/a)+shape.y;\n      if (grp.line.rotation<0 && grp.line.rotation>-90){\n        \n        shape.x=shape.x-added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } else if(grp.line.rotation<-90){\n        shape.x=shape.x-added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } else if( grp.line.rotation>0 && grp.line.rotation<180){\n        \n        shape.x=shape.x+added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } \n      else if(grp.line.rotation==-90){\n        shape.x=shape.x+added_distance\n      } else if(grp.line.rotation==90){\n        shape.x=shape.x-added_distance\n      } else if(grp.line.rotation==180 || grp.line.rotation==-180){\n        shape.y=shape.y-added_distance\n      } else if(grp.line.rotation==0){\n        shape.y=shape.y+added_distance\n      } \n      //shape.rotation=shape.rotation+shape.personalRotation;\n      shape.isGrouped=0;\n      this.shapes.push(shape,)\n      this.center.x=shape.x;\n      this.center.y=shape.y;\n      grp.line.freeDistances.push(grp.line.occupiedDistances[i]);\n      grp.line.occupiedDistances.splice(i,1);\n      grp.shapes_g.splice(i,1);\n      grp.line.positionPoints.splice(i,1)\n      \n      this.updateOccupiedDistance(grp.id)\n      this.updateAllPosInGrp(grp.id)\n      this.updateNaration(grp);\n    \n    },\n    */\n    /*\n\n    //called when the button \"Detach Shape\" is clicked\n    DetachShapeButtonAction(){\n      let shape= ContextMenu.props.ConcernedShape;\n      if(shape.attrs.className==\"Line\"){\n        let shapes_g=shape.getParent().attrs.shapes_g;\n        while(shapes_g.length!=0){\n          this.DetachShape(shapes_g[0]);\n        }\n      }else{\n        let shape_data=this.shapes.find(i => i.id ===shape.attrs.id);\n        let isFunded=true;\n        if(shape_data==undefined){\n          isFunded=false;\n        }\n        let i=0;\n        while(!isFunded){\n          if(i<this.groups.length){\n            shape_data=this.groups[i].shapes_g.find(i => i.id === shape.attrs.id);\n          if(shape_data==undefined){\n            isFunded=false;\n          }else{\n            isFunded=true;\n          }\n          i++;\n          }else{        \n            isFunded=true;\n          }\n        }\n        this.DetachShape(shape_data)\n      }\n    },\n\n    //called when the button \"keep/liberate distribution\" is clicked.\n    KeepDistribution(){\n      let grp=this.groups.find(i => i.id === ContextMenu.props.ConcernedShape.attrs.id);\n      let line=grp.line;\n      if(line==undefined){\n        return;\n      }else{\n        if(line.keepDistribution){\n          line.keepDistribution=false;\n          for (let i=0;i<grp.shapes_g.length;i++){\n            grp.shapes_g[i].distance_to_line_center=line.occupiedDistances[i]\n          }\n          line.freeDistances=[];\n\n          line.stroke='blue'\n          grp.line.keepDistanceButtonText=\"Keep Distribution\";\n          //ContextMenu.props.ConcernedShape.attrs.keepDistanceButtonText=\"Keep Distribution\";\n        }else{\n          line.keepDistribution=true;\n          for (let i=0;i<grp.shapes_g.length;i++){\n            line.occupiedDistances[i]=grp.shapes_g[i].distance_to_line_center;\n          }\n          line.stroke='black'\n          grp.line.keepDistanceButtonText=\"Liberate Distribution\";\n          //ContextMenu.props.ConcernedShape.attrs.keepDistanceButtonText=\"Liberate Distribution\";\n          this.updateOccupiedDistance(line.id);\n          this.updateAllPosInGrp(line.id);\n        }\n      }\n    },\n    */\n    createNewShape(shape){\n      if(shape.attrs.className==\"Line\"){\n        \n        this.max_id_figures=this.max_id_figures+1;\n\n          let clone=shape.getParent().clone({\n            id: ''+this.max_id_figures,\n            name: \"group\"+this.max_id_figures,\n            shapes_g:[],\n          })\n          clone.attrs.line.id=''+this.max_id_figures;\n          clone.attrs.line.x=shape.getStage().getPointerPosition().x;\n          clone.attrs.line.y=shape.getStage().getPointerPosition().y;\n          clone.attrs.line.draggable=true;\n          this.groups.push(clone.attrs,)\n          \n        \n      }else{\n        \n        this.max_id_figures=this.max_id_figures+1\n        let clone=shape.clone({\n          id: ''+this.max_id_figures,\n          draggable: true,\n        })\n        clone.attrs.isGrouped=0;\n        this.shapes.push(clone.attrs,);\n      }\n      \n\n    },\n    \n  \n  eraserAction(e){\n    this.Remove(e.target);\n    \n  },\n  unshowSelectedShape(e){\n    if(e.target.attrs.className==\"Line\" && this.eraseMode==0){\n      e.target.opacity(0.5)\n    }\n    else if(e.target.attrs.className==\"Line\" && this.eraseMode==1){\n      if(e.target.attrs.keepDistribution==1){\n        e.target.stroke(\"rgb(48,48,48)\")\n      }else{\n        e.target.stroke(\"blue\")\n      }\n    }\n    else if(e.target.attrs.className==\"positionPoint\" && this.eraseMode==1){\n      if(e.target.getParent().attrs.line.keepDistribution!=1){\n        e.target.strokeWidth(0)\n      }\n    }\n    else if(this.eraseMode==1){\n      e.target.strokeWidth(0)\n    }\n  },\n  showSelectedShape(e){\n    if(e.target.attrs.className==\"Line\" && this.eraseMode==0){\n      e.target.opacity(1)\n    }\n    else if(e.target.attrs.className==\"Line\" && this.eraseMode==1){\n      e.target.stroke('rgb(200, 59, 218)')\n    }\n    else if(e.target.attrs.className==\"positionPoint\" && this.eraseMode==1){\n      let line=e.target.getParent().attrs.line;\n      if(line.freeDistances.indexOf(e.target.attrs.distance_to_line_center)!=-1){\n        if(line.keepDistribution!=1){\n          e.target.stroke('rgb(200, 59, 218)')\n          e.target.strokeWidth(3)\n        }\n      }\n    }\n    else if(this.eraseMode==1){\n      e.target.stroke('rgb(200, 59, 218)')\n      e.target.strokeWidth(3)\n    }\n    /*\n    let shape=e.target;\n    if(this.eraseMode==1){\n    let shape_data=this.shapes.find(i => i.id ===shape.attrs.id);\n    let isFunded=true;\n    if(shape_data==undefined){\n      isFunded=false;\n      let i=0;\n      while(!isFunded){\n        if(i<this.groups.length){\n          shape_data=this.groups[i].shapes_g.find(i => i.id === shape.attrs.id);\n        if(shape_data==undefined){\n          isFunded=false;\n          i++;\n        }else{\n          isFunded=true;\n        }\n        }else{        \n          isFunded=true;\n        }\n      }\n    }\n    if (shape_data!=undefined){\n      shape_data.opacity=0.3\n    }\n    */\n\n  },\n  editText(e){\n    //let valuey=document.getElementById(\"stage\").style.top+e.target.y()\n    //let valuex=document.getElementById(\"stage\").style.left+e.target.x()\n    let stageBox=e.target.getStage().attrs.container.getBoundingClientRect();\n    document.getElementById(\"input1\").style.top=stageBox.y+e.target.getAbsolutePosition().y-document.getElementById(\"input1\").size*2.5+'px';\n    document.getElementById(\"input1\").style.left=stageBox.x+e.target.getAbsolutePosition().x-document.getElementById(\"input1\").size*5+'px';\n    document.getElementById(\"input1\").style.display=\"initial\"\n    this.editedText=e.target\n  },\n  updateText(e){\n    let shape=this.shapes.find(i => i.id ===this.editedText.attrs.id);\n    let isFunded=true;\n    if(shape==undefined){\n      isFunded=false;\n    }\n    let i=0;\n    while(!isFunded){\n      if(i<this.groups.length){\n        shape=this.groups[i].shapes_g.find(i => i.id === this.editedText.attrs.id);\n      if(shape==undefined){\n        isFunded=false;\n      }else{\n        isFunded=true;\n      }\n      i++;\n      }else{        \n        isFunded=true;\n      }\n    }\n    if(shape!=undefined){\n    let last_width;\n    let last_height;\n    let diff_width;\n    let diff_height;\n\n    last_width=this.editedText.width();\n    last_height=this.editedText.height();\n\n    shape.text=e.target.value;\n\n    this.editedText.text(e.target.value);\n    diff_width=this.editedText.width()-last_width;\n    diff_height=this.editedText.height()-last_height;\n\n    \n    shape.offsetX=shape.offsetX+diff_width/2\n    shape.offsetY=shape.offsetY+diff_height/2\n    shape.length_x=this.editedText.width()\n    shape.length_y=this.editedText.height()\n    document.getElementById(\"input1\").style.display=\"none\"\n    }\n\n  },\n  updateNaration(grp){\n    let text=\"<strong></strong><br>\"\n    text=text+\"- <mark class='red'> StickyLine</mark><br>\";\n    text=text+\"Relation: <i>alignement with</i>:\";\n    for(let j=0;j<grp.shapes_g.length;j++){\n      text=text+\"<br>\"+\"- \"+grp.shapes_g[j].className\n    }\n    this.$emit('explain',{origin:\"Instrument - Polymorphism<br> <mark class='red'> The Stickyline applies alignment to various objects. </mark>\",text:text});\n  }\n},\n};\n\n</script>\n<style>\n#playground{\n  cursor: default\n}\n#active{\n  position: absolute;\n  display: none;\n  top: 0px;\n  left: 0px;\n  width: 60px;\n  background-color: white;\n  box-shadow: 0 0 5px grey;\n  border-radius: 3px;\n}\n#center_menu{\n  position: absolute;\n  display: none;\n  top: 0px;\n  left: 0px;\n  width: 60px;\n  background-color: white;\n  box-shadow: 0 0 5px grey;\n  border-radius: 3px;\n}\ninput1{\n  position:absolute;\n  display: none;\n  z-index:2;\n  top:0px;\n  left:0px; \n}\n</style> ","import { render } from \"./PolymorphismDemo.vue?vue&type=template&id=73ad4d9a\"\nimport script from \"./PolymorphismDemo.vue?vue&type=script&lang=js\"\nexport * from \"./PolymorphismDemo.vue?vue&type=script&lang=js\"\n\nimport \"./PolymorphismDemo.vue?vue&type=style&index=0&id=73ad4d9a&lang=css\"\n\nimport exportComponent from \"/Users/junhangyu/Desktop/PE code/github/teachingApp/node_modules/vue-loader/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render]])\n\nexport default __exports__","<template>\n\n<div @click=\"HideContextMenu\" id=\"playground\"\n@mousedown=\"updateNaration(this.groups[0])\">\n<!--\n  <ToolBar :height=\"100\" :width=\"400\"\n  @need_new_shape=\"createNewShape\" @eraser_is_selected=\"switchEraseMode\"></ToolBar>\n  -->\n  <v-stage\n    ref=\"stage\"\n    id=\"stage\"\n    :config=\"stageSize\"\n    @dragmove=\"update\"\n    @mousedown=\"handleTransformation\"\n    @touchstart=\"handleTransformation\"\n    @fusion=\"makeGroup\"\n    @contextMenu=\"DisplayContextMenu\"\n  >\n    <v-layer ref=\"layer\">\n      <!--\n        see if a group should contain more than one line\n      -->\n      <!--\n      <v-circle :key=\"center.id\" :config=\"center\"/>\n      -->\n      <v-group ref=\"groups\" v-for=\"step in groups\" :key=\"step.id\" :config=\"step\">\n      \n      \n      \n        <v-rect\n        v-for=\"item in step.shapes_g.filter(i=>i.className=='Rect')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        \n       \n        @transformend=\"updateTransformedShape\"\n        @dragend= \"updatePosInGrp($event,step.id) \"\n        @dragmove=\"CheckIfNeedToDetach\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n      />\n      <v-circle\n        v-for=\"item in step.shapes_g.filter(i=>i.className=='Circle')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragend=\"updatePosInGrp($event,step.id)\"\n        @dragmove=\"CheckIfNeedToDetach\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n      />\n      \n      <v-image\n        v-for=\"item in step.shapes_g.filter(i=>i.className=='Image')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragend=\"updatePosInGrp($event,step.id)\"\n        @dragmove=\"CheckIfNeedToDetach\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n      />\n      <v-text\n        v-for=\"item in step.shapes_g.filter(i=>i.className=='Text')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragend=\"updatePosInGrp($event,step.id)\"\n        @dragmove=\"CheckIfNeedToDetach\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n\n        @dblclick=\"editText\"\n        />\n        <v-regular-polygon\n        v-for=\"item in step.shapes_g.filter(i=>i.className=='Triangle')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragend=\"updatePosInGrp($event,step.id)\"\n        @dragmove=\"CheckIfNeedToDetach\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n      />\n        <v-line \n        :key=\"step.line.id\"\n        :config=\"step.line\"\n        @transformend=\"updateTransformedShape\"\n        @dragmove=\"updateGrp($event,step.id)\"\n        @mouseout=\"unshowSelectedShape\"\n        @mouseenter=\"showSelectedShape\"\n        />\n    <v-circle\n        v-for=\"item in step.line.positionPoints\"\n        :key=\"item.id\"\n        :config=\"item\"\n        \n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n      />\n      </v-group>\n      <v-rect\n        v-for=\"item in shapes.filter(i=>i.className=='Rect')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragmove=\"updatePos\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n        \n      />\n      \n      <v-circle\n        v-for=\"item in shapes.filter(i=>i.className=='Circle')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragmove=\"updatePos\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n        \n      />\n      \n      <v-image\n        v-for=\"item in shapes.filter(i=>i.className=='Image')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragmove=\"updatePos\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n        />\n     \n      <v-text\n        v-for=\"item in shapes.filter(i=>i.className=='Text')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragmove=\"updatePos\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n        \n        @dblclick=\"editText\"\n        /> \n      \n      <v-regular-polygon\n        v-for=\"item in shapes.filter(i=>i.className=='Triangle')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragmove=\"updatePos\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n        />\n      \n      \n      <v-transformer  v-for=\"item in transformers\" :key=\"item.id\" :config=\"item\"/>\n      <v-circle :key=\"center.id\" :config=\"center\"\n      @dragend=\"ChangeCenter\"\n      @click=\"DisplayCenterMenu\"/>\n    </v-layer>\n    \n  </v-stage>\n  \n  <!--\n  <div id=\"active\">\n  <ContextMenu :menu-of-stage=\"isStageOnlySelected\" :menu-of-line=isALineSelected :menu-of-grouped-shape=isAGroupedShapeSelected :keep-distance-button-text=\"this.keepDistanceButtonText\" \n  @changecenter-button=\"ChangeCenterButtonAction\" @detachshape-button=\"DetachShapeButtonAction\" @keepdistance-button=\"KeepDistribution\"\n  @copy-button=\"Copy\" @copy-all-button=\"CopyAll\" @past-button=\"Past\" @remove-button=\"Remove\" @remove-all-button=\"RemoveAll\"></ContextMenu>\n  </div>\n  <div id=\"center_menu\">\n  <CenterMenu :defaultAlignment=\"this.selectedShapeAlignment\" @center-button=\"ChangeAlignCenter\"></CenterMenu>\n  </div>\n  -->\n  \n  <input type=\"text\" id=\"input2\" \n        size=\"10\" value=\"the logo\"\n       @keyup.enter=\"updateText\"\n  >\n  </div>\n</template>\n\n<script>\n\n//import ContextMenu from \"./ContextMenu.vue\"\n//import CenterMenu from \"./CenterMenu.vue\"\n//import ToolBar from \"./ToolBar.vue\";\n\nconst dragFunc=function (pos) {\n  let width=this.getStage().width();\n  let height=this.getStage().height();\n  let strokeSize=10\n    if(pos.x>width-strokeSize && pos.y>height-strokeSize){\n      return{\n        x: width-strokeSize,\n        y: height-strokeSize,\n      }\n    } else if(pos.x>width-strokeSize && pos.y<strokeSize){\n      return{\n        x: width-strokeSize,\n        y: strokeSize,\n      }\n    } else if(pos.y>height-strokeSize && pos.x<strokeSize){\n      return{\n        x: strokeSize,\n        y: height-strokeSize,\n      }\n    } else if(pos.x<strokeSize && pos.y<strokeSize){\n      return{\n        x: strokeSize,\n        y: strokeSize,\n      }\n    } else if(pos.x<strokeSize){\n      return{\n        x: strokeSize,\n        y: pos.y,\n      }\n    }else if(pos.y<strokeSize){\n      return{\n        x: pos.x,\n        y: strokeSize,\n      }\n    }else if(pos.x>width-strokeSize){\n      return{\n        x: width-strokeSize,\n        y: pos.y,\n      }\n    }else if(pos.y>height-strokeSize){\n      return{\n        x: pos.x,\n        y: height-strokeSize,\n      }\n    } else{\n      return {\n        x: pos.x,\n        y: pos.y,\n      };\n    }\n};\n\nexport default {\n  props:{\n    width:{\n      type: Number,\n      default:window.innerWidth,\n    },\n    height:{\n      type: Number,\n      default:window.innerHeight,\n    }\n  },\n  components:{\n    //ContextMenu,\n    //CenterMenu,\n    //ToolBar,\n},\n  data() {\n    return {\n      stageSize: {\n        width: this.width,\n        height: this.height,\n      },\n      lengthToCapture:10,\n      lengthToDetach:15,\n      editedText:null,\n\n      eraseMode:0,\n\n      selectedShapeAlignment:'',\n      \n      needMenu: 'initial', //say if the context menu has to be \"active\" or not.\n      isALineSelected:false, \n      isAGroupedShapeSelected:false,\n      isStageOnlySelected: false,\n      //dragItemId: null, //id of the item which is dragging.\n      //text which will appear on the button corresponding to the management of the distribution\n      keepDistanceButtonText:\"Liberate Distribution\",\n      max_id_figures: 6, //max among id of shapes and line since the canvas exist (line excluded) \n      //max_id_lines: 2, //max among id of lines since the canvas exist (line excluded) \n      //groups of shapes (ie a line with shapes on it)\n      groups:[{\n        //rotation: 20,\n        name: \"group\",\n        className: \"Group\",\n        id: '6',\n        x:0,\n        y:0,\n        offsetX:0,\n        offsetY:0,\n        rotation: 0,\n        draggable: false,\n        shapes_g:[], //list of shapes that are on the line\n        //the line of the group:\n        aShapeHasBeenDetach:0,\n        line:{\n          x:150,\n          y:250,\n          points: [0, 0, 0, 0, 200, 0],\n          positionPoints:[],\n          strokeWidth: 10,\n          rotation: 0,\n          tension:0,\n          closed: true,\n          draggable: true,\n          scaleX:1,\n          scaleY:1,\n          opacity:0.5,\n          offset:{\n            x:100,\n            y:0,\n          },\n          name: \"ligne\",\n          className: \"Line\",\n          stroke: 'rgb(48,48,48)',\n          id:'6',\n          //distShapesToCenter:[],\n          keepDistribution: true, //say of we keep the distribution on the line or not\n          freeDistances:[], // distance that can be taken by other shapes (if we keep distribution on the line).\n          occupiedDistances:[], //distance already \"taken\" by shapes on the line.       \n          //text which will appear on the button corresponding to the management of the distribution:\n          keepDistanceButtonText:\"Liberate Distribution\",\n          //function which determine how the line can be dragged:\n          defaultAlignment:\"Bottom\",\n          dragBoundFunc: dragFunc,\n        },\n      },\n      /*{\n        name: \"group2\",\n        className: \"Group\",\n        id: '7',\n        x:0,\n        y:0,\n        offsetX:0,\n        offsetY:0,\n        rotation: 0,\n        draggable: false,\n        shapes_g:[],\n        line:{\n        x:500,\n        y:300,\n        points: [0, 0, 0, 0, 300, 0],\n        positionPoints:[],\n        strokeWidth: 10,\n        rotation: 0,\n        tension:0,\n        closed: true,\n        draggable: true,\n        scaleX:1,\n        scaleY:1,\n        opacity:0.5,\n        offset:{\n          x:150,\n          y:0,\n        },\n        //draggable:true,\n        name: \"ligne\",\n        className: \"Line\",\n        stroke: 'black',\n        id:'7',\n        distShapesToCenter:[],\n        keepDistribution: true,\n        freeDistances:[],\n        occupiedDistances:[],\n        keepDistanceButtonText:\"Liberate Distribution\",\n        defaultAlignment:\"Middle\",\n        dragBoundFunc: dragFunc,\n      },\n      \n      }*/\n      ],\n      transformers:[\n        {\n          id: 'lineTransformer',\n          enabledAnchors: ['middle-left', 'middle-right'],\n          rotateEnabled:false,\n          flipEnabled: false, // in order to not have a rotation of the transformer which lead to problem related to shapes position on a line\n          nodes: [],\n\n        },\n        {\n          id: 'shapeTransformer',\n          nodes: [],\n        }\n      ],\n      shapes: [\n        /*\n        {\n          rotation: 0,\n          id: '1',\n          x: 100,\n          y: 10,\n          width: 130,\n          height: 100,\n          scaleX: 1,\n          scaleY: 1,\n          strokeWidth: 0,\n          stroke: 'black',\n          fill: 'red',\n          name: 'rect1',\n          draggable: true,\n          className:\"Rect\",\n          isGrouped: 0, //if =0 the shape is not attached to a stickyline. if=1, it does.\n          offsetX:130/2,\n          offsetY:0,\n          personalRotation:0, \n          centerPosition:'Top',\n          dragBoundFunc: dragFunc\n          \n        },\n        */\n        /*\n        {\n          rotation: 0,\n          id:'2',\n          x: 200,\n          y: 260,\n          width: 100,\n          height: 100,\n          scaleX: 1,\n          scaleY: 1,\n          strokeWidth: 0,\n          stroke: 'black',\n          fill: 'green',\n          name: 'rect2',\n          draggable: true,\n          className:\"Rect\",\n          isGrouped: 0,\n          dragBoundFunc: dragFunc,\n          offsetX: 100/2,\n          offsetY: 100,\n          personalRotation:0, \n          centerPosition: 'Bottom',\n        },\n        */\n        /*\n        {\n        rotation:0,\n        x: 100,\n        y: 150,\n        scaleX:1,\n        scaleY:1,\n        offsetX: 0,\n        offsetY: 50,\n        radius: 50,\n        fill: 'orange',\n        strokeWidth: 0,\n        stroke: 'black',\n        draggable:true,\n        isGrouped: 0,\n        className:\"Circle\",\n        personalRotation:0, \n        id:'3',\n        dragBoundFunc: dragFunc,\n        centerPosition:'Bottom',\n      },\n      */\n      \n        {\n            text: 'the logo',\n            rotation: 0,\n            x: 150,\n            y: 190,           \n            scaleX:1,\n            scaleY:1,\n            offsetY:0,\n            offsetX: 36,\n            length_x:72,\n            length_y:30,\n            draggable: true,\n            isGrouped: 0,\n            className:\"Text\",    \n            fontSize: 30,\n            fontFamily: 'Calibri',\n          personalRotation:0,\n            id:'4',\n            dragBoundFunc:dragFunc,\n            centerPosition:'Top',\n        },\n        \n        {\n            rotation: 0,\n            x: 50,\n            y: 100,           \n            scaleX:0.66,\n            scaleY:0.66,\n            offsetY:0,\n            offsetX:0,\n            //width:72,\n            //height:30,\n            image: null,\n            draggable: true,\n            isGrouped: 0,\n            className:\"Image\", \n               \n            fontSize: 30,\n          personalRotation:0, \n            id:'5',\n            dragBoundFunc:dragFunc,\n            centerPosition:'Bottom',\n        },\n        \n        \n         {\n          rotation: 0,\n          id:'8',\n          x: 250,\n          y: 100,\n          sides:3,\n          radius:45,\n          width: 90,\n          height: 90,\n          scaleX: 1,\n          scaleY: 1,\n          strokeWidth: 0,\n          stroke: 'black',\n          fill: 'purple',\n          name: 'triangle1',\n          draggable: true,\n          className:\"Triangle\",\n          isGrouped: 0,\n          dragBoundFunc: dragFunc,\n          offsetX: 0,\n          offsetY: 22.5,\n          personalRotation:0, \n          centerPosition:'Bottom',\n        },\n      ],\n      center:{\n        x: 300,\n        y: 500,\n        scaleX:1,\n        scaleY:1,\n        offsetX: 0,\n        offsetY: 0,\n        radius: 4,\n        fill: 'black',\n        opacity:1,\n        draggable:true,\n        isGrouped: 0,\n        className:\"Circle\",\n        id:'center',\n        dragBoundFunc:dragFunc,\n      },\n      positionPoint:{\n        x: 300,\n        y: 500,\n        scaleX:1,\n        scaleY:1,\n        offsetX: 0,\n        offsetY: 0,\n        radius: 3,\n        fill: 'yellow',\n        opacity:1,\n        draggable:false,\n        isGrouped: 0,\n        className:\"positionPoint\",\n        id:'positionPoint',\n        distance_to_line_center:undefined,\n      },\n      selectedShapeId: '',\n    };\n  },\n  mounted(){\n    let texts=this.$refs.stage.getStage().getChildren()[0].getChildren().filter((r)=>r.attrs.className=='Text');\n    \n    \n    for(let i=0;i<texts.length;i++){\n      texts[i].attrs.length_x=texts[i].width();\n      texts[i].attrs.length_y=texts[i].height();\n      texts[i].offsetX(texts[i].attrs.length_x/2);\n      texts[i].offsetY(texts[i].height())\n    }\n  },\n  created(){\n    //nb of shapes on the canvas (line excluded), we consider that there is no shape on line:\n    this.max_id_figures=this.shapes.length +this.groups.length; \n    //this.max_id_lines=this.groups.length;\n    const image = new window.Image();\n    image.src = require(\"@/assets/exsitu.png\");\n    // set image only when it is loaded\n    image.height=150;\n    image.width=150;\n    image.onload = () => {\n      this.shapes.find((r)=>r.className===\"Image\").image= image;\n      this.shapes.find((r)=>r.className===\"Image\").offsetX=image.width/2;\n      this.shapes.find((r)=>r.className===\"Image\").offsetY=image.height; \n    };\n  },\n  methods: {\n\n    switchEraseMode(){\n      if(this.eraseMode==0){\n        this.eraseMode=1;\n        document.getElementById(\"playground\").style.cursor='url('+require('@/assets/ugly_eraser.png')+'),default';\n        \n      this.eraseNodefromTransformer(\"shapeTransformer\");\n      this.eraseNodefromTransformer(\"lineTransformer\");\n      } else{\n        this.eraseMode=0;\n        document.getElementById(\"playground\").style.cursor=\"default\";\n      }\n    },\n    /*\n    Check if all shapes that are supposed to be on a line still in this line.\n    id_grp is the id of the group which contains the line.\n    */\n    checkIfShapesOnLine(id_grp){\n      const grp= this.groups.find((r) => r.id===id_grp);\n      const line=grp.line;\n      const groupedShapes = grp.shapes_g;\n      //const lengthToDetach=10;\n      \n      /*\n      To determine if a shape is on a line, we see if the point is not on the corresponding\n      straight line y=a*x+b regarding certains intervals for x and y.Those intervals depends of the rotation of\n      the line. \n      */\n     /*\n      let coord_y1=line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x1=line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let coord_y2= line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x2=line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let a=(coord_y1-coord_y2)/(coord_x2-coord_x1);\n      let b=line.y-a*line.x;\n      let is_on_straight_line=false;\n      */\n      \n      let i=0;\n      while(i<groupedShapes.length){\n        /*\n        if(Math.abs(coord_x1-coord_x2)>1){\n        is_on_straight_line=(Math.abs(a*groupedShapes[i].x+b-groupedShapes[i].y)<this.lengthToDetach);\n      }else{\n        is_on_straight_line=(Math.abs(groupedShapes[i].x-line.x)<this.lengthToDetach);\n      }\n        if (\n          !(is_on_straight_line)\n        ||((line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].y\n        ||line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].y)\n        && ((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n        ||((line.x+line.points[4]*line.scaleX*(1/2)*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].x\n        ||line.x-line.points[4]*line.scaleX*(1/2)*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].x)\n        &&((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n        ||((line.y+line.points[4]*line.scaleX*(1/2)*Math.sin(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].y\n        ||line.y-line.points[4]*line.scaleX*(1/2)*Math.sin(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].y)\n        &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>=-Math.PI)))\n\n        ||((line.x+line.points[4]*line.scaleX*(1/2)*Math.cos(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].x\n        ||line.x-line.points[4]*line.scaleX*(1/2)*Math.cos(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].x)\n        &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>=-Math.PI)))\n\n        ||((line.y+line.points[4]*line.scaleX*(1/2)*Math.sin(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].y\n        ||line.y-line.points[4]*line.scaleX*(1/2)*Math.sin(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].y)\n        &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n        ||((line.x+line.points[4]*line.scaleX*(1/2)*Math.cos(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].x\n        ||line.x-line.points[4]*line.scaleX*(1/2)*Math.cos(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].x)\n        &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n        ||((line.y+line.points[4]*line.scaleX*(1/2)*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].y\n        ||line.y-line.points[4]*line.scaleX*(1/2)*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].y)\n        &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>0)))\n\n        ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].x\n        ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].x)\n        &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>0)))\n        )\n        */\n       if(!this.isCoordinateOnLine(groupedShapes[i].x,groupedShapes[i].y,line.id)){\n          console.log(\"a shape is not on a line\");\n          groupedShapes[i].dragBoundFunc= dragFunc;\n          groupedShapes[i].isGrouped=0;\n          if(line.keepDistribution){\n            line.positionPoints.slice(i,1)\n          }\n          this.shapes.push(groupedShapes[i],)\n          line.freeDistances.push(line.occupiedDistances[i]);\n          line.occupiedDistances.splice(i,1);\n          \n          groupedShapes.splice(i,1);\n          \n          this.updateNaration(grp);\n        }else{\n          i=i+1;\n        }\n      }\n    },\n\n    //say of {x,y} is a point from the line\n    isCoordinateOnLine(x,y,id_grp){\n      const grp=this.groups.find((r) => r.id===id_grp);\n      const line=grp.line;\n      let is_not_on_straight_line=true;\n      let coord_y1=line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x1=line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let coord_y2= line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x2=line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let a=(coord_y1-coord_y2)/(coord_x2-coord_x1);\n      let b=line.y-a*line.x;\n      if(Math.abs(coord_x1-coord_x2)>1){\n        is_not_on_straight_line=(Math.abs(a*x+b-y)>1);\n      }else{\n        is_not_on_straight_line=(Math.abs(x-line.x)>1)\n      }\n      if(\n        (is_not_on_straight_line)\n\n      ||((line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<y\n      ||line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>y)\n      && ((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<x\n        ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>x)\n      &&((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<y\n        ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>y)\n      &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>-Math.PI)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>x)\n      &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>-Math.PI)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>y)\n      &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>x)\n      &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>y)\n      &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>=0)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>x)\n      &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>=0)))\n\n      ||(!is_not_on_straight_line && Math.sqrt((line.x-x)**2+(line.y-y)**2)>line.points[4]*line.scaleX/2)\n\n      )\n      {\n        return false; \n      } else{\n        return true;\n      }\n    },\n\n    //update a group with the id id_grp\n    updateGrp(e,id_grp){\n      const grep=this.groups.find((r)=>r.id===id_grp);\n      const line= grep.line;\n      grep.offsetX=line.offsetX;\n      grep.offsetY=line.offsetY;\n      \n      line.x=e.target.x();\n      line.y=e.target.y();\n      this.center.x=line.x;\n      this.center.y=line.y;\n      /*\n      if(line.keepDistribution){\n        this.updateOccupiedDistance(line.id);\n      }\n      */\n      this.updateAllPosInGrp(line.id); \n      this.checkIfShapesOnLine(line.id);\n    },\n\n\n    //update the position of all shapes that are on the line of the group with the id id_grp.\n    updateAllPosInGrp(id_grp){\n      const grp= this.groups.find((r) => r.id===id_grp);     \n      const line= grp.line;\n      const shapes_g = grp.shapes_g;\n      for (let i=0;i<shapes_g.length;i++){\n          if(line.keepDistribution){\n            shapes_g[i].x=line.x+line.occupiedDistances[i]*Math.cos(line.rotation*(Math.PI/180));\n            shapes_g[i].y=line.y+line.occupiedDistances[i]*Math.sin(line.rotation*(Math.PI/180));\n            shapes_g[i].distance_to_line_center=line.occupiedDistances[i];\n            shapes_g[i].rotation=shapes_g[i].personalRotation+line.rotation;\n            \n          } else{\n            shapes_g[i].x=line.x+line.occupiedDistances[i]*Math.cos(line.rotation*(Math.PI/180));\n            shapes_g[i].y=line.y+line.occupiedDistances[i]*Math.sin(line.rotation*(Math.PI/180));\n            shapes_g[i].distance_to_line_center=line.occupiedDistances[i];\n            shapes_g[i].rotation=shapes_g[i].personalRotation+line.rotation;\n          }\n          line.positionPoints[i].x=shapes_g[i].x;\n          line.positionPoints[i].y=shapes_g[i].y;\n          line.positionPoints[i].distance_to_line_center=shapes_g[i].distance_to_line_center;\n      }\n      let i=shapes_g.length;\n      while(i<line.positionPoints.length){\n        if(line.keepDistribution){\n          line.positionPoints.splice(i,1);\n        }else{\n        line.positionPoints[i].x=line.x+line.freeDistances[i-shapes_g.length]*Math.cos(line.rotation*(Math.PI/180));\n        line.positionPoints[i].y=line.y+line.freeDistances[i-shapes_g.length]*Math.sin(line.rotation*(Math.PI/180));\n        line.positionPoints[i].distance_to_line_center=line.freeDistances[i-shapes_g.length];\n        i++;\n        }\n        \n      }\n    \n    },\n    isOutsideTheLine(shape,line){\n      let coord_y1=line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x1=line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let coord_y2= line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x2=line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let a=(coord_y1-coord_y2)/(coord_x2-coord_x1);\n      let b=line.y-a*line.x;\n      let is_on_straight_line=false;\n      if(Math.abs(coord_x1-coord_x2)>=1){\n        is_on_straight_line=(Math.abs(a*shape.x+b-shape.y)<1);\n      }else{\n        is_on_straight_line=(Math.abs(shape.x-line.x)<1);\n      }\n      if(\n        !(is_on_straight_line)\n      ||((line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n        ||line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      && ((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>-Math.PI)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>-Math.PI)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>=0)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>=0)))\n      ){\n        return true;\n      }else{ return false}\n    },\n    \n    //update the canvas\n    update(){\n      const shapes = this.shapes\n      \n      //const lengthToCapture=10; //bigger is the number, bigger is the intervals of x and y where a shape can be added to a line.\n      let is_on_straight_line=false;\n      for (let i=0;i<shapes.length;i++){\n        let x=shapes[i].x;\n        let y=shapes[i].y;\n      for (let j=0;j<this.groups.length;j++){\n      \n        let line=this.groups[j].line;\n\n        \n        let coord_y1=line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n        let coord_x1=line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n        let coord_y2= line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n        let coord_x2=line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n        let a=(coord_y1-coord_y2)/(coord_x2-coord_x1);\n        let b=line.y-a*line.x;\n        if(Math.abs(coord_x1-coord_x2)>1){\n          is_on_straight_line=(Math.abs(a*x+b-y)<=this.lengthToCapture);\n        }else{\n          is_on_straight_line=(Math.abs(x-line.x)<=this.lengthToCapture);\n          //is_on_straight_line=true;\n        }\n        if(\n        (\n          is_on_straight_line\n      &&(line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToCapture>=y\n      && line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToCapture<=y)\n      &&(line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToCapture>=x\n      && line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToCapture<=x)\n      &&(line.rotation*(Math.PI/180)<=0 \n      && line.rotation*(Math.PI/180)>-Math.PI/2))\n\n      ||(\n        is_on_straight_line\n      &&(line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))+this.lengthToCapture>=y\n      && line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))-this.lengthToCapture<=y) \n      &&(line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))+this.lengthToCapture>=x\n      && line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))-this.lengthToCapture<=x)\n      &&(line.rotation*(Math.PI/180)<=-Math.PI/2 \n      && line.rotation*(Math.PI/180)>=-Math.PI))\n\n      ||(\n        is_on_straight_line\n      &&(line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))+this.lengthToCapture>=y\n      &&line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))-this.lengthToCapture<=y)\n      &&(line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))+this.lengthToCapture>=x\n      && line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))-this.lengthToCapture<=x)\n      &&(line.rotation*(Math.PI/180)<=Math.PI \n      && line.rotation*(Math.PI/180)>Math.PI/2))\n\n      ||(\n        is_on_straight_line\n      &&(line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToCapture>=y\n      && line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToCapture<=y)\n      &&(line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToCapture>=x\n      && line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToCapture<=x)\n      &&(line.rotation*(Math.PI/180)<=Math.PI/2\n      && line.rotation*(Math.PI/180)>=0))\n      )\n       {\n          shapes[i].isGrouped=1;\n          this.makeGroup(line.id);\n        }\n      }\n      }\n    },\n\n    CheckIfNeedToDetach(e){\n      let grp=this.groups.find((r)=>r.id===e.target.getParent().attrs.id);\n      let shape= grp.shapes_g.find((r)=>r.id==e.target.id());\n      let dist=Math.sqrt((e.target.getStage().getPointerPosition().y-e.target.y())**2+(e.target.getStage().getPointerPosition().x-e.target.x())**2);\n      if(e.target.className==\"Rect\"){\n        dist-=e.target.attrs.height*e.target.attrs.scaleY;\n      } else if(e.target.className==\"Circle\"){\n        dist-=(2*e.target.attrs.radius)*e.target.attrs.scaleY;\n      } else if(e.target.className==\"Text\"){\n        dist-=e.target.attrs.length_y*e.target.attrs.scaleY;\n      } else if(e.target.className==\"Image\"){\n        dist-=e.target.height()*e.target.scaleY();\n      } else if(e.target.attrs.className==\"Triangle\"){\n        dist-=e.target.height()*e.target.scaleY();\n      } \n      \n      if (dist>50){\n        //let shape= this.groups.find((r)=>r.id===e.target.getParent().attrs.id).shapes_g.find((r)=>r.id==e.target.id());\n        //this.groups.find((r)=>r.id===e.target.getParent().attrs.id).shapes_g.find((r)=>r.id==e.target.id()).needToBeDetach=1;\n        /*\n        shape.dragBoundFunc= function (pos) {\n              return {\n                x: pos.x,\n                y: pos.y,\n              };\n        }\n        */\n        //shape.x=e.target.getStage().getPointerPosition().x;\n        //shape.y=e.target.getStage().getPointerPosition().y;\n        //if (Math.abs(e.target.getStage().getPointerPosition().y-e.target.y())>220){\n        \n        //shape.x=e.target.getStage().getPointerPosition().x;\n        //shape.y=e.target.getStage().getPointerPosition().y;\n        this.groups.find((r)=>r.id===e.target.getParent().attrs.id).aShapeHasBeenDetach=1;\n        this.DetachShape(shape,e.target.getStage().getPointerPosition().x,e.target.getStage().getPointerPosition().y);\n        \n        //}\n        \n        \n        \n      }\n    },\n\n    //Give the sign of the distance of shape from the center of a line.\n    GiveSignOfDistance(shape,line){\n      let result;\n      let angle=line.rotation*(Math.PI/180);\n      let distX=shape.x-line.x;\n      let distY=shape.y-line.y;\n      /*\n      \n      if(angle<=-Math.PI/4 || angle>=-Math.PI/2){\n        result=-Math.sign(distY);\n      }\n      else if(angle<=-Math.PI/2 || angle>=-3*Math.PI/4){\n        result=Math.sign(distY);\n      }\n      else if(angle<=-3*Math.PI/4 || angle>=-Math.PI){\n        result=-Math.sign(distX);\n      }else if(angle>=3*Math.PI/4 || angle<=Math.PI){\n        result=Math.sign(distX);\n      }else if(angle>=Math.PI/2 || angle<3*Math.PI/4){\n        result=-Math.sign(distY);\n      } else if(angle<=Math.PI/2 || angle>Math.PI/4){\n        result=-Math.sign(distY);\n      } else if(angle<=Math.PI/4 || angle>=0){\n        result=Math.sign(distX);\n      }\n      */\n      \n      \n      if(Math.abs(distX)<=this.lengthToCapture && line.rotation==-90){\n        \n        result=-Math.sign(distY);\n      } else if (Math.abs(distX)<=this.lengthToCapture && line.rotation==90){\n        result=Math.sign(distY);\n      }\n      else{\n        result=Math.sign(distX);\n      }\n      if(angle<-Math.PI/2 || angle>Math.PI/2){\n        result=-result;\n      }\n      \n      return result;\n    },\n\n    //Different from the previous function bcs the straight line of the center is perdendicular to the line\n    GiveSignOfDistanceBtwCenterAndShape(center,shape){\n      let result;\n      let angle=shape.rotation*(Math.PI/180);\n      let distX=center.x-shape.x;\n      let distY=center.y-shape.y;\n      /*\n      \n      if(angle<=-Math.PI/4 || angle>=-Math.PI/2){\n        result=-Math.sign(distY);\n      }\n      else if(angle<=-Math.PI/2 || angle>=-3*Math.PI/4){\n        result=Math.sign(distY);\n      }\n      else if(angle<=-3*Math.PI/4 || angle>=-Math.PI){\n        result=-Math.sign(distX);\n      }else if(angle>=3*Math.PI/4 || angle<=Math.PI){\n        result=Math.sign(distX);\n      }else if(angle>=Math.PI/2 || angle<3*Math.PI/4){\n        result=-Math.sign(distY);\n      } else if(angle<=Math.PI/2 || angle>Math.PI/4){\n        result=-Math.sign(distY);\n      } else if(angle<=Math.PI/4 || angle>=0){\n        result=Math.sign(distX);\n      }\n      */\n      \n      \n      if(Math.abs(distY)<=this.lengthToCapture && shape.rotation==-90){\n        \n        result=Math.sign(distX);\n      } else if (Math.abs(distY)<=this.lengthToCapture && shape.rotation==90){\n        result=-Math.sign(distX);\n      }\n      else{\n        result=Math.sign(distY);\n      }\n      if(angle<-Math.PI/2 || angle>Math.PI/2){\n        result=-result;\n      }\n      \n      return result;\n    },\n\n    /*add shapes with isGrouped==1 to the group with the id id_grp.\n    */\n    makeGroup(id_grp){\n      this.eraseNodefromTransformer(\"shapeTransformer\");\n      this.eraseNodefromTransformer(\"lineTransformer\");\n      const grp=this.groups.find((r)=> r.id===id_grp);\n      const line=grp.line;\n      const shapes = this.shapes;\n      line.freeDistances.sort(this.isSmaller); //we will give the shortest available distance to the added shape\n      shapes.sort(this.isBeforeRegardingX);\n      for (let i=0;i<shapes.length;i++){\n        if(shapes[i].isGrouped==1){\n          const positionPoint=Object.assign({},this.positionPoint);\n          let distX=shapes[i].x-line.x;\n          let distY=shapes[i].y-line.y; \n          shapes[i].personalRotation=0;\n          //let pot_dist=this.GiveSignOfDistance(shapes[i],line)*Math.sqrt((distX)**2+(distY)**2);\n          /*\n          if(line.keepDistribution && line.freeDistances.length>0){\n          let distances=line.freeDistances+line.occupiedDistances;\n          console.log(distances);\n           let freeDistance=this.isNearest(line.freeDistances,pot_dist);\n           //shapes[i].distance_to_line_center=freeDistance.res; \n           shapes[i].distance_to_line_center=this.GiveSignOfDistance(shapes[i],line)*Math.sqrt((distX)**2+(distY)**2);\n            \n           line.occupiedDistances.push(shapes[i].distance_to_line_center,);\n           line.freeDistances.splice(freeDistance.indice,1);\n\n          } else{\n            */\n            //let distX=shapes[i].x-line.x;\n            //let distY=shapes[i].y-line.y;\n            shapes[i].distance_to_line_center=this.GiveSignOfDistance(shapes[i],line)*Math.sqrt((distX)**2+(distY)**2);\n            /*If the distance is a little bit to far from the center \n            we adjust it so that the shape can be at one of the border of the stickyline*/\n            if(Math.abs(shapes[i].distance_to_line_center)>=line.points[4]*line.scaleX/2){\n              shapes[i].distance_to_line_center=Math.sign(shapes[i].distance_to_line_center)*line.points[4]*line.scaleX/2\n            }\n            this.ChangeCenterRegardingCommand(shapes[i].id,grp.line.defaultAlignment);\n            \n              //shapes[i].isGrouped=0;\n              this.updateDragFunc(shapes[i],line);\n              grp.shapes_g.push(shapes[i],);\n              console.log(\"no 'free distance' anymore\")\n              grp.line.occupiedDistances.push(shapes[i].distance_to_line_center,);\n              positionPoint.id=\"positionPoint\"+grp.id+grp.line.positionPoints.length;\n              grp.line.positionPoints.push(positionPoint,);\n              //shapes[i].distance_to_line_center=this.GiveSignOfDistance(shapes[i],line)*Math.sqrt((distX)**2+(distY)**2);\n            \n            //line.occupiedDistances.push(shapes[i].distance_to_line_center,);\n          //}\n          console.log(\"A new shape has been added with a distance\"+shapes[i].distance_to_line_center);\n          //shapes[i].isGrouped=0;\n          //this.updateDragFunc(shapes[i],line);\n          //grp.shapes_g.push(shapes[i],);\n          this.updateOccupiedDistance(line.id);\n          \n          this.updateAllPosInGrp(id_grp);\n\n          shapes.splice(i,1);\n          \n          this.updateNaration(grp);\n        }\n      }\n      this.center.x=line.x;\n      this.center.y=line.y;\n    },\n\n    updateOccupiedDistance(id_grp){\n      \n      const grp=this.groups.find((r)=> r.id===id_grp);\n      //this.updateAllPosInGrp(id_grp);\n      this.sortByDistToLineCenter(grp);\n      \n      //let l=grp.line.points[4]/2;\n      if(grp.line.keepDistribution){\n      let L=grp.line.points[4];\n      let nb_shapes=grp.shapes_g.length;\n      let d=(L/(nb_shapes-1))*grp.line.scaleX;\n      if(nb_shapes%2==0){\n        \n      for (let i =1;i<=nb_shapes/2-1;i++){\n        //grp.line.occupiedDistances[i-1]=-(l/i);\n        grp.line.occupiedDistances[i-1]=-((nb_shapes/2-1)-i+1)*d-d/2\n      }\n      for (let i =1;i<=nb_shapes/2-1;i++){\n        grp.line.occupiedDistances[nb_shapes/2+i]=i*d+d/2;\n      }\n      grp.line.occupiedDistances[nb_shapes/2-1]=-d/2\n      grp.line.occupiedDistances[nb_shapes/2]=d/2\n      } else{\n        for (let i =1;i<=(nb_shapes-1)/2;i++){\n          grp.line.occupiedDistances[i-1]=-d*(((nb_shapes-1)/2)-i+1);\n        }\n        for (let i =1;i<=(nb_shapes-1)/2;i++){\n          grp.line.occupiedDistances[((nb_shapes-1)/2)+i]=d*i;\n        }\n        grp.line.occupiedDistances[(nb_shapes-1)/2]=0;\n      }\n      \n      for (let i=0;i<grp.shapes_g.length;i++){\n        grp.shapes_g[i].distance_to_line_center=grp.line.occupiedDistances[i];\n      }\n      }\n      else{\n        grp.line.occupiedDistances.sort(this.isSmaller);\n      }\n      \n      \n      \n    \n\n    },\n\n   isSmaller(a,b){\n    if(a<b){\n      return -1;\n    }else{\n      return 1\n    }\n   },\n\n   isBeforeRegardingX(a,b){\n    if(a.x<b.x){\n      return -1;\n    }else{\n      return 1;\n    }\n   },\n\n    \n   updateOccDist(grp,shape){\n    let res=this.isNearest(grp.line,shape);\n    //let grp=this.groups.find((r)=>r.id===line.id);\n    if(res.isFree){\n      shape.distance_to_line_center=grp.line.freeDistances[res.indice];\n      grp.line.freeDistances.splice(res.indice,1);\n      this.sortByDistToLineCenter(grp);\n      for(let l=0;l<grp.shapes_g.length;l++){\n        if(grp.line.occupiedDistances.length==l){\n          grp.line.occupiedDistances.push(grp.shapes_g[l].distance_to_line_center,);\n        }else{\n          grp.line.occupiedDistances[l]=grp.shapes_g[l].distance_to_line_center;\n        }\n      } \n    } else{\n      grp.shapes_g.find((r)=>r.id==shape.id).distance_to_line_center=grp.line.occupiedDistances[res.indice];\n      grp.line.occupiedDistances.splice(res.indice,1);\n      //line.occupiedDistances.push(shape.distance_to_line_center,);\n      //line.freeDistances.splice(res.indice,1);   \n      this.updateOccDist(grp,grp.shapes_g[res.indice]);\n    }\n   },\n   isNearest(line,shape){\n    let ecart;\n    let invx=line.x+line.freeDistances[0]*Math.cos(line.rotation*(Math.PI/180));\n    let invy=line.y+line.freeDistances[0]*Math.sin(line.rotation*(Math.PI/180));\n    let ecart_min=Math.sqrt((invx-shape.x)**2+(invy-shape.y)**2);\n    let indice=0;\n    for(let i=1;i<line.freeDistances.length;i++){\n      invx=line.x+line.freeDistances[i]*Math.cos(line.rotation*(Math.PI/180));\n      invy=line.y+line.freeDistances[i]*Math.sin(line.rotation*(Math.PI/180));\n      ecart=Math.sqrt((invx-shape.x)**2+(invy-shape.y)**2);\n      if(ecart<ecart_min){\n        //res=line.freeDistances[i];\n        ecart_min=ecart;\n        indice=i;\n      }\n    }\n    return indice;\n    /*\n    let allDist=line.freeDistances.concat(line.occupiedDistances);\n    console.log(allDist);\n    \n    let ecart;\n    let invx=line.x+allDist[0]*Math.cos(line.rotation*(Math.PI/180));\n    let invy=line.y+allDist[0]*Math.sin(line.rotation*(Math.PI/180));\n    let ecart_min=Math.sqrt((invx-shape.x)**2+(invy-shape.y)**2)\n    let indice=0;\n    console.log(ecart_min);\n    for(let i=1;i<allDist.length;i++){\n      invx=line.x+allDist[i]*Math.cos(line.rotation*(Math.PI/180));\n      invy=line.y+allDist[i]*Math.sin(line.rotation*(Math.PI/180));\n      ecart=Math.sqrt((invx-shape.x)**2+(invy-shape.y)**2);\n      if(this.groups.find((r)=>r.id==line.id).shapes_g.indexOf(shape)!=-1){\n        console.log(ecart_min);\n        console.log(ecart);\n        if(ecart<ecart_min && ecart!=0){\n          //res=allDist[i];\n          ecart_min=ecart;\n          indice=i;\n        }\n      }else if(ecart<ecart_min){\n        //res=allDist[i];\n        ecart_min=ecart;\n        indice=i;\n      }\n    }\n    console.log(indice);\n    if(indice>=line.freeDistances.length){\n      return{\n        isFree: false,\n        indice: indice-line.freeDistances.length,\n      }\n    }else{\n      return{\n        isFree: true,\n        indice: indice,\n      }\n    }\n    */\n\n    /*\n    line.freeDistances.sort(this.isSmaller);\n    let ecart;\n    let invx=line.x+line.freeDistances[0]*Math.cos(line.rotation*(Math.PI/180));\n    let invy=line.y+line.freeDistances[0]*Math.sin(line.rotation*(Math.PI/180));\n    let ecart_min=Math.sqrt((invx-shape.x)**2+(invy-shape.y)**2)\n    let indice=0;\n    for(let i=0;i<line.freeDistances.length;i++){\n      invx=line.x+line.freeDistances[i]*Math.cos(line.rotation*(Math.PI/180));\n      invy=line.y+line.freeDistances[i]*Math.sin(line.rotation*(Math.PI/180));\n      ecart=Math.sqrt((invx-shape.x)**2+(invy-shape.y)**2)\n      if(ecart<ecart_min){\n        //res=freeDistances[i];\n        ecart_min=ecart;\n        indice=i;\n      }\n    }\n    return indice;\n    */\n    /*\n    if(shapeDistance>=0){\n      for(let i=0;i<freeDistances.length;i++){\n        if(freeDistances[i]>shapeDistance){\n          return i;\n        }\n      }\n      return freeDistances.length-1;\n    }else{\n      let ecart_min=Math.abs(Math.abs(freeDistances[0])-Math.abs(shapeDistance))\n      let indice=0;\n      for(let i=0;i<freeDistances.length;i++){\n        let ecart=Math.abs(Math.abs(freeDistances[i])-Math.abs(shapeDistance));\n        if(ecart<ecart_min){\n          //res=freeDistances[i];\n          ecart_min=ecart;\n          indice=i;\n        }\n      }\n      return indice;\n    }\n    */\n    /*\n    //let res=freeDistances[0];\n    let ecart_min=Math.abs(Math.abs(freeDistances[0])-Math.abs(shapeDistance))\n    let indice=0;\n    for(let i=0;i<freeDistances.length;i++){\n      let ecart=Math.abs(Math.abs(freeDistances[i])-Math.abs(shapeDistance));\n      if(ecart<ecart_min){\n        //res=freeDistances[i];\n        ecart_min=ecart;\n        indice=i;\n      }\n    }\n    return indice;\n    */\n   },\n   \n\n   sortByDistToLineCenter(grp){\n    //this.updateAllPosInGrp(grp.id)\n    //let last_distX=new Array(grp.shapes_g.length);\n    \n    //let distX;\n    //let distY;\n    //let sign;\n    //let dist=new Array(grp.shapes_g.length);\n    //let angle;\n    if(grp.line.keepDistribution){\n      for (let l=0;l<grp.shapes_g.length;l++){\n          let distX=grp.shapes_g[l].x-grp.line.x;\n          let distY=grp.shapes_g[l].y-grp.line.y;\n          //dist[l]=this.GiveSignOfDistance(grp.shapes_g[l],grp.line)*Math.sqrt((distX)**2+(distY)**2);\n          grp.shapes_g[l].distance_to_line_center=this.GiveSignOfDistance(grp.shapes_g[l],grp.line)*Math.sqrt((distX)**2+(distY)**2);\n          //last_distX[l]=distX;\n        }\n    }\n    for(let i=1;i<grp.shapes_g.length;i++){\n      \n     \n      let shape=grp.shapes_g[i];\n      //let distance=dist[i];\n      let j=i\n      while(j>0 && grp.shapes_g[j-1].distance_to_line_center>shape.distance_to_line_center){\n        grp.shapes_g[j]=grp.shapes_g[j-1];\n        //dist[j]=dist[j-1]\n        j=j-1;\n      }\n      grp.shapes_g[j]=shape;\n      //dist[j]=distance;\n    }\n   },\n   \n\n   sortAnyShapesByDistToLineCenter(shapes,line){\n    //this.updateAllPosInGrp(grp.id)\n    //let last_distX=new Array(grp.shapes_g.length);\n    \n    //let distX;\n    //let distY;\n    //let sign;\n    //let dist=new Array(grp.shapes_g.length);\n    //let angle;\n    for (let l=0;l<shapes.length;l++){\n        let distX=shapes[l].x-line.x;\n        let distY=shapes[l].y-line.y;\n        /*\n        angle=grp.shapes_g[l].rotation*(Math.PI/180);\n\n      \n      if(angle<=-Math.PI/4 || angle>=-Math.PI/2){\n        sign=-Math.sign(distY);\n      }\n      else if(angle<=-Math.PI/2 || angle>=-3*Math.PI/4){\n        sign=Math.sign(distY);\n      }\n      else if(angle<=-3*Math.PI/4 || angle>=-Math.PI){\n        sign=-Math.sign(distX);\n      }else if(angle>=3*Math.PI/4 || angle<=Math.PI){\n        sign=Math.sign(distX);\n      }else if(angle>=Math.PI/2 || angle<3*Math.PI/4){\n        sign=-Math.sign(distY);\n      } else if(angle<=Math.PI/2 || angle>Math.PI/4){\n        sign=-Math.sign(distY);\n      } else if(angle<=Math.PI/4 || angle>=0){\n        sign=Math.sign(distX);\n      }\n       console.log(sign);\n        */\n       \n        /*\n        if(Math.sin(grp.line.rotation*(Math.PI/180))==0){\n            grp.shapes_g[l].distance_to_line_center=grp.shapes_g[l].x-grp.line.x;\n        }else{\n            grp.shapes_g[l].distance_to_line_center=Math.sign(distX)*Math.sqrt((distX)**2+(distY)**2);\n          \n            if(grp.line.rotation*(Math.PI/180)<=-Math.PI/2 || grp.line.rotation*(Math.PI/180)<=Math.PI/2 &&grp.line.rotation*(Math.PI/180)>=0){\n              grp.shapes_g[l].distance_to_line_center=-grp.shapes_g[l].distance_to_line_center\n            }\n        }\n        */\n        //dist[l]=this.GiveSignOfDistance(grp.shapes_g[l],grp.line)*Math.sqrt((distX)**2+(distY)**2);\n        shapes.distance_to_line_center=this.GiveSignOfDistance(shapes,line)*Math.sqrt((distX)**2+(distY)**2);\n        /*\n        if((grp.line.rotation*(Math.PI/180)<=-Math.PI/2 || (grp.line.rotation*(Math.PI/180)<=Math.PI/2 && grp.line.rotation*(Math.PI/180)>=0)) && (Math.sign(last_distX[l])!=Math.sign(distX))){\n          grp.shapes_g[l].distance_to_line_center=-grp.shapes_g[l].distance_to_line_center\n        }\n        */\n        //last_distX[l]=distX;\n      }\n    for(let i=1;i<shapes.length;i++){\n      \n     \n      let shape=shapes[i];\n      //let distance=dist[i];\n      let j=i\n      while(j>0 && shapes[j-1].distance_to_line_center>shape.distance_to_line_center){\n        shapes[j]=shapes[j-1];\n        //dist[j]=dist[j-1]\n        j=j-1;\n      }\n      shapes[j]=shape;\n      //dist[j]=distance;\n    }\n   },\n\n  \n\n   /*\n   update the drag function of a shape which is on a line. \n   */\n   updateDragFunc(shape,line){\n          let angle=line.rotation*(Math.PI/180);\n          if (angle<=0 && angle>=-Math.PI/4){\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x +(pos.x-line.x)*Math.cos(angle),\n                y: line.y+(pos.x-line.x)*Math.sin(angle),\n              };\n            }\n          } else if (angle<-Math.PI/4 && angle>=-Math.PI/2){\n            // We prefer, in this case, moving the shape of the line regarding the y of the mouse position instead of the x.\n            // So that the user can move the shape more intuitively\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x-(pos.y-line.y)*Math.cos(angle),\n                y: line.y-(pos.y-line.y)*Math.sin(angle),\n              };\n            }\n          }\n          else if (angle<-Math.PI/2 && angle>=-3*Math.PI/4){\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x-(pos.y-line.y)*Math.cos(angle),\n                y: line.y-(pos.y-line.y)*Math.sin(angle),\n              };\n            }\n          } else if (angle<-3*Math.PI/4 && angle>=-Math.PI){\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x-(pos.x-line.x)*Math.cos(angle),\n                y: line.y-(pos.x-line.x)*Math.sin(angle),\n              };\n            }\n          }else if (angle<=Math.PI && angle>=3*Math.PI/4){\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x-(pos.x-line.x)*Math.cos(angle),\n                y: line.y-(pos.x-line.x)*Math.sin(angle),\n              };\n            }\n          } else if (angle<3*Math.PI/4 && angle>=Math.PI/2){\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x+(pos.y-line.y)*Math.cos(angle),\n                y: line.y+(pos.y-line.y)*Math.sin(angle),\n              };\n            }\n          } else if (angle<Math.PI/2 && angle>=Math.PI/4){\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x+(pos.y-line.y)*Math.cos(angle),\n                y: line.y+(pos.y-line.y)*Math.sin(angle),\n              };\n            }\n          }else if (angle<Math.PI/4 && angle>=0){\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x+(pos.x-line.x)*Math.cos(angle),\n                y: line.y+(pos.x-line.x)*Math.sin(angle),\n              };\n            }\n          }\n   },\n\n   /*\n   Update the position of a free shape when it is dragging.\n   */\n    updatePos(e){\n      const shape = this.shapes.find(i => i.id === e.target.id());\n      shape.x=e.target.x();\n      shape.y=e.target.y();\n      this.center.x=e.target.x();\n      this.center.y=e.target.y();\n\n      let pos = { x: shape.x, y: shape.y };\n      e.target.position(pos);\n      e.target.getLayer().batchDraw();\n      \n    },\n\n    /*\n    Update the positio  of shape attached to a line (from the group with id=id_grp) when it is dragging.\n     */\n    updatePosInGrp(e,id_grp){\n      let distX;\n      let distY;\n      let distance_to_line_center;\n      const grp=this.groups.find((r)=> r.id===id_grp);\n      \n      if(grp.aShapeHasBeenDetach==1){\n        grp.aShapeHasBeenDetach=0;\n        return;\n      }\n      const line=grp.line;\n      const shape = grp.shapes_g.find(i => i.id === e.target.id());\n      const shapes_g = grp.shapes_g; \n      //const lengthToDetach=10;\n      if(shape.needToBeDetach==1){\n        shape.needToBeDetach=0;\n        this.DetachShape(shape);\n        this.updateAllPosInGrp(e.target.getParent().attrs.id);\n      }\n      if(line.keepDistribution){\n        if(this.isCoordinateOnLine(e.target.x(),e.target.y(),line.id)){\n          distX=shape.x-e.target.x();\n          distY=shape.y -e.target.y();\n          let L=grp.line.points[4];\n          let nb_shapes=grp.shapes_g.length;\n          let d=(L/(nb_shapes-1))*grp.line.scaleX;\n          let dist=Math.sqrt(distX**2 +distY**2);\n          if(dist>=d){\n            shape.x=e.target.x();\n            shape.y=e.target.y();\n            this.updateOccupiedDistance(line.id)\n            shape.x=line.x+line.occupiedDistances[shapes_g.indexOf(shape)]*Math.cos(line.rotation*(Math.PI/180));\n            shape.y=line.y+line.occupiedDistances[shapes_g.indexOf(shape)]*Math.sin(line.rotation*(Math.PI/180));\n            shape.distance_to_line_center=line.occupiedDistances[shapes_g.indexOf(shape)];\n            shape.rotation=line.rotation;\n            this.updateAllPosInGrp(line.id);\n          }else{\n            shape.x=line.x+line.occupiedDistances[shapes_g.indexOf(shape)]*Math.cos(line.rotation*(Math.PI/180));\n            shape.y=line.y+line.occupiedDistances[shapes_g.indexOf(shape)]*Math.sin(line.rotation*(Math.PI/180));\n            shape.distance_to_line_center=line.occupiedDistances[shapes_g.indexOf(shape)];\n            shape.rotation=line.rotation; \n          }   \n        }else{\n          shape.x=e.target.x();\n          shape.y=e.target.y();\n        }\n        line.positionPoints[grp.shapes_g.indexOf(shape)].x=shape.x;\n        line.positionPoints[grp.shapes_g.indexOf(shape)].y=shape.y;\n        line.positionPoints[grp.shapes_g.indexOf(shape)].distance_to_line_center=shape.distance_to_line_center; \n      } else{\n        \n          line.positionPoints[grp.shapes_g.indexOf(shape)].x=shape.x;\n          line.positionPoints[grp.shapes_g.indexOf(shape)].y=shape.y;\n          shape.x=e.target.x();\n          shape.y=e.target.y();\n          \n          if(Math.sin(line.rotation*(Math.PI/180))==0){\n            distance_to_line_center=shape.x-line.x;\n          }else{\n            if(Math.sign(shape.x-line.x)!=0){\n              distance_to_line_center=Math.sign(-shape.rotation)*Math.sign(shape.x-line.x)*Math.sqrt((shape.x-line.x)**2+(shape.y-line.y)**2);\n            } else{\n             distance_to_line_center=Math.sign(-shape.rotation)*Math.sign(shape.y-line.y)*Math.sqrt((shape.x-line.x)**2+(shape.y-line.y)**2); \n            }\n          \n            if(shape.rotation*(Math.PI/180)<=-Math.PI/2 || (shape.rotation*(Math.PI/180)<=Math.PI/2 && shape.rotation*(Math.PI/180)>=0)){\n              distance_to_line_center=-distance_to_line_center\n            }\n          }\n          //shape.distance_to_line_center=distance_to_line_center;\n          //grp.line.occupiedDistances[shapes_g.indexOf(shape)]=shape.distance_to_line_center;\n        line.positionPoints[grp.shapes_g.indexOf(shape)].distance_to_line_center=shape.distance_to_line_center;\n          \n      }\n      let pos = { x: shape.x, y: shape.y };\n      this.center.x=shape.x;\n      this.center.y=shape.y;\n      e.target.position(pos);\n      e.target.getLayer().batchDraw();\n      if(!this.isCoordinateOnLine(shape.x,shape.y,line.id)){\n        shape.dragBoundFunc= dragFunc;\n        shape.isGrouped=0;\n        this.shapes.push(shape,)\n        for (let i=0;i<shapes_g.length;i++){\n          if(shapes_g[i].id==shape.id){\n            line.freeDistances.push(line.occupiedDistances[i]);\n            line.occupiedDistances.splice(i,1);\n            shapes_g.splice(i,1);\n            console.log(\"a shape has been removed from the line\");\n          }\n        } \n      }else{\n        if(!line.keepDistribution){\n          grp.line.occupiedDistances[shapes_g.indexOf(shape)]=distance_to_line_center;\n        }else{\n        grp.line.occupiedDistances[shapes_g.indexOf(shape)]=shape.distance_to_line_center;\n        }\n        \n      line.positionPoints[grp.shapes_g.indexOf(shape)].x=shape.x;\n      line.positionPoints[grp.shapes_g.indexOf(shape)].y=shape.y;\n      line.positionPoints[grp.shapes_g.indexOf(shape)].distance_to_line_center=shape.distance_to_line_center;\n       \n      }\n      /*\n      let coord_y1=line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x1=line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let coord_y2= line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x2=line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let a=(coord_y1-coord_y2)/(coord_x2-coord_x1);\n      let b=line.y-a*line.x;\n      let is_on_straight_line=false;\n      if(Math.abs(coord_x1-coord_x2)>=1){\n        is_on_straight_line=(Math.abs(a*shape.x+b-shape.y)<1);\n      }else{\n        is_on_straight_line=(Math.abs(shape.x-line.x)<1);\n      }\n      if(\n        !(is_on_straight_line)\n      ||((line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n        ||line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      && ((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>-Math.PI)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>-Math.PI)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>=0)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>=0)))\n      )\n      {\n        shape.dragBoundFunc= dragFunc;\n        this.shapes.push(shape,)\n        for (let i=0;i<shapes_g.length;i++){\n          if(shapes_g[i].id==shape.id){\n            line.freeDistances.push(line.occupiedDistances[i]);\n            line.occupiedDistances.splice(i,1);\n            shapes_g.splice(i,1);\n            console.log(\"a shape has been removed from the line\");\n          }\n        } \n      }else{\n        if(!line.keepDistribution){\n          grp.line.occupiedDistances[shapes_g.indexOf(shape)]=distance_to_line_center;\n        }else{\n        grp.line.occupiedDistances[shapes_g.indexOf(shape)]=shape.distance_to_line_center;\n        }\n      }\n      */\n      //this.updateOccupiedDistance(line.id);\n      \n          if(line.keepDistribution){\n            this.updateOccupiedDistance(line.id);\n          }\n          \n          this.updateAllPosInGrp(line.id);\n    },\n    \n    /*\n    Function called when the transformation of a shape with a transfomer is finished.\n    */\n    updateTransformedShape(e) {\n      \n\n      let res;\n      let shape; //Object concerned by the transformation\n      if(e.target.className==\"Line\"){\n        shape=this.groups.find(\n        (r) => r.id === this.selectedShapeId\n      ).line;\n      }else{\n        res=this.findShape(this.selectedShapeId)\n        shape=res.shape_data;\n        if(shape== undefined){\n          return;\n        }\n      }\n\n      \n      let last_shapex= shape.x;\n      let last_shapey= shape.y;\n\n      //update data of the transformed object.\n      shape.x = e.target.x();\n      shape.y = e.target.y();\n      shape.rotation = e.target.rotation();\n      let last_scaleX= shape.scaleX;\n      shape.scaleX = e.target.scaleX();\n      shape.scaleY = e.target.scaleY();\n\n      if(e.target.className==\"Line\"){\n        const grp=this.groups.find((r)=> r.id===shape.id);\n        if(shape.keepDistribution){\n          for (let i=0;i<shape.occupiedDistances.length;i++){\n            shape.occupiedDistances[i]=(shape.occupiedDistances[i]/last_scaleX)*shape.scaleX;\n          }\n          /*\n          for (let i=0;i<shape.freeDistances.length;i++){\n            shape.freeDistances[i]=(shape.freeDistances[i]/last_scaleX)*shape.scaleX;\n          }\n          */\n          \n          //this.updateOccupiedDistance(shape.id)\n          this.update();\n          this.updateGrp(e, this.selectedShapeId);\n          this.checkIfShapesOnLine(this.selectedShapeId);        \n        }else{\n          \n          \n          \n         if(last_scaleX!=shape.scaleX){\n          for(let i=0;i<grp.shapes_g.length;i++){\n          \n          //If the width of the line has been changed, we update the distance from the shape to the center of the line\n            \n              let distX=grp.shapes_g[i].x-shape.x;\n              let distY=grp.shapes_g[i].y-shape.y;\n              /*\n              if(Math.sign(grp.shapes_g[i].distance_to_line_center)==0){\n                grp.shapes_g[i].distance_to_line_center=-this.GiveSignOfDistance(grp.shapes_g[i],shape)*Math.sqrt((distX)**2 +(distY)**2);\n              \n              }else{\n                grp.shapes_g[i].distance_to_line_center=Math.sign(grp.shapes_g[i].distance_to_line_center)*Math.sqrt((distX)**2 +(distY)**2);\n              }\n              if(Math.sign((grp.shapes_g[i].x-last_shapex))!=Math.sign(distX)){\n                grp.shapes_g[i].distance_to_line_center=-grp.shapes_g[i].distance_to_line_center;\n              }\n              */\n             if(Math.sign(grp.line.occupiedDistances[i])==0){\n                //if(grp.line.rotation!=-90 && grp.line.rotation!=90){\n                  //grp.line.occupiedDistances[i]=-this.GiveSignOfDistance(grp.shapes_g[i],shape)*Math.sqrt((distX)**2 +(distY)**2);\n                //}else{\n                  grp.line.occupiedDistances[i]=this.GiveSignOfDistance(grp.shapes_g[i],shape)*Math.sqrt((distX)**2 +(distY)**2);\n                  \n                //}\n              \n              }else{\n                grp.line.occupiedDistances[i]=Math.sign(grp.line.occupiedDistances[i])*Math.sqrt((distX)**2 +(distY)**2);\n              }\n\n              \n              if(Math.sign((grp.shapes_g[i].x-last_shapex))!=Math.sign(distX) && Math.sign((grp.shapes_g[i].x-last_shapex))!=0 && grp.line.rotation!=90 && grp.line.rotation!=-90){\n                \n                grp.line.occupiedDistances[i]=-grp.line.occupiedDistances[i];\n              }\n              if(Math.sign((grp.shapes_g[i].y-last_shapey))!=Math.sign(distY) && Math.sign((grp.shapes_g[i].y-last_shapey))!=0 && (grp.line.rotation==90 || grp.line.rotation==-90)){\n                grp.line.occupiedDistances[i]=-grp.line.occupiedDistances[i];\n              }\n              //this.checkIfShapesOnLine(this.selectedShapeId);  \n            \n            //this.checkIfShapesOnLine(this.selectedShapeId);\n            //grp.line.occupiedDistances[i]=grp.shapes_g[i].distance_to_line_center;\n            \n          }\n          for (let i=0;i<shape.freeDistances.length;i++){\n            let distX=last_shapex-shape.x;\n            let distY=last_shapey-shape.y; \n            let dist=Math.sqrt(distX**2+distY**2);\n            if(shape.rotation<-90 ||shape.rotation>90){\n              shape.freeDistances[i]=shape.freeDistances[i]-Math.sign(last_shapex-shape.x)*dist;\n            } else if(shape.rotation==90 || shape.rotation==-90){\n              shape.freeDistances[i]=shape.freeDistances[i]-distY\n            } else{\n              shape.freeDistances[i]=shape.freeDistances[i]+Math.sign(last_shapex-shape.x)*dist;\n            \n            }\n          }\n         }\n          this.update();\n          this.updateGrp(e, this.selectedShapeId);\n          this.checkIfShapesOnLine(this.selectedShapeId);\n\n          // We now see if freeDistances need to be delete(so if they are bigger than the half of the stickyline);\n          \n        }\n        for(let i=0;i<grp.shapes_g.length;i++){\n            \n          this.updateDragFunc(grp.shapes_g[i],shape);\n\n        }\n      }else if(res.grp_id!='-1'){\n        //this.update();\n        //let layer=e.target.getParent().getLayer();\n        //layer.batchDraw();\n        this.updateAllPosInGrp(res.grp_id);\n        this.updateOccupiedDistance(res.grp_id);\n        e.target.x(e.target.getParent().attrs.shapes_g.find((r)=>r.id===e.target.id()).x);\n        e.target.y(e.target.getParent().attrs.shapes_g.find((r)=>r.id===e.target.id()).y);\n        this.groups.find((r)=>r.id===res.grp_id).shapes_g.find((r)=>r.id===e.target.id()).personalRotation=e.target.rotation()-e.target.getParent().attrs.line.rotation;\n        \n        \n        this.updateAllPosInGrp(res.grp_id);\n        this.checkIfShapesOnLine(res.grp_id);\n        this.updateDragFuncOfCenter();\n      \n      }\n      else{\n        this.update();\n        \n        this.updateDragFuncOfCenter();\n      }\n      this.center.x=e.target.attrs.x;\n      this.center.y=e.target.attrs.y;\n    },\n    \n    handleTransformation(e) {\n      if (e.evt==undefined) {\n        return;\n      }\n      if(this.eraseMode==1){\n        this.eraserAction(e);\n        return;\n      }\n      \n      //If we click on the stage, we have to remove the transformer from the node where it was.\n      if (e.target === e.target.getStage()) {\n        this.selectedShapeId = 'NoId';\n        this.eraseNodefromTransformer(\"lineTransformer\");\n        this.eraseNodefromTransformer(\"shapeTransformer\");\n        this.center.opacity=0;\n        return;\n      }\n\n      // If we click on a transformer, nothing happen.\n      const clickedOnTransformer = e.target.getParent().className === 'Transformer';\n      if (clickedOnTransformer) {\n        return;\n      }\n      \n      const id = e.target.id();\n      let transformer_id;\n      let shape=this.findShape(id).shape_data;\n\n      //if it is a line, we need the transformer dedicated to the line (ie transformer with id=\"lineTransformer\")\n      //if it is a classic shape, we need the transformer dedicated to the shape (ie transformer with id=\"shapeTransformer\")\n      if(e.target.attrs.id==\"center\"){\n        return;\n      }\n      if(e.target.className==\"Line\"){\n        transformer_id=\"lineTransformer\"\n        shape = this.groups.find((r) => r.id === id).line;\n        this.center.draggable=false;\n        this.selectedShapeAlignment=shape.defaultAlignment;\n        this.eraseNodefromTransformer(\"shapeTransformer\");\n      }else{\n        transformer_id=\"shapeTransformer\"\n        this.center.draggable=true;\n        this.selectedShapeAlignment=shape.centerPosition;\n        this.eraseNodefromTransformer(\"lineTransformer\");\n      }\n      \n      if (shape!=undefined) {\n        this.selectedShapeId = id;\n        this.center.opacity=1;\n        this.updateTransformer(transformer_id);\n      } else{\n        /*Only if the center is not selected.\n        When the center is dragged, this function is called.\n        But a shape is actualy selected (the one of the center).\n        */\n        this.selectedShapeId = 'NoId';\n      }\n      //this.updateTransformer(transformer_id);\n      \n      this.updateDragFuncOfCenter()\n    },\n\n    //remove node from transformer with id=transformer_id\n    eraseNodefromTransformer(transformer_id) {\n      let stage= this.$refs.stage.getStage();      \n      const transformerNode = stage.find(\"#\"+transformer_id)[0]; \n      transformerNode.nodes([]);\n    },\n\n    //Update transformer with id=transformer_id\n    //It places the transformer regarding what node is selected\n    updateTransformer(transformer_id) {\n\n      let stage= this.$refs.stage.getStage();\n      const transformerNode = stage.find(\"#\"+transformer_id)[0];\n      let selectedNode;\n      if (transformer_id==\"lineTransformer\"){\n        selectedNode = stage.children[0].getChildren().filter((r)=> r.attrs.className==\"Group\" && r.attrs.id==this.selectedShapeId)[0]\n        .getChildren().filter(r=>r.attrs.className==\"Line\" && r.attrs.id==this.selectedShapeId)[0];\n      }else{\n      selectedNode = stage.children[0].getChildren().filter((r)=>r.attrs.className!=\"Group\" && r.attrs.id==this.selectedShapeId)[0];\n\n      let isFunded=true;\n      if(selectedNode==undefined){\n        isFunded=false;\n      }\n      let i=0;\n      while(!isFunded){\n        if(i<this.groups.length){\n          selectedNode=stage.children[0].getChildren().filter((r)=>r.attrs.className==\"Group\")[i].getChildren().find((r)=>r.attrs.id==this.selectedShapeId && r.attrs.className!=\"Line\");\n        if(selectedNode==undefined){\n          isFunded=false;\n        }else{\n          isFunded=true;\n        }\n        i++;\n        }else{        \n          isFunded=true;\n        }\n      }\n      }\n      /*\n      if (transformer_id==\"lineTransformer\"){\n        selectedNode = stage.children[0].getChildren().filter((r)=> r.attrs.className==\"Group\" && r.attrs.id==this.selectedShapeId)[0]\n        .getChildren().filter(r=>r.attrs.className==\"Line\" && r.attrs.id==this.selectedShapeId)[0];\n      }\n      */\n     \n      //If the selected node has already the transformer on it, nothing happen\n      if (selectedNode === transformerNode.node()) {\n        return;\n      }\n\n      //If a node is selected\n      if (selectedNode!=undefined) {\n        //We attach the transformer to the node\n        transformerNode.nodes([selectedNode]);\n      } else {\n        //if no node is selected, we remove the transformer from its node.\n        transformerNode.nodes([]);\n      }\n      this.center.x=selectedNode.attrs.x;\n      this.center.y=selectedNode.attrs.y;\n      \n    },\n/*\n  DisplayCenterMenu(e){\n    CenterMenu.props.ConcernedShape=e.target;\n   document.getElementById(\"center_menu\").style.display=\"initial\";\n   document.getElementById(\"center_menu\").style.top=e.target.getStage().getPointerPosition().y+8+\"px\";\n  document.getElementById(\"center_menu\").style.left=e.target.getStage().getPointerPosition().x+8+\"px\";\n  },\n  */\n\n  //display context menu according to the target\n  /*\n  DisplayContextMenu(e){\n    e.evt.preventDefault()\n    if (e.target.className!=undefined && e.target.attrs.id!=\"center\"){\n      this.isStageOnlySelected=false;\n      ContextMenu.data().dM='initial';\n      this.$emit('needmenu');\n      this.needMenu=true;\n      ContextMenu.props.ConcernedShape=e.target;\n      if (e.target.attrs.className==\"Line\"){\n        this.isALineSelected=true;\n        this.isAGroupedShapeSelected=true;\n        //We precise the text which depends on the line where we clicked.\n        this.keepDistanceButtonText=e.target.attrs.keepDistanceButtonText;\n      } else if(e.target.getParent().attrs.className==\"Group\"){\n        this.isAGroupedShapeSelected=true;\n      }\n      else{\n        this.isALineSelected=false;\n        this.isAGroupedShapeSelected=false;\n      }\n      document.getElementById(\"active\").style.display=\"initial\";\n      document.getElementById(\"active\").style.top=e.target.getStage().getPointerPosition().y+8+\"px\";\n      document.getElementById(\"active\").style.left=e.target.getStage().getPointerPosition().x +8+\"px\";\n    }\n    if (e.target === e.target.getStage()) {\n      this.needMenu=true;\n      this.isALineSelected=false;\n      this.isAGroupedShapeSelected=false;\n      this.isStageOnlySelected=true;\n      document.getElementById(\"active\").style.display=\"initial\";\n      document.getElementById(\"active\").style.top=e.target.getStage().getPointerPosition().y+8+\"px\";\n      document.getElementById(\"active\").style.left=e.target.getStage().getPointerPosition().x +8+\"px\";\n    \n    }\n  },\n\n  //hide context menu\n  HideContextMenu(){\n    this.needMenu=false;\n    document.getElementById(\"active\").style.display=\"none\";\n    document.getElementById(\"center_menu\").style.display=\"none\";\n  },\n*/\n\n  \n ChangeCenter(e){\n  let res=this.findShape(this.selectedShapeId);\n  let shape=res.shape_data;\n  let threshold1;\n  let threshold2;\n  let dist=this.GiveSignOfDistanceBtwCenterAndShape(e.target.attrs,shape)*Math.sqrt((e.target.y()-(shape.y))**2+(e.target.x()-shape.x)**2)+shape.offsetY*shape.scaleY;\n  \n  //let last_offsetX=shape.offsetX;\n  let last_offsetY=shape.offsetY;\n  if(shape==undefined){\n    shape=this.groups.find((r)=>r.id==this.selectedShapeId).line;\n\n  }else{\n    \n      if(shape.className==\"Rect\") {\n        threshold1=shape.height*shape.scaleY/3;\n        threshold2=shape.height*shape.scaleY*2/3;\n        if(dist>=threshold1 && dist<=threshold2){\n          shape.offsetX=shape.width/2;\n          shape.offsetY=shape.height/2;\n          shape.centerPosition=\"Middle\";\n        }else if(dist>threshold2){\n          shape.offsetX=shape.width/2;\n          shape.offsetY=shape.height;\n          shape.centerPosition=\"Bottom\";\n        }\n        else{\n          shape.offsetX=shape.width/2;\n          shape.offsetY=0;\n          shape.centerPosition=\"Top\";\n        }\n      }\n      else if(shape.className==\"Circle\") {\n        dist=dist+shape.radius*shape.scaleY;\n        threshold1=shape.radius*shape.scaleY*2/3;\n        threshold2=shape.radius*shape.scaleY*4/3;\n        if(dist>=threshold1 && dist<=threshold2){\n          shape.offsetX=0;\n          shape.offsetY=0;\n          shape.centerPosition=\"Middle\";\n        }else if(dist>threshold2){\n          shape.offsetX=0;\n          shape.offsetY=shape.radius;\n          shape.centerPosition=\"Bottom\";\n        }else{\n          shape.offsetX=0;\n          shape.offsetY=-shape.radius;\n          shape.centerPosition=\"Top\";\n        } \n      }\n      else if(shape.className==\"Image\") {\n        threshold1=shape.image.height*shape.scaleY/3;\n        threshold2=shape.image.height*shape.scaleY*2/3;\n        if(dist>=threshold1 && dist<=threshold2){\n          shape.offsetX=shape.image.width/2;\n          shape.offsetY=shape.image.height/2;\n          shape.centerPosition=\"Middle\";\n        }else if(dist>threshold2){\n          shape.offsetX=shape.image.width/2;\n          shape.offsetY=shape.image.height;\n          shape.centerPosition=\"Bottom\";\n        }\n        else {\n          shape.offsetX=shape.image.width/2;\n          shape.offsetY=0;\n          shape.centerPosition=\"Top\";\n        }\n      }\n      else if(shape.className==\"Text\") {\n        threshold1=shape.length_y*shape.scaleY/3;\n        threshold2=shape.length_y*shape.scaleY*2/3;\n        if(dist>=threshold1 && dist<=threshold2){\n          shape.offsetX=shape.length_x/2;\n          shape.offsetY=shape.length_y/2;\n          shape.centerPosition=\"Middle\";\n        }else if(dist>threshold2){\n          shape.offsetX=shape.length_x/2;\n          shape.offsetY=shape.length_y;\n          shape.centerPosition=\"Bottom\";\n        }\n        else{\n          shape.offsetX=shape.length_x/2;\n          shape.offsetY=0;\n          shape.centerPosition=\"Top\";\n        }\n      }\n      else if(shape.className==\"Triangle\") {\n        dist=dist+shape.radius*shape.scaleY;\n        threshold1=shape.radius*shape.scaleY/2;\n        threshold2=shape.radius*shape.scaleY*5/4;\n        if(dist>=threshold1 && dist<=threshold2){\n          shape.offsetX=0;\n          shape.offsetY=0;\n        }else if(dist>threshold2){\n          shape.offsetX=0;\n          shape.offsetY=shape.radius/2\n          shape.centerPosition=\"Bottom\";\n        }\n        else{\n          shape.offsetX=0;\n          shape.offsetY=-shape.radius;\n          shape.centerPosition=\"Top\";\n        }\n      }\n      shape.y=shape.y-(last_offsetY-shape.offsetY)*shape.scaleY*Math.cos(shape.rotation*(Math.PI/180));\n      shape.x=shape.x+(last_offsetY-shape.offsetY)*shape.scaleY*Math.sin(shape.rotation*(Math.PI/180));\n      this.selectedShapeAlignment=shape.centerPosition;\n\n      if (res.grp_id!='-1'){\n        this.updateAllPosInGrp(res.grp_id);\n      }\n        \n      e.target.x(shape.x);\n      e.target.y(shape.y);\n\n     \n\n      \n  }\n  },\n  /*\n  ChangeAlignCenter(align_choice){\n    let center=CenterMenu.props.ConcernedShape;\n    let grp=this.groups.find((r)=>r.id===this.selectedShapeId);\n    let shape;\n    if(grp!=undefined){\n      for(let i=0;i<grp.shapes_g.length;i++){\n        this.ChangeCenterRegardingCommand(grp.shapes_g[i].id,align_choice)\n      }\n      center.x(grp.line.x);\n      center.y(grp.line.y);\n      if(grp.line.defaultAlignment==align_choice){\n        grp.line.defaultAlignment='' //If we select again the same alogn_choice, we deselect it, no alignement center is fixed.\n      }else{\n        grp.line.defaultAlignment=align_choice;\n      }\n      this.selectedShapeAlignment=grp.line.defaultAlignment;\n    }else{\n      shape=this.findShape(this.selectedShapeId).shape_data;\n      this.ChangeCenterRegardingCommand(shape.id,align_choice)\n      this.selectedShapeAlignment=shape.centerPosition;\n      center.x(shape.x);\n      center.y(shape.y);\n    }\n  },\n  */\n  //Allow to change the center regarding a text command (Top,Middle or Bottom)\n  ChangeCenterRegardingCommand(shape_id,command){\n    let res=this.findShape(shape_id);\n    let shape=res.shape_data;\n    let last_offsetY=shape.offsetY;\n    if(shape.className==\"Rect\" ){\n      if(command==\"Top\"){\n        shape.offsetY=0;\n        shape.offsetX=shape.width/2;\n      }\n      else if(command==\"Middle\"){\n          shape.offsetX=shape.width/2;\n          shape.offsetY=shape.height/2;\n      }else if(command==\"Bottom\"){\n            shape.offsetX=shape.width/2;\n            shape.offsetY=shape.height;\n      }\n    }\n      else if(shape.className==\"Circle\") {\n        if(command==\"Top\"){\n          shape.offsetX=0;\n          shape.offsetY=-shape.radius;\n        }else if(command==\"Middle\"){\n          shape.offsetX=0;\n          shape.offsetY=0\n        }else if(command==\"Bottom\"){\n          shape.offsetX=0;\n          shape.offsetY=shape.radius;\n        } \n      }\n      else if(shape.className==\"Image\") {\n        if(command==\"Middle\"){\n          shape.offsetX=shape.image.width/2;\n          shape.offsetY=shape.image.height/2;\n        }else if(command==\"Bottom\"){\n          shape.offsetX=shape.image.width/2;\n          shape.offsetY=shape.image.height;\n        }\n        else if (command==\"Top\"){\n          shape.offsetX=shape.image.width/2;\n          shape.offsetY=0;\n        }\n      }\n      else if(shape.className==\"Text\") {\n        if(command==\"Middle\"){\n          shape.offsetX=shape.length_x/2;\n          shape.offsetY=shape.length_y/2;\n        }else if(command==\"Bottom\"){\n          shape.offsetX=shape.length_x/2;\n          shape.offsetY=shape.length_y;\n        }\n        else if(command==\"Top\"){\n          shape.offsetX=shape.length_x/2;\n          shape.offsetY=0;\n        }\n      }\n      else if(shape.className==\"Triangle\") {\n        if(command==\"Middle\"){\n          shape.offsetX=0;\n          shape.offsetY=0;\n        }else if(command==\"Bottom\"){\n          shape.offsetX=0;\n          shape.offsetY=shape.radius/2;\n        }\n        else if(command==\"Top\"){\n          shape.offsetX=0;\n          shape.offsetY=-shape.radius;\n        }\n      }\n      shape.centerPosition=command;\n      shape.y=shape.y-(last_offsetY-shape.offsetY)*shape.scaleY*Math.cos(shape.rotation*(Math.PI/180));\n      shape.x=shape.x+(last_offsetY-shape.offsetY)*shape.scaleY*Math.sin(shape.rotation*(Math.PI/180));\n\n      if (res.grp_id!='-1'){\n        this.updateAllPosInGrp(res.grp_id);\n      }\n        \n      //center.x(shape.x);\n      //center.y(shape.y);\n  },\n  updateDragFuncOfCenter(){\n    let shape=this.findShape(this.selectedShapeId).shape_data\n    let center=this.center;\n    let angle=shape.rotation*(Math.PI/180);\n    if(angle>=-Math.PI/2 && angle<=0){\n      angle-=90*(Math.PI/180);\n    }else if(angle<-Math.PI/2){\n      angle+=(Math.PI/2);\n      angle=Math.PI+angle;\n    } else if(angle<=Math.PI && angle>0){\n      angle-=90*(Math.PI/180);\n    } \n    if (angle<=0 && angle>=-Math.PI/4){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x +(pos.x-shape.x)*Math.cos(angle),\n          y: shape.y+(pos.x-shape.x)*Math.sin(angle),\n        };\n      }\n    } else if (angle<-Math.PI/4 && angle>=-Math.PI/2){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x-(pos.y-shape.y)*Math.cos(angle),\n          y: shape.y-(pos.y-shape.y)*Math.sin(angle),\n        };\n      }\n    }\n    else if (angle<-Math.PI/2 && angle>=-3*Math.PI/4){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x-(pos.y-shape.y)*Math.cos(angle),\n          y: shape.y-(pos.y-shape.y)*Math.sin(angle),\n        };\n      }\n    } else if (angle<-3*Math.PI/4 && angle>=-Math.PI){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x-(pos.x-shape.x)*Math.cos(angle),\n          y: shape.y-(pos.x-shape.x)*Math.sin(angle),\n        };\n      }\n    }else if (angle<=Math.PI && angle>=3*Math.PI/4){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x-(pos.x-shape.x)*Math.cos(angle),\n          y: shape.y-(pos.x-shape.x)*Math.sin(angle),\n        };\n      }\n    } else if (angle<3*Math.PI/4 && angle>=Math.PI/2){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x+(pos.y-shape.y)*Math.cos(angle),\n          y: shape.y+(pos.y-shape.y)*Math.sin(angle),\n        };\n      }\n    } else if (angle<Math.PI/2 && angle>=Math.PI/4){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x+(pos.y-shape.y)*Math.cos(angle),\n          y: shape.y+(pos.y-shape.y)*Math.sin(angle),\n        };\n      }\n    }else if (angle<Math.PI/4 && angle>=0){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x+(pos.x-shape.x)*Math.cos(angle),\n          y: shape.y+(pos.x-shape.x)*Math.sin(angle),\n        };\n      }\n    }\n  },\n  MovingCenter(){\n    //let shape=this.findShape(this.selectedShapeId)\n    //console.log(e.target)\n  },\n  /*\n  //called when the \"Change Center\" button is clicked\n  ChangeCenterButtonAction(){\n      let shape= ContextMenu.props.ConcernedShape;\n      if(shape.attrs.className==\"Line\"){\n        let shapes_g=shape.getParent().attrs.shapes_g //the list of the shapes which are on the line is in the corresponding group.\n        for (let j=0;j<shapes_g.length;j++){\n          this.ChangeCenter(shapes_g[j]);\n        }\n      }else{\n        let shape_data=this.shapes.find(i => i.id ===shape.attrs.id);\n        let isFunded=true;\n        if(shape_data==undefined){\n          isFunded=false;\n        }\n        let i=0;\n        while(!isFunded){\n          if(i<this.groups.length){\n            shape_data=this.groups[i].shapes_g.find(i => i.id === shape.attrs.id);\n          if(shape_data==undefined){\n            isFunded=false;\n          }else{\n            isFunded=true;\n          }\n          i++;\n          }else{        \n            isFunded=true;\n          }\n        }\n        this.ChangeCenter(shape_data)\n      }\n    },\n    */\n    \n    //allow to copy a target\n    /*\n    Copy(){\n      ContextMenu.props.CopiedShape=ContextMenu.props.ConcernedShape;\n      ContextMenu.props.pastOneObject=true;\n    },\n    CopyAll(){\n      ContextMenu.props.CopiedShape=ContextMenu.props.ConcernedShape;\n      ContextMenu.props.pastOneObject=false;\n    },\n    Past(){   \n      //Prevent error when no shape is copied\n      if(ContextMenu.props.CopiedShape.attrs==undefined){\n        return;\n      }\n      let clone=ContextMenu.props.CopiedShape.clone({\n        id: ''+this.max_id_figures,\n      })\n      //let layer=ContextMenu.props.CopiedShape.getLayer();\n      let i= this.groups.length\n      //let new_id=i+1;\n      if(ContextMenu.props.CopiedShape.attrs.className==\"Line\"){\n        this.max_id_figures=this.max_id_figures+1;\n        if(!ContextMenu.props.pastOneObject){\n          //let i= this.groups.length;\n          //let new_id=i+1;\n        \n          clone=ContextMenu.props.CopiedShape.getParent().clone({\n            id: ''+ this.max_id_figures,\n            name: \"group\"+this.max_id_figures,\n            shapes_g:[],\n          })\n          clone.attrs.line.id=''+this.max_id_figures;\n          clone.attrs.line.x=ContextMenu.props.ConcernedShape.getStage().getPointerPosition().x;\n          clone.attrs.line.y=ContextMenu.props.ConcernedShape.getStage().getPointerPosition().y;\n          let positionPoints=Object.assign([],clone.attrs.line.positionPoints);\n            let length=positionPoints.length;\n            clone.attrs.line.positionPoints=[];\n            for(let i=0;i<length.valueOf();i++){\n              let clone_positionPoint=ContextMenu.props.CopiedShape.getParent().getChildren().find((r)=>r.attrs.id===positionPoints[i].id).clone({\n              id:'positionPoint'+clone.attrs.line.id+i,\n              });\n              clone.attrs.line.positionPoints.push(clone_positionPoint.attrs,);\n            }\n          \n          //layer= ContextMenu.props.CopiedShape.getParent().getLayer();\n          this.groups.push(clone.attrs,);\n          let shapesg=this.groups[this.groups.indexOf(this.groups.find((r)=> r.id==ContextMenu.props.CopiedShape.getParent().attrs.id))].shapes_g;\n          let shapesg_length=shapesg.length;\n          for (let j=0; j<shapesg_length;j++){\n            this.max_id_figures=this.max_id_figures + 1;\n            let clone_shape=ContextMenu.props.CopiedShape.getParent().getChildren().find((r)=>r.attrs.id===shapesg[j].id).clone({\n              id:''+this.max_id_figures,\n            });\n           // this.updateDragFunc(clone_shape,clone_line);\n            this.groups[i].shapes_g.push(clone_shape.attrs,);\n            this.updateDragFunc(this.groups[i].shapes_g[this.groups[i].shapes_g.length-1],this.groups[i].line);\n          }\n          this.updateAllPosInGrp(clone.attrs.id);\n        }else{\n          //let i= this.groups.length;\n          //let new_id=i+1;\n        \n          clone=ContextMenu.props.CopiedShape.getParent().clone({\n            id: ''+this.max_id_figures,\n            name: \"group\"+this.max_id_figures,\n            shapes_g:[],\n          })\n          clone.attrs.line.id=''+this.max_id_figures;\n          clone.attrs.line.x=ContextMenu.props.ConcernedShape.getStage().getPointerPosition().x;\n          clone.attrs.line.y=ContextMenu.props.ConcernedShape.getStage().getPointerPosition().y;\n          for(let j=0;j<clone.attrs.line.occupiedDistances.length;j++){\n            clone.attrs.line.freeDistances.push(clone.attrs.line.occupiedDistances[j],);\n          }\n          clone.attrs.line.occupiedDistances=[];\n          if(clone.attrs.line.keepDistribution!=1){\n            let positionPoints=Object.assign([],clone.attrs.line.positionPoints);\n            let length=positionPoints.length;\n            clone.attrs.line.positionPoints=[];\n            for(let i=0;i<length.valueOf();i++){\n              let clone_positionPoint=ContextMenu.props.CopiedShape.getParent().getChildren().find((r)=>r.attrs.id===positionPoints[i].id).clone({\n              id:'positionPoint'+clone.attrs.line.id+i,\n              });\n              clone.attrs.line.positionPoints.push(clone_positionPoint.attrs,);\n            }\n          }\n          //layer= ContextMenu.props.CopiedShape.getParent().getLayer();\n          this.groups.push(clone.attrs,)\n        }\n        //In order to actualize the new line (in particular to show the positionPoints):\n        this.updateAllPosInGrp(clone.attrs.id)\n      } \n      else{\n        this.max_id_figures=this.max_id_figures + 1;\n        clone=ContextMenu.props.CopiedShape.clone({\n          id: ''+this.max_id_figures,  \n          x:ContextMenu.props.ConcernedShape.getStage().getPointerPosition().x,\n          y:ContextMenu.props.ConcernedShape.getStage().getPointerPosition().y,\n        });\n        clone.attrs.dragBoundFunc=function (pos) {\n          return {\n            x: pos.x,\n            y: pos.y,\n          };\n        };\n        clone.attrs.isGrouped=0;\n        this.shapes.push(clone.attrs,); \n         \n      }\n      //layer.batchDraw(); \n      \n    },\n    //RemoveShape(shape)\n    Remove(shape){\n      //let shape=ContextMenu.props.ConcernedShape;\n      if(shape.attrs.className==\"Line\"){\n        let grp=this.groups.find((r)=>r.id===shape.attrs.id);\n        const length=grp.shapes_g.length;\n        for(let i=0;i<length;i++){\n          grp.shapes_g[i].dragBoundFunc= dragFunc;\n          grp.shapes_g[i].isGrouped=0;\n          this.shapes.push(grp.shapes_g[i],);\n        }\n        this.eraseNodefromTransformer(\"lineTransformer\");\n        this.groups.splice(this.groups.indexOf(grp),1);\n        shape.getParent().destroy();\n\n        //We give to the circle (representing center of shapes) a default position\n        if(this.groups[0]!=undefined){\n          this.center.x=this.groups[0].line.x;\n          this.center.y=this.groups[0].line.y;\n        } else if(this.shapes[0]!=undefined){\n          this.center.x=this.shapes[0].x;\n          this.center.y=this.shapes[0].y;\n        }\n        this.center.opacity=0;\n        \n      }else if(shape.attrs.className==\"positionPoint\"){\n        let line=shape.getParent().attrs.line;\n        let target_positionPoint=line.positionPoints.find((r)=>r.id===shape.attrs.id);\n        let index=line.freeDistances.indexOf(shape.attrs.distance_to_line_center);\n        console.log(line.positionPoints);\n        if(line.keepDistribution!=1 && index!=-1){\n          line.freeDistances.splice(index,1);\n          line.positionPoints.splice(line.positionPoints.indexOf(target_positionPoint),1)\n        }\n      }\n      else{\n        let res=this.findShape(shape.attrs.id)\n        let shape_data=res.shape_data;\n        let grp_id=res.grp_id;\n        if(shape_data!=undefined){\n        if(grp_id!='-1'){\n        //let shape_data=this.shapes.find(i => i.id ===shape.attrs.id);\n        let grp=this.groups.find((r)=>r.id===grp_id);\n          grp.line.freeDistances.push(grp.line.occupiedDistances[grp.shapes_g.indexOf(shape_data)],)\n          grp.line.occupiedDistances.splice(grp.shapes_g.indexOf(shape_data),1)\n          \n          grp.shapes_g.splice(grp.shapes_g.indexOf(shape_data),1);\n          this.updateOccupiedDistance(grp.id);\n          \n          this.updateAllPosInGrp(grp.id);\n          \n         console.log(grp.line.positionPoints)\n      \n        } else{\n          this.eraseNodefromTransformer(\"shapeTransformer\");\n          this.shapes.splice(this.shapes.indexOf(shape_data),1);\n          //We give to the circle (representing center of shapes) a default position\n          if(this.groups[0]!=undefined){\n            this.center.x=this.groups[0].line.x;\n            this.center.y=this.groups[0].line.y;\n          } else if(this.shapes[0]!=undefined){\n            this.center.x=this.shapes[0].x;\n            this.center.y=this.shapes[0].y;\n          }\n          this.center.opacity=0;\n        }\n        shape.destroy();\n        }\n      }\n    },\n\n    RemoveAll(){\n      let shape=ContextMenu.props.ConcernedShape;\n      if(shape.className==\"Line\"){\n        let grp=this.groups.find((r)=>r.id===shape.attrs.id);\n        while(grp.shapes_g.length!=0){\n          grp.shapes_g[0].dragBoundFunc= dragFunc;\n          grp.shapes_g.splice(0,1);\n        }\n        this.eraseNodefromTransformer(\"lineTransformer\");\n        this.groups.splice(this.groups.indexOf(grp),1);\n        shape.getParent().destroy();\n\n        //We give to the circle (representing center of shapes) a default position\n        if(this.groups[0]!=undefined){\n          this.center.x=this.groups[0].line.x;\n          this.center.y=this.groups[0].line.y;\n        } else if(this.shapes[0]!=undefined){\n          this.center.x=this.shapes[0].x;\n          this.center.y=this.shapes[0].y;\n        }\n        \n      }else{\n        return;\n      }\n    },\n    */\n\n    findShape(id){\n      let shape_data=this.shapes.find(i => i.id ===id);\n      let grp_id='-1'; // return grp_id=-1 if the shape doesn't belong to attached group.\n      let isFunded=true;\n      if(shape_data==undefined){\n        isFunded=false;\n      }\n      let i=0;\n      while(!isFunded){\n        if(i<this.groups.length){\n          shape_data=this.groups[i].shapes_g.find(i => i.id === id);\n        if(shape_data==undefined){\n          isFunded=false;\n        }else{\n          grp_id=this.groups[i].id; \n          isFunded=true;\n        }\n        i++;\n        }else{        \n          isFunded=true;\n        }\n      }\n      return {shape_data, grp_id}\n    },\n\n    //detach a shape from its line.\n     DetachShape(shape,target_x,target_y){\n      \n      \n      const added_distance=this.lengthToCapture+5;\n      let grp=this.groups.find((r)=>r.shapes_g.indexOf(shape)!=-1);\n      let i=grp.shapes_g.indexOf(shape);\n      \n      shape.dragBoundFunc= dragFunc;\n\n      let coord_y1=grp.line.y-grp.line.points[4]*(1/2)*grp.line.scaleX*Math.sin(grp.line.rotation*(Math.PI/180));\n      let coord_x2=grp.line.x+grp.line.points[4]*(1/2)*grp.line.scaleX*Math.cos(grp.line.rotation*(Math.PI/180));\n      let coord_y2= grp.line.y+grp.line.points[4]*(1/2)*grp.line.scaleX*Math.sin(grp.line.rotation*(Math.PI/180));\n      let coord_x1=grp.line.x-grp.line.points[4]*(1/2)*grp.line.scaleX*Math.cos(grp.line.rotation*(Math.PI/180));\n      let a=(coord_y2-coord_y1)/(coord_x2-coord_x1);\n      //let b=grp.line.y-a*grp.line.x;\n      let b=shape.x*(1/a)+shape.y;\n      if (grp.line.rotation<0 && grp.line.rotation>-45){\n        \n        shape.x=shape.x+Math.sign(shape.y-target_y)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } else if (grp.line.rotation<=-45 && grp.line.rotation>-90){\n        \n        shape.x=shape.x+Math.sign(shape.x-target_x)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      }\n      \n      else if(grp.line.rotation<-90 && grp.line.rotation>-135){\n        shape.x=shape.x+Math.sign(shape.x-target_x)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } \n      else if(grp.line.rotation<=-135 && grp.line.rotation>-180){\n        shape.x=shape.x-Math.sign(shape.y-target_y)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } \n      \n      else if( grp.line.rotation>135 && grp.line.rotation<180){\n        \n        shape.x=shape.x-Math.sign(shape.y-target_y)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } else if( grp.line.rotation>90 && grp.line.rotation<=135){\n        \n        shape.x=shape.x-Math.sign(shape.x-target_x)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } else if( grp.line.rotation>45 && grp.line.rotation<=90){\n        \n        shape.x=shape.x-Math.sign(shape.x-target_x)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } else if( grp.line.rotation>0 && grp.line.rotation<=45){\n        \n        shape.x=shape.x+Math.sign(shape.y-target_y)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } \n      else if(grp.line.rotation==-90){\n        shape.x=shape.x-Math.sign(shape.x-target_x)*added_distance\n      } else if(grp.line.rotation==90){\n        shape.x=shape.x+Math.sign(shape.x-target_x)*added_distance\n      } else if(grp.line.rotation==180 || grp.line.rotation==-180){\n        shape.y=shape.y-Math.sign(shape.y-target_y)*added_distance\n      } else if(grp.line.rotation==0){\n        shape.y=shape.y-Math.sign(shape.y-target_y)*added_distance\n      } \n      //shape.rotation=shape.rotation+shape.personalRotation;\n      shape.isGrouped=0;\n      this.shapes.push(shape,)\n      this.center.x=shape.x;\n      this.center.y=shape.y;\n      grp.line.freeDistances.push(grp.line.occupiedDistances[i]);\n      grp.line.occupiedDistances.splice(i,1);\n      grp.shapes_g.splice(i,1);\n      grp.line.positionPoints.splice(i,1)\n      \n      this.updateOccupiedDistance(grp.id)\n      this.updateAllPosInGrp(grp.id)\n      this.updateNaration(grp)\n      this.eraseNodefromTransformer(\"shapeTransformer\");\n    \n    },\n    /*\n    DetachShape(shape){\n      \n      \n      const added_distance=this.lengthToCapture+5;\n      let grp=this.groups.find((r)=>r.shapes_g.indexOf(shape)!=-1);\n      let i=grp.shapes_g.indexOf(shape);\n      \n      shape.dragBoundFunc= dragFunc;\n\n      let coord_y1=grp.line.y-grp.line.points[4]*(1/2)*grp.line.scaleX*Math.sin(grp.line.rotation*(Math.PI/180));\n      let coord_x2=grp.line.x+grp.line.points[4]*(1/2)*grp.line.scaleX*Math.cos(grp.line.rotation*(Math.PI/180));\n      let coord_y2= grp.line.y+grp.line.points[4]*(1/2)*grp.line.scaleX*Math.sin(grp.line.rotation*(Math.PI/180));\n      let coord_x1=grp.line.x-grp.line.points[4]*(1/2)*grp.line.scaleX*Math.cos(grp.line.rotation*(Math.PI/180));\n      let a=(coord_y2-coord_y1)/(coord_x2-coord_x1);\n      //let b=grp.line.y-a*grp.line.x;\n      let b=shape.x*(1/a)+shape.y;\n      if (grp.line.rotation<0 && grp.line.rotation>-90){\n        \n        shape.x=shape.x-added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } else if(grp.line.rotation<-90){\n        shape.x=shape.x-added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } else if( grp.line.rotation>0 && grp.line.rotation<180){\n        \n        shape.x=shape.x+added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } \n      else if(grp.line.rotation==-90){\n        shape.x=shape.x+added_distance\n      } else if(grp.line.rotation==90){\n        shape.x=shape.x-added_distance\n      } else if(grp.line.rotation==180 || grp.line.rotation==-180){\n        shape.y=shape.y-added_distance\n      } else if(grp.line.rotation==0){\n        shape.y=shape.y+added_distance\n      } \n      //shape.rotation=shape.rotation+shape.personalRotation;\n      shape.isGrouped=0;\n      this.shapes.push(shape,)\n      this.center.x=shape.x;\n      this.center.y=shape.y;\n      grp.line.freeDistances.push(grp.line.occupiedDistances[i]);\n      grp.line.occupiedDistances.splice(i,1);\n      grp.shapes_g.splice(i,1);\n      if(grp.line.keepDistribution){\n        grp.line.positionPoints.splice(i,1)\n      }\n      this.updateOccupiedDistance(grp.id)\n      this.updateAllPosInGrp(grp.id)\n    \n    },\n    */\n    /*\n\n    //called when the button \"Detach Shape\" is clicked\n    DetachShapeButtonAction(){\n      let shape= ContextMenu.props.ConcernedShape;\n      if(shape.attrs.className==\"Line\"){\n        let shapes_g=shape.getParent().attrs.shapes_g;\n        while(shapes_g.length!=0){\n          this.DetachShape(shapes_g[0]);\n        }\n      }else{\n        let shape_data=this.shapes.find(i => i.id ===shape.attrs.id);\n        let isFunded=true;\n        if(shape_data==undefined){\n          isFunded=false;\n        }\n        let i=0;\n        while(!isFunded){\n          if(i<this.groups.length){\n            shape_data=this.groups[i].shapes_g.find(i => i.id === shape.attrs.id);\n          if(shape_data==undefined){\n            isFunded=false;\n          }else{\n            isFunded=true;\n          }\n          i++;\n          }else{        \n            isFunded=true;\n          }\n        }\n        this.DetachShape(shape_data)\n      }\n    },\n\n    //called when the button \"keep/liberate distribution\" is clicked.\n    KeepDistribution(){\n      let grp=this.groups.find(i => i.id === ContextMenu.props.ConcernedShape.attrs.id);\n      let line=grp.line;\n      if(line==undefined){\n        return;\n      }else{\n        if(line.keepDistribution){\n          line.keepDistribution=false;\n          for (let i=0;i<grp.shapes_g.length;i++){\n            grp.shapes_g[i].distance_to_line_center=line.occupiedDistances[i]\n          }\n          line.freeDistances=[];\n\n          line.stroke='blue'\n          grp.line.keepDistanceButtonText=\"Keep Distribution\";\n          //ContextMenu.props.ConcernedShape.attrs.keepDistanceButtonText=\"Keep Distribution\";\n        }else{\n          line.keepDistribution=true;\n          for (let i=0;i<grp.shapes_g.length;i++){\n            line.occupiedDistances[i]=grp.shapes_g[i].distance_to_line_center;\n          }\n          line.stroke='black'\n          grp.line.keepDistanceButtonText=\"Liberate Distribution\";\n          //ContextMenu.props.ConcernedShape.attrs.keepDistanceButtonText=\"Liberate Distribution\";\n          this.updateOccupiedDistance(line.id);\n          this.updateAllPosInGrp(line.id);\n        }\n      }\n    },\n    */\n    createNewShape(shape){\n      if(shape.attrs.className==\"Line\"){\n        \n        this.max_id_figures=this.max_id_figures+1;\n\n          let clone=shape.getParent().clone({\n            id: ''+this.max_id_figures,\n            name: \"group\"+this.max_id_figures,\n            shapes_g:[],\n          })\n          clone.attrs.line.id=''+this.max_id_figures;\n          clone.attrs.line.x=shape.getStage().getPointerPosition().x;\n          clone.attrs.line.y=shape.getStage().getPointerPosition().y;\n          clone.attrs.line.draggable=true;\n          this.groups.push(clone.attrs,)\n          \n        \n      }else{\n        \n        this.max_id_figures=this.max_id_figures+1\n        let clone=shape.clone({\n          id: ''+this.max_id_figures,\n          draggable: true,\n        })\n        clone.attrs.isGrouped=0;\n        this.shapes.push(clone.attrs,);\n      }\n      \n\n    },\n    \n  \n  eraserAction(e){\n    this.Remove(e.target);\n    \n  },\n  unshowSelectedShape(e){\n    if(e.target.attrs.className==\"Line\" && this.eraseMode==0){\n      e.target.opacity(0.5)\n    }\n    else if(e.target.attrs.className==\"Line\" && this.eraseMode==1){\n      if(e.target.attrs.keepDistribution==1){\n        e.target.stroke(\"rgb(48,48,48)\")\n      }else{\n        e.target.stroke(\"blue\")\n      }\n    }\n    else if(e.target.attrs.className==\"positionPoint\" && this.eraseMode==1){\n      if(e.target.getParent().attrs.line.keepDistribution!=1){\n        e.target.strokeWidth(0)\n      }\n    }\n    else if(this.eraseMode==1){\n      e.target.strokeWidth(0)\n    }\n  },\n  showSelectedShape(e){\n    if(e.target.attrs.className==\"Line\" && this.eraseMode==0){\n      e.target.opacity(1)\n    }\n    else if(e.target.attrs.className==\"Line\" && this.eraseMode==1){\n      e.target.stroke('rgb(200, 59, 218)')\n    }\n    else if(e.target.attrs.className==\"positionPoint\" && this.eraseMode==1){\n      let line=e.target.getParent().attrs.line;\n      if(line.freeDistances.indexOf(e.target.attrs.distance_to_line_center)!=-1){\n        if(line.keepDistribution!=1){\n          e.target.stroke('rgb(200, 59, 218)')\n          e.target.strokeWidth(3)\n        }\n      }\n    }\n    else if(this.eraseMode==1){\n      e.target.stroke('rgb(200, 59, 218)')\n      e.target.strokeWidth(3)\n    }\n    /*\n    let shape=e.target;\n    if(this.eraseMode==1){\n    let shape_data=this.shapes.find(i => i.id ===shape.attrs.id);\n    let isFunded=true;\n    if(shape_data==undefined){\n      isFunded=false;\n      let i=0;\n      while(!isFunded){\n        if(i<this.groups.length){\n          shape_data=this.groups[i].shapes_g.find(i => i.id === shape.attrs.id);\n        if(shape_data==undefined){\n          isFunded=false;\n          i++;\n        }else{\n          isFunded=true;\n        }\n        }else{        \n          isFunded=true;\n        }\n      }\n    }\n    if (shape_data!=undefined){\n      shape_data.opacity=0.3\n    }\n    */\n\n  },\n  editText(e){\n    //let valuey=document.getElementById(\"stage\").style.top+e.target.y()\n    //let valuex=document.getElementById(\"stage\").style.left+e.target.x()\n    let stageBox=e.target.getStage().attrs.container.getBoundingClientRect();\n    document.getElementById(\"input2\").style.top=stageBox.y+e.target.getAbsolutePosition().y-document.getElementById(\"input1\").size*2.5+'px';\n    document.getElementById(\"input2\").style.left=stageBox.x+e.target.getAbsolutePosition().x-document.getElementById(\"input2\").size*5+'px';\n    document.getElementById(\"input2\").style.display=\"initial\"\n    this.editedText=e.target\n  },\n  updateText(e){\n    let shape=this.shapes.find(i => i.id ===this.editedText.attrs.id);\n    let isFunded=true;\n    if(shape==undefined){\n      isFunded=false;\n    }\n    let i=0;\n    while(!isFunded){\n      if(i<this.groups.length){\n        shape=this.groups[i].shapes_g.find(i => i.id === this.editedText.attrs.id);\n      if(shape==undefined){\n        isFunded=false;\n      }else{\n        isFunded=true;\n      }\n      i++;\n      }else{        \n        isFunded=true;\n      }\n    }\n    if(shape!=undefined){\n    let last_width;\n    let last_height;\n    let diff_width;\n    let diff_height;\n\n    last_width=this.editedText.width();\n    last_height=this.editedText.height();\n\n    shape.text=e.target.value;\n\n    this.editedText.text(e.target.value);\n    diff_width=this.editedText.width()-last_width;\n    diff_height=this.editedText.height()-last_height;\n\n    \n    shape.offsetX=shape.offsetX+diff_width/2\n    shape.offsetY=shape.offsetY+diff_height/2\n    shape.length_x=this.editedText.width()\n    shape.length_y=this.editedText.height()\n    document.getElementById(\"input2\").style.display=\"none\"\n    }\n\n  },\n  updateNaration(grp){\n      let text=\"<strong>Substrate:</strong><br>\"\n      text=text+\"- <mark class='grey'> StickyLine </mark><br>\";\n      text=text+\"Relation: <i>alignement and distribution with</i>:\";\n      for(let j=0;j<grp.shapes_g.length;j++){\n        text=text+\"<br>\"+\"- \"+grp.shapes_g[j].className\n      }\n      this.$emit('explain',{origin:\"Substrate - Polymorphism<br><mark class='grey'> The Stickyline preserves various relationships. </mark>\",text:text});\n  }\n},\n};\n\n</script>\n<style>\n#playground{\n  cursor: default\n}\n#active{\n  position: absolute;\n  display: none;\n  top: 0px;\n  left: 0px;\n  width: 60px;\n  background-color: white;\n  box-shadow: 0 0 5px grey;\n  border-radius: 3px;\n}\n#center_menu{\n  position: absolute;\n  display: none;\n  top: 0px;\n  left: 0px;\n  width: 60px;\n  background-color: white;\n  box-shadow: 0 0 5px grey;\n  border-radius: 3px;\n}\ninput2{\n  position:absolute;\n  display: none;\n  top:0px;\n  left:0px; \n  z-index:2;\n}\n</style> ","import { render } from \"./PolymorphismSubstrateDemo.vue?vue&type=template&id=ee70aa5a\"\nimport script from \"./PolymorphismSubstrateDemo.vue?vue&type=script&lang=js\"\nexport * from \"./PolymorphismSubstrateDemo.vue?vue&type=script&lang=js\"\n\nimport \"./PolymorphismSubstrateDemo.vue?vue&type=style&index=0&id=ee70aa5a&lang=css\"\n\nimport exportComponent from \"/Users/junhangyu/Desktop/PE code/github/teachingApp/node_modules/vue-loader/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render]])\n\nexport default __exports__","<template>\n\n<div @click=\"HideContextMenu\" id=\"ReuseSubstrateDemo\"\n @focus=\"initialNaration(this.groups)\"\n@focusout=\"this.narationHasBeenInitialized=false\"\ntabindex=\"0\">\n<!--\n  <ToolBar :height=\"100\" :width=\"400\"\n  @need_new_shape=\"createNewShape\" @eraser_is_selected=\"switchEraseMode\"></ToolBar>\n  -->\n  <v-stage\n    ref=\"stage\"\n    id=\"stage\"\n    :config=\"stageSize\"\n    @dragmove=\"update\"\n    @mousedown=\"handleTransformation\"\n    @touchstart=\"handleTransformation\"\n    @fusion=\"makeGroup\"\n    @contextMenu=\"DisplayContextMenu\"\n  >\n    <v-layer ref=\"layer\">\n      <!--\n        see if a group should contain more than one line\n      -->\n      <!--\n      <v-circle :key=\"center.id\" :config=\"center\"/>\n      -->\n      <v-group ref=\"groups\" v-for=\"step in groups\" :key=\"step.id\" :config=\"step\">\n      \n      \n      \n        <v-rect\n        v-for=\"item in step.shapes_g.filter(i=>i.className=='Rect')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        \n       \n        @transformend=\"updateTransformedShape\"\n        @dragend= \"updatePosInGrp($event,step.id) \"\n        @dragmove=\"CheckIfNeedToDetach\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n      />\n      <v-circle\n        v-for=\"item in step.shapes_g.filter(i=>i.className=='Circle')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragend=\"updatePosInGrp($event,step.id)\"\n        @dragmove=\"CheckIfNeedToDetach\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n      />\n      \n      <v-image\n        v-for=\"item in step.shapes_g.filter(i=>i.className=='Image')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragend=\"updatePosInGrp($event,step.id)\"\n        @dragmove=\"CheckIfNeedToDetach\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n      />\n      <v-text\n        v-for=\"item in step.shapes_g.filter(i=>i.className=='Text')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragend=\"updatePosInGrp($event,step.id)\"\n        @dragmove=\"CheckIfNeedToDetach\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n\n        @dblclick=\"editText\"\n        />\n        <v-regular-polygon\n        v-for=\"item in step.shapes_g.filter(i=>i.className=='Triangle')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragend=\"updatePosInGrp($event,step.id)\"\n        @dragmove=\"CheckIfNeedToDetach\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n      />\n        <v-line \n        :key=\"step.line.id\"\n        :config=\"step.line\"\n        @transformend=\"updateTransformedShape\"\n        @dragmove=\"updateGrp($event,step.id)\"\n        @mouseout=\"unshowSelectedShape\"\n        @mouseenter=\"showSelectedShape\"\n        />\n    <v-circle\n        v-for=\"item in step.line.positionPoints\"\n        :key=\"item.id\"\n        :config=\"item\"\n        \n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n      />\n      </v-group>\n      <v-rect\n        v-for=\"item in shapes.filter(i=>i.className=='Rect')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragmove=\"updatePos\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n        \n      />\n      \n      <v-circle\n        v-for=\"item in shapes.filter(i=>i.className=='Circle')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragmove=\"updatePos\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n        \n      />\n      <!--\n      <v-image\n        v-for=\"item in shapes.filter(i=>i.className=='Image')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragmove=\"updatePos\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n        />\n     \n      <v-text\n        v-for=\"item in shapes.filter(i=>i.className=='Text')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragmove=\"updatePos\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n        \n        @dblclick=\"editText\"\n        /> \n      -->\n      <v-regular-polygon\n        v-for=\"item in shapes.filter(i=>i.className=='Triangle')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragmove=\"updatePos\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n        />\n      \n      \n      <v-transformer  v-for=\"item in transformers\" :key=\"item.id\" :config=\"item\"/>\n      <v-circle :key=\"center.id\" :config=\"center\"\n      @dragend=\"ChangeCenter\"\n      @click=\"DisplayCenterMenu\"/>\n      <!--\n      <v-transformer id=\"shapeTransformer\"/>\n      <v-transformer id=\"lineTransformer\" :config=\"{enabledAnchors: ['middle-left', 'middle-right'],}\" />\n      -->\n    </v-layer>\n    \n  </v-stage>\n  \n  \n  <div id=\"activeReuseSubstrate\"\n  \n  @focusout=\"stopInitialisation\"\n  tabindex=\"1\">\n  <ContextMenu :menu-of-stage=\"isStageOnlySelected\" :menu-of-line=isALineSelected \n  \n  :menu-of-grouped-shape=isAGroupedShapeSelected :keep-distance-button-text=\"this.keepDistanceButtonText\" \n  :need-copy-button=\"false\" :need-switch-distribution-mode-button=\"false\"\n  @changecenter-button=\"ChangeCenterButtonAction\" @detachshape-button=\"DetachShapeButtonAction\" @keepdistance-button=\"KeepDistribution\"\n  @copy-button=\"Copy\" @copy-all-button=\"CopyAll\" @past-button=\"Past\" @remove-button=\"Remove\" @remove-all-button=\"RemoveAll\"></ContextMenu>\n  </div>\n  <!--\n  <div id=\"center_menu\">\n  <CenterMenu :defaultAlignment=\"this.selectedShapeAlignment\" @center-button=\"ChangeAlignCenter\"></CenterMenu>\n  </div>\n  -->\n  </div>\n</template>\n\n<script>\n\nimport ContextMenu from \"@/components/interactive-components-for-canvas/ContextMenu.vue\"\n//import CenterMenu from \"./CenterMenu.vue\"\n//import ToolBar from \"./ToolBar.vue\";\n\nconst dragFunc=function (pos) {\n  let width=this.getStage().width();\n  let height=this.getStage().height();\n  let strokeSize=10\n    if(pos.x>width-strokeSize && pos.y>height-strokeSize){\n      return{\n        x: width-strokeSize,\n        y: height-strokeSize,\n      }\n    } else if(pos.x>width-strokeSize && pos.y<strokeSize){\n      return{\n        x: width-strokeSize,\n        y: strokeSize,\n      }\n    } else if(pos.y>height-strokeSize && pos.x<strokeSize){\n      return{\n        x: strokeSize,\n        y: height-strokeSize,\n      }\n    } else if(pos.x<strokeSize && pos.y<strokeSize){\n      return{\n        x: strokeSize,\n        y: strokeSize,\n      }\n    } else if(pos.x<strokeSize){\n      return{\n        x: strokeSize,\n        y: pos.y,\n      }\n    }else if(pos.y<strokeSize){\n      return{\n        x: pos.x,\n        y: strokeSize,\n      }\n    }else if(pos.x>width-strokeSize){\n      return{\n        x: width-strokeSize,\n        y: pos.y,\n      }\n    }else if(pos.y>height-strokeSize){\n      return{\n        x: pos.x,\n        y: height-strokeSize,\n      }\n    } else{\n      return {\n        x: pos.x,\n        y: pos.y,\n      };\n    }\n};\n\n\nexport default {\n  props:{\n    width:{\n      type: Number,\n      default:window.innerWidth,\n    },\n    height:{\n      type: Number,\n      default:window.innerHeight,\n    }\n  },\n  components:{\n    ContextMenu,\n    //CenterMenu,\n    //ToolBar,\n},\n  data() {\n    return {\n      stageSize: {\n        width: this.width,\n        height: this.height,\n      },\n\n      narationHasBeenInitialized:false,\n\n      lengthToCapture:10,\n      lengthToDetach:15,\n      editedText:null,\n\n      eraseMode:0,\n\n      selectedShapeAlignment:'',\n      \n      needMenu: 'initial', //say if the context menu has to be \"active\" or not.\n      isALineSelected:false, \n      isAGroupedShapeSelected:false,\n      isStageOnlySelected: false,\n      //dragItemId: null, //id of the item which is dragging.\n      //text which will appear on the button corresponding to the management of the distribution\n      keepDistanceButtonText:\"Liberate Distribution\",\n      max_id_figures: 6, //max among id of shapes and line since the canvas exist (line excluded) \n      //max_id_lines: 2, //max among id of lines since the canvas exist (line excluded) \n      //groups of shapes (ie a line with shapes on it)\n      groups:[{\n        //rotation: 20,\n        name: \"group\",\n        className: \"Group\",\n        id: '1',\n        x:0,\n        y:0,\n        offsetX:0,\n        offsetY:0,\n        rotation: 0,\n        draggable: false,\n        shapes_g:[ {\n        rotation:0,\n        x: 30,\n        y: 320,\n        scaleX:1,\n        scaleY:1,\n        offsetX: 0,\n        offsetY: 40,\n        radius: 40,\n        fill: 'orange',\n        strokeWidth: 0,\n        stroke: 'black',\n        draggable:true,\n        isGrouped: 1,\n        className:\"Circle\",\n        /*When it is on a line, a shape can be rotate by the user independently from the line.\n          To keep the independant rotation of the attached shape, we add the parameter \"personalRotation\".\n          So, when the shape is attached, is final rotation is the sum of this parameter with the rotation of the line.\n          */\n        personalRotation:0, \n        id:'2',\n        dragBoundFunc: dragFunc,\n        centerPosition:'Bottom',\n      },\n        {\n        rotation:0,\n        x: 110,\n        y: 320,\n        scaleX:1,\n        scaleY:1,\n        offsetX: 0,\n        offsetY: 40,\n        radius: 40,\n        fill: 'orange',\n        strokeWidth: 0,\n        stroke: 'black',\n        draggable:true,\n        isGrouped: 1,\n        className:\"Circle\",\n        /*When it is on a line, a shape can be rotate by the user independently from the line.\n          To keep the independant rotation of the attached shape, we add the parameter \"personalRotation\".\n          So, when the shape is attached, is final rotation is the sum of this parameter with the rotation of the line.\n          */\n        personalRotation:0, \n        id:'3',\n        dragBoundFunc: dragFunc,\n        centerPosition:'Bottom',\n      },{\n        rotation:0,\n        x: 200,\n        y: 320,\n        scaleX:1,\n        scaleY:1,\n        offsetX: 0,\n        offsetY: 40,\n        radius: 40,\n        fill: 'orange',\n        strokeWidth: 0,\n        stroke: 'black',\n        draggable:true,\n        isGrouped: 1,\n        className:\"Circle\",\n        /*When it is on a line, a shape can be rotate by the user independently from the line.\n          To keep the independant rotation of the attached shape, we add the parameter \"personalRotation\".\n          So, when the shape is attached, is final rotation is the sum of this parameter with the rotation of the line.\n          */\n        personalRotation:0, \n        id:'4',\n        dragBoundFunc: dragFunc,\n        centerPosition:'Bottom',\n      }], //list of shapes that are on the line\n        //the line of the group:\n        aShapeHasBeenDetach:0,\n        line:{\n          x:150,\n          y:250,\n          points: [0, 0, 0, 0, 250, 0],\n          positionPoints:[{\n        x: 300,\n        y: 500,\n        scaleX:1,\n        scaleY:1,\n        offsetX: 0,\n        offsetY: 0,\n        radius: 3,\n        fill: 'yellow',\n        opacity:1,\n        draggable:false,\n        isGrouped: 0,\n        className:\"positionPoint\",\n        id:'positionPoint1',\n        distance_to_line_center:undefined,\n      },{\n        x: 300,\n        y: 500,\n        scaleX:1,\n        scaleY:1,\n        offsetX: 0,\n        offsetY: 0,\n        radius: 3,\n        fill: 'yellow',\n        opacity:1,\n        draggable:false,\n        isGrouped: 0,\n        className:\"positionPoint\",\n        id:'positionPoint2',\n        distance_to_line_center:undefined,\n      },{\n        x: 300,\n        y: 500,\n        scaleX:1,\n        scaleY:1,\n        offsetX: 0,\n        offsetY: 0,\n        radius: 3,\n        fill: 'yellow',\n        opacity:1,\n        draggable:false,\n        isGrouped: 0,\n        className:\"positionPoint\",\n        id:'positionPoint3',\n        distance_to_line_center:undefined,\n      },],\n          strokeWidth: 10,\n          rotation: 0,\n          tension:0,\n          closed: true,\n          draggable: true,\n          scaleX:1,\n          scaleY:1,\n          opacity:0.5,\n          offset:{\n            x:125,\n            y:0,\n          },\n          name: \"ligne\",\n          className: \"Line\",\n          stroke: 'blue',\n          id:'1',\n          //distShapesToCenter:[],\n          keepDistribution: false, //say of we keep the distribution on the line or not\n          freeDistances:[], // distance that can be taken by other shapes (if we keep distribution on the line).\n          occupiedDistances:[-95,-15,105], //distance already \"taken\" by shapes on the line.       \n          //text which will appear on the button corresponding to the management of the distribution:\n          keepDistanceButtonText:\"Liberate Distribution\",\n          //function which determine how the line can be dragged:\n          defaultAlignment:\"Bottom\",\n          dragBoundFunc: dragFunc,\n        },\n      },\n      /*{\n        name: \"group2\",\n        className: \"Group\",\n        id: '7',\n        x:0,\n        y:0,\n        offsetX:0,\n        offsetY:0,\n        rotation: 0,\n        draggable: false,\n        shapes_g:[],\n        line:{\n        x:500,\n        y:300,\n        points: [0, 0, 0, 0, 300, 0],\n        positionPoints:[],\n        strokeWidth: 10,\n        rotation: 0,\n        tension:0,\n        closed: true,\n        draggable: true,\n        scaleX:1,\n        scaleY:1,\n        opacity:0.5,\n        offset:{\n          x:150,\n          y:0,\n        },\n        //draggable:true,\n        name: \"ligne\",\n        className: \"Line\",\n        stroke: 'black',\n        id:'7',\n        distShapesToCenter:[],\n        keepDistribution: true,\n        freeDistances:[],\n        occupiedDistances:[],\n        keepDistanceButtonText:\"Liberate Distribution\",\n        defaultAlignment:\"Middle\",\n        dragBoundFunc: dragFunc,\n      },\n      \n      }*/\n      ],\n      transformers:[\n        {\n          id: 'lineTransformer',\n          enabledAnchors: [],\n          rotateEnabled: false,\n          borderEnabled:false,\n          flipEnabled: false, // in order to not have a rotation of the transformer which lead to problem related to shapes position on a line\n          nodes: [],\n\n        },\n        {\n          id: 'shapeTransformer',\n          nodes: [],\n        }\n      ],\n      shapes: [],\n      center:{\n        x: 300,\n        y: 500,\n        scaleX:1,\n        scaleY:1,\n        offsetX: 0,\n        offsetY: 0,\n        radius: 4,\n        fill: 'black',\n        opacity:1,\n        draggable:true,\n        isGrouped: 0,\n        className:\"Circle\",\n        id:'center',\n        dragBoundFunc:dragFunc,\n      },\n      positionPoint:{\n        x: 300,\n        y: 500,\n        scaleX:1,\n        scaleY:1,\n        offsetX: 0,\n        offsetY: 0,\n        radius: 3,\n        fill: 'yellow',\n        opacity:1,\n        draggable:false,\n        isGrouped: 0,\n        className:\"positionPoint\",\n        id:'positionPoint',\n        distance_to_line_center:undefined,\n      },\n      selectedShapeId: '',\n    };\n  },\n  mounted(){\n    let texts=this.$refs.stage.getStage().getChildren()[0].getChildren().filter((r)=>r.attrs.className=='Text');\n    \n    \n    for(let i=0;i<texts.length;i++){\n      texts[i].attrs.length_x=texts[i].width();\n      texts[i].attrs.length_y=texts[i].height();\n      texts[i].offsetX(texts[i].attrs.length_x/2);\n    }\n    let grp=this.groups[0];\n    let line=grp.line;\n    let shapes_g=grp.shapes_g;\n    for(let i=0;i<shapes_g.length;i++){\n      this.updateDragFunc(shapes_g[i],line);\n      \n      this.updateAllPosInGrp(grp.id);\n    }\n  },\n  created(){\n    //nb of shapes on the canvas (line excluded), we consider that there is no shape on line:\n    this.max_id_figures=this.shapes.length +this.groups.length; \n    for(let i=0;i<this.groups.length;i++){\n      this.max_id_figures= this.max_id_figures+this.groups[i].shapes_g.length;\n    }\n    //this.max_id_lines=this.groups.length;\n    /*\n    const image = new window.Image();\n    image.src = require(\"@/assets/exsitu.png\");\n    // set image only when it is loaded\n    image.height=150;\n    image.width=150;\n    image.onload = () => {\n      this.shapes.find((r)=>r.className===\"Image\").image= image;\n      this.shapes.find((r)=>r.className===\"Image\").offsetX=image.width/2;\n      this.shapes.find((r)=>r.className===\"Image\").offsetY=0; \n    };\n    */\n  },\n  methods: {\n\n    switchEraseMode(){\n      if(this.eraseMode==0){\n        this.eraseMode=1;\n        document.getElementById(\"playground\").style.cursor='url('+require('@/assets/ugly_eraser.png')+'),default';\n        \n      this.eraseNodefromTransformer(\"shapeTransformer\");\n      this.eraseNodefromTransformer(\"lineTransformer\");\n      } else{\n        this.eraseMode=0;\n        document.getElementById(\"playground\").style.cursor=\"default\";\n      }\n    },\n    /*\n    Check if all shapes that are supposed to be on a line still in this line.\n    id_grp is the id of the group which contains the line.\n    */\n    checkIfShapesOnLine(id_grp){\n      const grp= this.groups.find((r) => r.id===id_grp);\n      const line=grp.line;\n      const groupedShapes = grp.shapes_g;\n      //const lengthToDetach=10;\n      \n      /*\n      To determine if a shape is on a line, we see if the point is not on the corresponding\n      straight line y=a*x+b regarding certains intervals for x and y.Those intervals depends of the rotation of\n      the line. \n      */\n     /*\n      let coord_y1=line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x1=line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let coord_y2= line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x2=line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let a=(coord_y1-coord_y2)/(coord_x2-coord_x1);\n      let b=line.y-a*line.x;\n      let is_on_straight_line=false;\n      */\n      \n      let i=0;\n      while(i<groupedShapes.length){\n        /*\n        if(Math.abs(coord_x1-coord_x2)>1){\n        is_on_straight_line=(Math.abs(a*groupedShapes[i].x+b-groupedShapes[i].y)<this.lengthToDetach);\n      }else{\n        is_on_straight_line=(Math.abs(groupedShapes[i].x-line.x)<this.lengthToDetach);\n      }\n        if (\n          !(is_on_straight_line)\n        ||((line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].y\n        ||line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].y)\n        && ((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n        ||((line.x+line.points[4]*line.scaleX*(1/2)*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].x\n        ||line.x-line.points[4]*line.scaleX*(1/2)*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].x)\n        &&((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n        ||((line.y+line.points[4]*line.scaleX*(1/2)*Math.sin(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].y\n        ||line.y-line.points[4]*line.scaleX*(1/2)*Math.sin(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].y)\n        &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>=-Math.PI)))\n\n        ||((line.x+line.points[4]*line.scaleX*(1/2)*Math.cos(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].x\n        ||line.x-line.points[4]*line.scaleX*(1/2)*Math.cos(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].x)\n        &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>=-Math.PI)))\n\n        ||((line.y+line.points[4]*line.scaleX*(1/2)*Math.sin(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].y\n        ||line.y-line.points[4]*line.scaleX*(1/2)*Math.sin(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].y)\n        &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n        ||((line.x+line.points[4]*line.scaleX*(1/2)*Math.cos(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].x\n        ||line.x-line.points[4]*line.scaleX*(1/2)*Math.cos(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].x)\n        &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n        ||((line.y+line.points[4]*line.scaleX*(1/2)*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].y\n        ||line.y-line.points[4]*line.scaleX*(1/2)*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].y)\n        &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>0)))\n\n        ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].x\n        ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].x)\n        &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>0)))\n        )\n        */\n       if(!this.isCoordinateOnLine(groupedShapes[i].x,groupedShapes[i].y,line.id)){\n          console.log(\"a shape is not on a line\");\n          groupedShapes[i].dragBoundFunc= dragFunc;\n          groupedShapes[i].isGrouped=0;\n          if(line.keepDistribution){\n            line.positionPoints.slice(i,1)\n          }\n          this.shapes.push(groupedShapes[i],)\n          line.freeDistances.push(line.occupiedDistances[i]);\n          line.occupiedDistances.splice(i,1);\n          groupedShapes.splice(i,1);\n          this.updateNaration(grp)\n        }else{\n          i=i+1;\n        }\n      }\n    },\n\n    //say of {x,y} is a point from the line\n    isCoordinateOnLine(x,y,id_grp){\n      const grp=this.groups.find((r) => r.id===id_grp);\n      const line=grp.line;\n      let is_not_on_straight_line=true;\n      let coord_y1=line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x1=line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let coord_y2= line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x2=line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let a=(coord_y1-coord_y2)/(coord_x2-coord_x1);\n      let b=line.y-a*line.x;\n      if(Math.abs(coord_x1-coord_x2)>1){\n        is_not_on_straight_line=(Math.abs(a*x+b-y)>1);\n      }else{\n        is_not_on_straight_line=(Math.abs(x-line.x)>1)\n      }\n      if(\n        (is_not_on_straight_line)\n\n      ||((line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<y\n      ||line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>y)\n      && ((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<x\n        ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>x)\n      &&((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<y\n        ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>y)\n      &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>-Math.PI)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>x)\n      &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>-Math.PI)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>y)\n      &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>x)\n      &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>y)\n      &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>=0)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>x)\n      &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>=0)))\n\n      ||(!is_not_on_straight_line && Math.sqrt((line.x-x)**2+(line.y-y)**2)>line.points[4]*line.scaleX/2)\n\n      )\n      {\n        return false; \n      } else{\n        return true;\n      }\n    },\n\n    //update a group with the id id_grp\n    updateGrp(e,id_grp){\n      const grep=this.groups.find((r)=>r.id===id_grp);\n      const line= grep.line;\n      grep.offsetX=line.offsetX;\n      grep.offsetY=line.offsetY;\n      \n      line.x=e.target.x();\n      line.y=e.target.y();\n      this.center.x=line.x;\n      this.center.y=line.y;\n      /*\n      if(line.keepDistribution){\n        this.updateOccupiedDistance(line.id);\n      }\n      */\n      this.updateAllPosInGrp(line.id); \n      this.checkIfShapesOnLine(line.id);\n    },\n\n\n    //update the position of all shapes that are on the line of the group with the id id_grp.\n    updateAllPosInGrp(id_grp){\n      const grp= this.groups.find((r) => r.id===id_grp);     \n      const line= grp.line;\n      const shapes_g = grp.shapes_g;\n      for (let i=0;i<shapes_g.length;i++){\n          if(line.keepDistribution){\n            shapes_g[i].x=line.x+line.occupiedDistances[i]*Math.cos(line.rotation*(Math.PI/180));\n            shapes_g[i].y=line.y+line.occupiedDistances[i]*Math.sin(line.rotation*(Math.PI/180));\n            shapes_g[i].distance_to_line_center=line.occupiedDistances[i];\n            shapes_g[i].rotation=shapes_g[i].personalRotation+line.rotation;\n            \n          } else{\n            shapes_g[i].x=line.x+line.occupiedDistances[i]*Math.cos(line.rotation*(Math.PI/180));\n            shapes_g[i].y=line.y+line.occupiedDistances[i]*Math.sin(line.rotation*(Math.PI/180));\n            shapes_g[i].distance_to_line_center=line.occupiedDistances[i];\n            shapes_g[i].rotation=shapes_g[i].personalRotation+line.rotation;\n          }\n          line.positionPoints[i].x=shapes_g[i].x;\n          line.positionPoints[i].y=shapes_g[i].y;\n          line.positionPoints[i].distance_to_line_center=shapes_g[i].distance_to_line_center;\n      }\n      let i=shapes_g.length;\n      while(i<line.positionPoints.length){\n        if(line.keepDistribution){\n          line.positionPoints.splice(i,1);\n        }else{\n        line.positionPoints[i].x=line.x+line.freeDistances[i-shapes_g.length]*Math.cos(line.rotation*(Math.PI/180));\n        line.positionPoints[i].y=line.y+line.freeDistances[i-shapes_g.length]*Math.sin(line.rotation*(Math.PI/180));\n        line.positionPoints[i].distance_to_line_center=line.freeDistances[i-shapes_g.length];\n        i++;\n        }\n        \n      }\n    \n    },\n    isOutsideTheLine(shape,line){\n      let coord_y1=line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x1=line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let coord_y2= line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x2=line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let a=(coord_y1-coord_y2)/(coord_x2-coord_x1);\n      let b=line.y-a*line.x;\n      let is_on_straight_line=false;\n      if(Math.abs(coord_x1-coord_x2)>=1){\n        is_on_straight_line=(Math.abs(a*shape.x+b-shape.y)<1);\n      }else{\n        is_on_straight_line=(Math.abs(shape.x-line.x)<1);\n      }\n      if(\n        !(is_on_straight_line)\n      ||((line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n        ||line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      && ((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>-Math.PI)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>-Math.PI)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>=0)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>=0)))\n      ){\n        return true;\n      }else{ return false}\n    },\n    \n    //update the canvas\n    update(){\n      const shapes = this.shapes\n      \n      //const lengthToCapture=10; //bigger is the number, bigger is the intervals of x and y where a shape can be added to a line.\n      let is_on_straight_line=false;\n      for (let i=0;i<shapes.length;i++){\n        let x=shapes[i].x;\n        let y=shapes[i].y;\n      for (let j=0;j<this.groups.length;j++){\n      \n        let line=this.groups[j].line;\n\n        \n        let coord_y1=line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n        let coord_x1=line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n        let coord_y2= line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n        let coord_x2=line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n        let a=(coord_y1-coord_y2)/(coord_x2-coord_x1);\n        let b=line.y-a*line.x;\n        if(Math.abs(coord_x1-coord_x2)>1){\n          is_on_straight_line=(Math.abs(a*x+b-y)<=this.lengthToCapture);\n        }else{\n          is_on_straight_line=(Math.abs(x-line.x)<=this.lengthToCapture);\n          //is_on_straight_line=true;\n        }\n        if(\n        (\n          is_on_straight_line\n      &&(line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToCapture>=y\n      && line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToCapture<=y)\n      &&(line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToCapture>=x\n      && line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToCapture<=x)\n      &&(line.rotation*(Math.PI/180)<=0 \n      && line.rotation*(Math.PI/180)>-Math.PI/2))\n\n      ||(\n        is_on_straight_line\n      &&(line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))+this.lengthToCapture>=y\n      && line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))-this.lengthToCapture<=y) \n      &&(line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))+this.lengthToCapture>=x\n      && line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))-this.lengthToCapture<=x)\n      &&(line.rotation*(Math.PI/180)<=-Math.PI/2 \n      && line.rotation*(Math.PI/180)>=-Math.PI))\n\n      ||(\n        is_on_straight_line\n      &&(line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))+this.lengthToCapture>=y\n      &&line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))-this.lengthToCapture<=y)\n      &&(line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))+this.lengthToCapture>=x\n      && line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))-this.lengthToCapture<=x)\n      &&(line.rotation*(Math.PI/180)<=Math.PI \n      && line.rotation*(Math.PI/180)>Math.PI/2))\n\n      ||(\n        is_on_straight_line\n      &&(line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToCapture>=y\n      && line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToCapture<=y)\n      &&(line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToCapture>=x\n      && line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToCapture<=x)\n      &&(line.rotation*(Math.PI/180)<=Math.PI/2\n      && line.rotation*(Math.PI/180)>=0))\n      )\n       {\n          shapes[i].isGrouped=1;\n          this.makeGroup(line.id);\n        }\n      }\n      }\n    },\n\n    CheckIfNeedToDetach(e){\n      let grp=this.groups.find((r)=>r.id===e.target.getParent().attrs.id);\n      let shape= grp.shapes_g.find((r)=>r.id==e.target.id());\n      let dist=Math.sqrt((e.target.getStage().getPointerPosition().y-e.target.y())**2+(e.target.getStage().getPointerPosition().x-e.target.x())**2);\n      if(e.target.className==\"Rect\"){\n        dist-=e.target.attrs.height*e.target.attrs.scaleY;\n      } else if(e.target.className==\"Circle\"){\n        dist-=(2*e.target.attrs.radius)*e.target.attrs.scaleY;\n      } else if(e.target.className==\"Text\"){\n        dist-=e.target.attrs.length_y*e.target.attrs.scaleY;\n      } else if(e.target.className==\"Image\"){\n        dist-=e.target.height()*e.target.scaleY();\n      } else if(e.target.attrs.className==\"Triangle\"){\n        dist-=e.target.height()*e.target.scaleY();\n      } \n      \n      if (dist>50){\n        //let shape= this.groups.find((r)=>r.id===e.target.getParent().attrs.id).shapes_g.find((r)=>r.id==e.target.id());\n        //this.groups.find((r)=>r.id===e.target.getParent().attrs.id).shapes_g.find((r)=>r.id==e.target.id()).needToBeDetach=1;\n        /*\n        shape.dragBoundFunc= function (pos) {\n              return {\n                x: pos.x,\n                y: pos.y,\n              };\n        }\n        */\n        //shape.x=e.target.getStage().getPointerPosition().x;\n        //shape.y=e.target.getStage().getPointerPosition().y;\n        //if (Math.abs(e.target.getStage().getPointerPosition().y-e.target.y())>220){\n          \n        //shape.x=e.target.getStage().getPointerPosition().x;\n        //shape.y=e.target.getStage().getPointerPosition().y;\n        this.groups.find((r)=>r.id===e.target.getParent().attrs.id).aShapeHasBeenDetach=1;\n        this.DetachShape(shape,e.target.getStage().getPointerPosition().x,e.target.getStage().getPointerPosition().y);\n        \n        //}\n        \n        \n        \n      }\n    },\n\n    //Give the sign of the distance of shape from the center of a line.\n    GiveSignOfDistance(shape,line){\n      let result;\n      let angle=line.rotation*(Math.PI/180);\n      let distX=shape.x-line.x;\n      let distY=shape.y-line.y;\n      /*\n      \n      if(angle<=-Math.PI/4 || angle>=-Math.PI/2){\n        result=-Math.sign(distY);\n      }\n      else if(angle<=-Math.PI/2 || angle>=-3*Math.PI/4){\n        result=Math.sign(distY);\n      }\n      else if(angle<=-3*Math.PI/4 || angle>=-Math.PI){\n        result=-Math.sign(distX);\n      }else if(angle>=3*Math.PI/4 || angle<=Math.PI){\n        result=Math.sign(distX);\n      }else if(angle>=Math.PI/2 || angle<3*Math.PI/4){\n        result=-Math.sign(distY);\n      } else if(angle<=Math.PI/2 || angle>Math.PI/4){\n        result=-Math.sign(distY);\n      } else if(angle<=Math.PI/4 || angle>=0){\n        result=Math.sign(distX);\n      }\n      */\n      \n      \n      if(Math.abs(distX)<=this.lengthToCapture && line.rotation==-90){\n        \n        result=-Math.sign(distY);\n      } else if (Math.abs(distX)<=this.lengthToCapture && line.rotation==90){\n        result=Math.sign(distY);\n      }\n      else{\n        result=Math.sign(distX);\n      }\n      if(angle<-Math.PI/2 || angle>Math.PI/2){\n        result=-result;\n      }\n      \n      return result;\n    },\n\n    //Different from the previous function bcs the straight line of the center is perdendicular to the line\n    GiveSignOfDistanceBtwCenterAndShape(center,shape){\n      let result;\n      let angle=shape.rotation*(Math.PI/180);\n      let distX=center.x-shape.x;\n      let distY=center.y-shape.y;\n      /*\n      \n      if(angle<=-Math.PI/4 || angle>=-Math.PI/2){\n        result=-Math.sign(distY);\n      }\n      else if(angle<=-Math.PI/2 || angle>=-3*Math.PI/4){\n        result=Math.sign(distY);\n      }\n      else if(angle<=-3*Math.PI/4 || angle>=-Math.PI){\n        result=-Math.sign(distX);\n      }else if(angle>=3*Math.PI/4 || angle<=Math.PI){\n        result=Math.sign(distX);\n      }else if(angle>=Math.PI/2 || angle<3*Math.PI/4){\n        result=-Math.sign(distY);\n      } else if(angle<=Math.PI/2 || angle>Math.PI/4){\n        result=-Math.sign(distY);\n      } else if(angle<=Math.PI/4 || angle>=0){\n        result=Math.sign(distX);\n      }\n      */\n      \n      \n      if(Math.abs(distY)<=this.lengthToCapture && shape.rotation==-90){\n        \n        result=Math.sign(distX);\n      } else if (Math.abs(distY)<=this.lengthToCapture && shape.rotation==90){\n        result=-Math.sign(distX);\n      }\n      else{\n        result=Math.sign(distY);\n      }\n      if(angle<-Math.PI/2 || angle>Math.PI/2){\n        result=-result;\n      }\n      \n      return result;\n    },\n\n    /*add shapes with isGrouped==1 to the group with the id id_grp.\n    */\n    makeGroup(id_grp){\n      this.eraseNodefromTransformer(\"shapeTransformer\");\n      this.eraseNodefromTransformer(\"lineTransformer\");\n      const grp=this.groups.find((r)=> r.id===id_grp);\n      const line=grp.line;\n      const shapes = this.shapes;\n      line.freeDistances.sort(this.isSmaller); //we will give the shortest available distance to the added shape\n      shapes.sort(this.isBeforeRegardingX);\n      for (let i=0;i<shapes.length;i++){\n        if(shapes[i].isGrouped==1){\n          const positionPoint=Object.assign({},this.positionPoint);\n          let distX=shapes[i].x-line.x;\n          let distY=shapes[i].y-line.y; \n          shapes[i].personalRotation=0;\n          //let pot_dist=this.GiveSignOfDistance(shapes[i],line)*Math.sqrt((distX)**2+(distY)**2);\n          /*\n          if(line.keepDistribution && line.freeDistances.length>0){\n          let distances=line.freeDistances+line.occupiedDistances;\n          console.log(distances);\n           let freeDistance=this.isNearest(line.freeDistances,pot_dist);\n           //shapes[i].distance_to_line_center=freeDistance.res; \n           shapes[i].distance_to_line_center=this.GiveSignOfDistance(shapes[i],line)*Math.sqrt((distX)**2+(distY)**2);\n            \n           line.occupiedDistances.push(shapes[i].distance_to_line_center,);\n           line.freeDistances.splice(freeDistance.indice,1);\n\n          } else{\n            */\n            //let distX=shapes[i].x-line.x;\n            //let distY=shapes[i].y-line.y;\n            shapes[i].distance_to_line_center=this.GiveSignOfDistance(shapes[i],line)*Math.sqrt((distX)**2+(distY)**2);\n            /*If the distance is a little bit to far from the center \n            we adjust it so that the shape can be at one of the border of the stickyline*/\n            if(Math.abs(shapes[i].distance_to_line_center)>=line.points[4]*line.scaleX/2){\n              shapes[i].distance_to_line_center=Math.sign(shapes[i].distance_to_line_center)*line.points[4]*line.scaleX/2\n            }\n            this.ChangeCenterRegardingCommand(shapes[i].id,grp.line.defaultAlignment);\n            if(!line.keepDistribution && line.freeDistances.length>0){\n              let indice=this.isNearest(line,shapes[i]);\n              //console.log(indice);\n              //shapes[i].distance_to_line_center=line.freeDistances[indice];\n              //line.freeDistances.splice(indice,1);\n              //shapes[i].isGrouped=0;\n              this.updateDragFunc(shapes[i],line);\n              grp.shapes_g.push(shapes[i],);\n              grp.line.occupiedDistances.push(grp.line.freeDistances[indice]);\n              grp.line.freeDistances.splice(indice,1);\n              //this.updateOccupiedDistance(grp.line.id);\n\n            }else{\n              //shapes[i].isGrouped=0;\n              this.updateDragFunc(shapes[i],line);\n              grp.shapes_g.push(shapes[i],);\n              console.log(\"no 'free distance' anymore\")\n              grp.line.occupiedDistances.push(shapes[i].distance_to_line_center,);\n              positionPoint.id=\"positionPoint\"+grp.id+grp.line.positionPoints.length;\n              grp.line.positionPoints.push(positionPoint,);\n              //shapes[i].distance_to_line_center=this.GiveSignOfDistance(shapes[i],line)*Math.sqrt((distX)**2+(distY)**2);\n            }\n            //line.occupiedDistances.push(shapes[i].distance_to_line_center,);\n          //}\n          console.log(\"A new shape has been added with a distance\"+shapes[i].distance_to_line_center);\n          //shapes[i].isGrouped=0;\n          //this.updateDragFunc(shapes[i],line);\n          //grp.shapes_g.push(shapes[i],);\n          this.updateOccupiedDistance(line.id);\n          \n          this.updateAllPosInGrp(id_grp);\n          shapes.splice(i,1);\n          this.updateNaration(grp)\n        }\n      }\n      this.center.x=line.x;\n      this.center.y=line.y;\n    },\n\n    updateOccupiedDistance(id_grp){\n      \n      const grp=this.groups.find((r)=> r.id===id_grp);\n      //this.updateAllPosInGrp(id_grp);\n      this.sortByDistToLineCenter(grp);\n      \n      //let l=grp.line.points[4]/2;\n      if(grp.line.keepDistribution){\n      let L=grp.line.points[4];\n      let nb_shapes=grp.shapes_g.length;\n      let d=(L/(nb_shapes-1))*grp.line.scaleX;\n      if(nb_shapes%2==0){\n        \n      for (let i =1;i<=nb_shapes/2-1;i++){\n        //grp.line.occupiedDistances[i-1]=-(l/i);\n        grp.line.occupiedDistances[i-1]=-((nb_shapes/2-1)-i+1)*d-d/2\n      }\n      for (let i =1;i<=nb_shapes/2-1;i++){\n        grp.line.occupiedDistances[nb_shapes/2+i]=i*d+d/2;\n      }\n      grp.line.occupiedDistances[nb_shapes/2-1]=-d/2\n      grp.line.occupiedDistances[nb_shapes/2]=d/2\n      } else{\n        for (let i =1;i<=(nb_shapes-1)/2;i++){\n          grp.line.occupiedDistances[i-1]=-d*(((nb_shapes-1)/2)-i+1);\n        }\n        for (let i =1;i<=(nb_shapes-1)/2;i++){\n          grp.line.occupiedDistances[((nb_shapes-1)/2)+i]=d*i;\n        }\n        grp.line.occupiedDistances[(nb_shapes-1)/2]=0;\n      }\n      \n      for (let i=0;i<grp.shapes_g.length;i++){\n        grp.shapes_g[i].distance_to_line_center=grp.line.occupiedDistances[i];\n      }\n      }\n      else{\n        grp.line.occupiedDistances.sort(this.isSmaller);\n      }\n      \n      \n      \n    \n\n    },\n\n   isSmaller(a,b){\n    if(a<b){\n      return -1;\n    }else{\n      return 1\n    }\n   },\n\n   isBeforeRegardingX(a,b){\n    if(a.x<b.x){\n      return -1;\n    }else{\n      return 1;\n    }\n   },\n\n    \n   updateOccDist(grp,shape){\n    let res=this.isNearest(grp.line,shape);\n    //let grp=this.groups.find((r)=>r.id===line.id);\n    if(res.isFree){\n      shape.distance_to_line_center=grp.line.freeDistances[res.indice];\n      grp.line.freeDistances.splice(res.indice,1);\n      this.sortByDistToLineCenter(grp);\n      for(let l=0;l<grp.shapes_g.length;l++){\n        if(grp.line.occupiedDistances.length==l){\n          grp.line.occupiedDistances.push(grp.shapes_g[l].distance_to_line_center,);\n        }else{\n          grp.line.occupiedDistances[l]=grp.shapes_g[l].distance_to_line_center;\n        }\n      } \n    } else{\n      grp.shapes_g.find((r)=>r.id==shape.id).distance_to_line_center=grp.line.occupiedDistances[res.indice];\n      grp.line.occupiedDistances.splice(res.indice,1);\n      //line.occupiedDistances.push(shape.distance_to_line_center,);\n      //line.freeDistances.splice(res.indice,1);   \n      this.updateOccDist(grp,grp.shapes_g[res.indice]);\n    }\n   },\n   isNearest(line,shape){\n    let ecart;\n    let invx=line.x+line.freeDistances[0]*Math.cos(line.rotation*(Math.PI/180));\n    let invy=line.y+line.freeDistances[0]*Math.sin(line.rotation*(Math.PI/180));\n    let ecart_min=Math.sqrt((invx-shape.x)**2+(invy-shape.y)**2);\n    let indice=0;\n    for(let i=1;i<line.freeDistances.length;i++){\n      invx=line.x+line.freeDistances[i]*Math.cos(line.rotation*(Math.PI/180));\n      invy=line.y+line.freeDistances[i]*Math.sin(line.rotation*(Math.PI/180));\n      ecart=Math.sqrt((invx-shape.x)**2+(invy-shape.y)**2);\n      if(ecart<ecart_min){\n        //res=line.freeDistances[i];\n        ecart_min=ecart;\n        indice=i;\n      }\n    }\n    return indice;\n    /*\n    let allDist=line.freeDistances.concat(line.occupiedDistances);\n    console.log(allDist);\n    \n    let ecart;\n    let invx=line.x+allDist[0]*Math.cos(line.rotation*(Math.PI/180));\n    let invy=line.y+allDist[0]*Math.sin(line.rotation*(Math.PI/180));\n    let ecart_min=Math.sqrt((invx-shape.x)**2+(invy-shape.y)**2)\n    let indice=0;\n    console.log(ecart_min);\n    for(let i=1;i<allDist.length;i++){\n      invx=line.x+allDist[i]*Math.cos(line.rotation*(Math.PI/180));\n      invy=line.y+allDist[i]*Math.sin(line.rotation*(Math.PI/180));\n      ecart=Math.sqrt((invx-shape.x)**2+(invy-shape.y)**2);\n      if(this.groups.find((r)=>r.id==line.id).shapes_g.indexOf(shape)!=-1){\n        console.log(ecart_min);\n        console.log(ecart);\n        if(ecart<ecart_min && ecart!=0){\n          //res=allDist[i];\n          ecart_min=ecart;\n          indice=i;\n        }\n      }else if(ecart<ecart_min){\n        //res=allDist[i];\n        ecart_min=ecart;\n        indice=i;\n      }\n    }\n    console.log(indice);\n    if(indice>=line.freeDistances.length){\n      return{\n        isFree: false,\n        indice: indice-line.freeDistances.length,\n      }\n    }else{\n      return{\n        isFree: true,\n        indice: indice,\n      }\n    }\n    */\n\n    /*\n    line.freeDistances.sort(this.isSmaller);\n    let ecart;\n    let invx=line.x+line.freeDistances[0]*Math.cos(line.rotation*(Math.PI/180));\n    let invy=line.y+line.freeDistances[0]*Math.sin(line.rotation*(Math.PI/180));\n    let ecart_min=Math.sqrt((invx-shape.x)**2+(invy-shape.y)**2)\n    let indice=0;\n    for(let i=0;i<line.freeDistances.length;i++){\n      invx=line.x+line.freeDistances[i]*Math.cos(line.rotation*(Math.PI/180));\n      invy=line.y+line.freeDistances[i]*Math.sin(line.rotation*(Math.PI/180));\n      ecart=Math.sqrt((invx-shape.x)**2+(invy-shape.y)**2)\n      if(ecart<ecart_min){\n        //res=freeDistances[i];\n        ecart_min=ecart;\n        indice=i;\n      }\n    }\n    return indice;\n    */\n    /*\n    if(shapeDistance>=0){\n      for(let i=0;i<freeDistances.length;i++){\n        if(freeDistances[i]>shapeDistance){\n          return i;\n        }\n      }\n      return freeDistances.length-1;\n    }else{\n      let ecart_min=Math.abs(Math.abs(freeDistances[0])-Math.abs(shapeDistance))\n      let indice=0;\n      for(let i=0;i<freeDistances.length;i++){\n        let ecart=Math.abs(Math.abs(freeDistances[i])-Math.abs(shapeDistance));\n        if(ecart<ecart_min){\n          //res=freeDistances[i];\n          ecart_min=ecart;\n          indice=i;\n        }\n      }\n      return indice;\n    }\n    */\n    /*\n    //let res=freeDistances[0];\n    let ecart_min=Math.abs(Math.abs(freeDistances[0])-Math.abs(shapeDistance))\n    let indice=0;\n    for(let i=0;i<freeDistances.length;i++){\n      let ecart=Math.abs(Math.abs(freeDistances[i])-Math.abs(shapeDistance));\n      if(ecart<ecart_min){\n        //res=freeDistances[i];\n        ecart_min=ecart;\n        indice=i;\n      }\n    }\n    return indice;\n    */\n   },\n   \n\n   sortByDistToLineCenter(grp){\n    //this.updateAllPosInGrp(grp.id)\n    //let last_distX=new Array(grp.shapes_g.length);\n    \n    //let distX;\n    //let distY;\n    //let sign;\n    //let dist=new Array(grp.shapes_g.length);\n    //let angle;\n    if(grp.line.keepDistribution){\n      for (let l=0;l<grp.shapes_g.length;l++){\n          let distX=grp.shapes_g[l].x-grp.line.x;\n          let distY=grp.shapes_g[l].y-grp.line.y;\n          //dist[l]=this.GiveSignOfDistance(grp.shapes_g[l],grp.line)*Math.sqrt((distX)**2+(distY)**2);\n          grp.shapes_g[l].distance_to_line_center=this.GiveSignOfDistance(grp.shapes_g[l],grp.line)*Math.sqrt((distX)**2+(distY)**2);\n          //last_distX[l]=distX;\n        }\n    }\n    for(let i=1;i<grp.shapes_g.length;i++){\n      \n     \n      let shape=grp.shapes_g[i];\n      //let distance=dist[i];\n      let j=i\n      while(j>0 && grp.shapes_g[j-1].distance_to_line_center>shape.distance_to_line_center){\n        grp.shapes_g[j]=grp.shapes_g[j-1];\n        //dist[j]=dist[j-1]\n        j=j-1;\n      }\n      grp.shapes_g[j]=shape;\n      //dist[j]=distance;\n    }\n   },\n   \n\n   sortAnyShapesByDistToLineCenter(shapes,line){\n    //this.updateAllPosInGrp(grp.id)\n    //let last_distX=new Array(grp.shapes_g.length);\n    \n    //let distX;\n    //let distY;\n    //let sign;\n    //let dist=new Array(grp.shapes_g.length);\n    //let angle;\n    for (let l=0;l<shapes.length;l++){\n        let distX=shapes[l].x-line.x;\n        let distY=shapes[l].y-line.y;\n        /*\n        angle=grp.shapes_g[l].rotation*(Math.PI/180);\n\n      \n      if(angle<=-Math.PI/4 || angle>=-Math.PI/2){\n        sign=-Math.sign(distY);\n      }\n      else if(angle<=-Math.PI/2 || angle>=-3*Math.PI/4){\n        sign=Math.sign(distY);\n      }\n      else if(angle<=-3*Math.PI/4 || angle>=-Math.PI){\n        sign=-Math.sign(distX);\n      }else if(angle>=3*Math.PI/4 || angle<=Math.PI){\n        sign=Math.sign(distX);\n      }else if(angle>=Math.PI/2 || angle<3*Math.PI/4){\n        sign=-Math.sign(distY);\n      } else if(angle<=Math.PI/2 || angle>Math.PI/4){\n        sign=-Math.sign(distY);\n      } else if(angle<=Math.PI/4 || angle>=0){\n        sign=Math.sign(distX);\n      }\n       console.log(sign);\n        */\n       \n        /*\n        if(Math.sin(grp.line.rotation*(Math.PI/180))==0){\n            grp.shapes_g[l].distance_to_line_center=grp.shapes_g[l].x-grp.line.x;\n        }else{\n            grp.shapes_g[l].distance_to_line_center=Math.sign(distX)*Math.sqrt((distX)**2+(distY)**2);\n          \n            if(grp.line.rotation*(Math.PI/180)<=-Math.PI/2 || grp.line.rotation*(Math.PI/180)<=Math.PI/2 &&grp.line.rotation*(Math.PI/180)>=0){\n              grp.shapes_g[l].distance_to_line_center=-grp.shapes_g[l].distance_to_line_center\n            }\n        }\n        */\n        //dist[l]=this.GiveSignOfDistance(grp.shapes_g[l],grp.line)*Math.sqrt((distX)**2+(distY)**2);\n        shapes.distance_to_line_center=this.GiveSignOfDistance(shapes,line)*Math.sqrt((distX)**2+(distY)**2);\n        /*\n        if((grp.line.rotation*(Math.PI/180)<=-Math.PI/2 || (grp.line.rotation*(Math.PI/180)<=Math.PI/2 && grp.line.rotation*(Math.PI/180)>=0)) && (Math.sign(last_distX[l])!=Math.sign(distX))){\n          grp.shapes_g[l].distance_to_line_center=-grp.shapes_g[l].distance_to_line_center\n        }\n        */\n        //last_distX[l]=distX;\n      }\n    for(let i=1;i<shapes.length;i++){\n      \n     \n      let shape=shapes[i];\n      //let distance=dist[i];\n      let j=i\n      while(j>0 && shapes[j-1].distance_to_line_center>shape.distance_to_line_center){\n        shapes[j]=shapes[j-1];\n        //dist[j]=dist[j-1]\n        j=j-1;\n      }\n      shapes[j]=shape;\n      //dist[j]=distance;\n    }\n   },\n\n  \n\n   /*\n   update the drag function of a shape which is on a line. \n   */\n   updateDragFunc(shape,line){\n          let angle=line.rotation*(Math.PI/180);\n          if (angle<=0 && angle>=-Math.PI/4){\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x +(pos.x-line.x)*Math.cos(angle),\n                y: line.y+(pos.x-line.x)*Math.sin(angle),\n              };\n            }\n          } else if (angle<-Math.PI/4 && angle>=-Math.PI/2){\n            // We prefer, in this case, moving the shape of the line regarding the y of the mouse position instead of the x.\n            // So that the user can move the shape more intuitively\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x-(pos.y-line.y)*Math.cos(angle),\n                y: line.y-(pos.y-line.y)*Math.sin(angle),\n              };\n            }\n          }\n          else if (angle<-Math.PI/2 && angle>=-3*Math.PI/4){\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x-(pos.y-line.y)*Math.cos(angle),\n                y: line.y-(pos.y-line.y)*Math.sin(angle),\n              };\n            }\n          } else if (angle<-3*Math.PI/4 && angle>=-Math.PI){\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x-(pos.x-line.x)*Math.cos(angle),\n                y: line.y-(pos.x-line.x)*Math.sin(angle),\n              };\n            }\n          }else if (angle<=Math.PI && angle>=3*Math.PI/4){\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x-(pos.x-line.x)*Math.cos(angle),\n                y: line.y-(pos.x-line.x)*Math.sin(angle),\n              };\n            }\n          } else if (angle<3*Math.PI/4 && angle>=Math.PI/2){\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x+(pos.y-line.y)*Math.cos(angle),\n                y: line.y+(pos.y-line.y)*Math.sin(angle),\n              };\n            }\n          } else if (angle<Math.PI/2 && angle>=Math.PI/4){\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x+(pos.y-line.y)*Math.cos(angle),\n                y: line.y+(pos.y-line.y)*Math.sin(angle),\n              };\n            }\n          }else if (angle<Math.PI/4 && angle>=0){\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x+(pos.x-line.x)*Math.cos(angle),\n                y: line.y+(pos.x-line.x)*Math.sin(angle),\n              };\n            }\n          }\n   },\n\n   /*\n   Update the position of a free shape when it is dragging.\n   */\n    updatePos(e){\n      const shape = this.shapes.find(i => i.id === e.target.id());\n      shape.x=e.target.x();\n      shape.y=e.target.y();\n      this.center.x=e.target.x();\n      this.center.y=e.target.y();\n\n      let pos = { x: shape.x, y: shape.y };\n      e.target.position(pos);\n      e.target.getLayer().batchDraw();\n      \n    },\n\n    /*\n    Update the positio  of shape attached to a line (from the group with id=id_grp) when it is dragging.\n     */\n    updatePosInGrp(e,id_grp){\n      let distX;\n      let distY;\n      let distance_to_line_center;\n      const grp=this.groups.find((r)=> r.id===id_grp);\n      \n      if(grp.aShapeHasBeenDetach==1){\n        grp.aShapeHasBeenDetach=0;\n        return;\n      }\n      const line=grp.line;\n      const shape = grp.shapes_g.find(i => i.id === e.target.id());\n      const shapes_g = grp.shapes_g; \n      //const lengthToDetach=10;\n      if(shape.needToBeDetach==1){\n        shape.needToBeDetach=0;\n        this.DetachShape(shape);\n        this.updateAllPosInGrp(e.target.getParent().attrs.id);\n      }\n      if(line.keepDistribution){\n        if(this.isCoordinateOnLine(e.target.x(),e.target.y(),line.id)){\n          distX=shape.x-e.target.x();\n          distY=shape.y -e.target.y();\n          let L=grp.line.points[4];\n          let nb_shapes=grp.shapes_g.length;\n          let d=(L/(nb_shapes-1))*grp.line.scaleX;\n          let dist=Math.sqrt(distX**2 +distY**2);\n          if(dist>=d){\n            shape.x=e.target.x();\n            shape.y=e.target.y();\n            this.updateOccupiedDistance(line.id)\n            shape.x=line.x+line.occupiedDistances[shapes_g.indexOf(shape)]*Math.cos(line.rotation*(Math.PI/180));\n            shape.y=line.y+line.occupiedDistances[shapes_g.indexOf(shape)]*Math.sin(line.rotation*(Math.PI/180));\n            shape.distance_to_line_center=line.occupiedDistances[shapes_g.indexOf(shape)];\n            shape.rotation=line.rotation;\n            this.updateAllPosInGrp(line.id);\n          }else{\n            shape.x=line.x+line.occupiedDistances[shapes_g.indexOf(shape)]*Math.cos(line.rotation*(Math.PI/180));\n            shape.y=line.y+line.occupiedDistances[shapes_g.indexOf(shape)]*Math.sin(line.rotation*(Math.PI/180));\n            shape.distance_to_line_center=line.occupiedDistances[shapes_g.indexOf(shape)];\n            shape.rotation=line.rotation; \n          }   \n        }else{\n          shape.x=e.target.x();\n          shape.y=e.target.y();\n        }\n        line.positionPoints[grp.shapes_g.indexOf(shape)].x=shape.x;\n        line.positionPoints[grp.shapes_g.indexOf(shape)].y=shape.y;\n        line.positionPoints[grp.shapes_g.indexOf(shape)].distance_to_line_center=shape.distance_to_line_center; \n      } else{\n        \n          line.positionPoints[grp.shapes_g.indexOf(shape)].x=shape.x;\n          line.positionPoints[grp.shapes_g.indexOf(shape)].y=shape.y;\n          shape.x=e.target.x();\n          shape.y=e.target.y();\n          \n          if(Math.sin(line.rotation*(Math.PI/180))==0){\n            distance_to_line_center=shape.x-line.x;\n          }else{\n            if(Math.sign(shape.x-line.x)!=0){\n              distance_to_line_center=Math.sign(-shape.rotation)*Math.sign(shape.x-line.x)*Math.sqrt((shape.x-line.x)**2+(shape.y-line.y)**2);\n            } else{\n             distance_to_line_center=Math.sign(-shape.rotation)*Math.sign(shape.y-line.y)*Math.sqrt((shape.x-line.x)**2+(shape.y-line.y)**2); \n            }\n          \n            if(shape.rotation*(Math.PI/180)<=-Math.PI/2 || (shape.rotation*(Math.PI/180)<=Math.PI/2 && shape.rotation*(Math.PI/180)>=0)){\n              distance_to_line_center=-distance_to_line_center\n            }\n          }\n          //shape.distance_to_line_center=distance_to_line_center;\n          //grp.line.occupiedDistances[shapes_g.indexOf(shape)]=shape.distance_to_line_center;\n        line.positionPoints[grp.shapes_g.indexOf(shape)].distance_to_line_center=shape.distance_to_line_center;\n          \n      }\n      let pos = { x: shape.x, y: shape.y };\n      this.center.x=shape.x;\n      this.center.y=shape.y;\n      e.target.position(pos);\n      e.target.getLayer().batchDraw();\n      if(!this.isCoordinateOnLine(shape.x,shape.y,line.id)){\n        shape.dragBoundFunc= dragFunc;\n        shape.isGrouped=0;\n        this.shapes.push(shape,)\n        for (let i=0;i<shapes_g.length;i++){\n          if(shapes_g[i].id==shape.id){\n            line.freeDistances.push(line.occupiedDistances[i]);\n            line.occupiedDistances.splice(i,1);\n            shapes_g.splice(i,1);\n            console.log(\"a shape has been removed from the line\");\n          }\n        } \n      }else{\n        if(!line.keepDistribution){\n          grp.line.occupiedDistances[shapes_g.indexOf(shape)]=distance_to_line_center;\n        }else{\n        grp.line.occupiedDistances[shapes_g.indexOf(shape)]=shape.distance_to_line_center;\n        }\n        \n      line.positionPoints[grp.shapes_g.indexOf(shape)].x=shape.x;\n      line.positionPoints[grp.shapes_g.indexOf(shape)].y=shape.y;\n      line.positionPoints[grp.shapes_g.indexOf(shape)].distance_to_line_center=shape.distance_to_line_center;\n      this.updateNaration(grp);\n       \n      }\n      /*\n      let coord_y1=line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x1=line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let coord_y2= line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x2=line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let a=(coord_y1-coord_y2)/(coord_x2-coord_x1);\n      let b=line.y-a*line.x;\n      let is_on_straight_line=false;\n      if(Math.abs(coord_x1-coord_x2)>=1){\n        is_on_straight_line=(Math.abs(a*shape.x+b-shape.y)<1);\n      }else{\n        is_on_straight_line=(Math.abs(shape.x-line.x)<1);\n      }\n      if(\n        !(is_on_straight_line)\n      ||((line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n        ||line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      && ((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>-Math.PI)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>-Math.PI)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>=0)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>=0)))\n      )\n      {\n        shape.dragBoundFunc= dragFunc;\n        this.shapes.push(shape,)\n        for (let i=0;i<shapes_g.length;i++){\n          if(shapes_g[i].id==shape.id){\n            line.freeDistances.push(line.occupiedDistances[i]);\n            line.occupiedDistances.splice(i,1);\n            shapes_g.splice(i,1);\n            console.log(\"a shape has been removed from the line\");\n          }\n        } \n      }else{\n        if(!line.keepDistribution){\n          grp.line.occupiedDistances[shapes_g.indexOf(shape)]=distance_to_line_center;\n        }else{\n        grp.line.occupiedDistances[shapes_g.indexOf(shape)]=shape.distance_to_line_center;\n        }\n      }\n      */\n      //this.updateOccupiedDistance(line.id);\n      \n          if(line.keepDistribution){\n            this.updateOccupiedDistance(line.id);\n          }\n          \n          this.updateAllPosInGrp(line.id);\n    },\n    \n    /*\n    Function called when the transformation of a shape with a transfomer is finished.\n    */\n    updateTransformedShape(e) {\n      \n\n      let res;\n      let shape; //Object concerned by the transformation\n      if(e.target.className==\"Line\"){\n        shape=this.groups.find(\n        (r) => r.id === this.selectedShapeId\n      ).line;\n      }else{\n        res=this.findShape(this.selectedShapeId)\n        shape=res.shape_data;\n        if(shape== undefined){\n          return;\n        }\n      }\n\n      \n      let last_shapex= shape.x;\n      let last_shapey= shape.y;\n\n      //update data of the transformed object.\n      shape.x = e.target.x();\n      shape.y = e.target.y();\n      shape.rotation = e.target.rotation();\n      let last_scaleX= shape.scaleX;\n      shape.scaleX = e.target.scaleX();\n      shape.scaleY = e.target.scaleY();\n\n      if(e.target.className==\"Line\"){\n        const grp=this.groups.find((r)=> r.id===shape.id);\n        if(shape.keepDistribution){\n          for (let i=0;i<shape.occupiedDistances.length;i++){\n            shape.occupiedDistances[i]=(shape.occupiedDistances[i]/last_scaleX)*shape.scaleX;\n          }\n          /*\n          for (let i=0;i<shape.freeDistances.length;i++){\n            shape.freeDistances[i]=(shape.freeDistances[i]/last_scaleX)*shape.scaleX;\n          }\n          */\n          \n          //this.updateOccupiedDistance(shape.id)\n          this.update();\n          this.updateGrp(e, this.selectedShapeId);\n          this.checkIfShapesOnLine(this.selectedShapeId);        \n        }else{\n          \n          \n          \n         if(last_scaleX!=shape.scaleX){\n          for(let i=0;i<grp.shapes_g.length;i++){\n          \n          //If the width of the line has been changed, we update the distance from the shape to the center of the line\n            \n              let distX=grp.shapes_g[i].x-shape.x;\n              let distY=grp.shapes_g[i].y-shape.y;\n              /*\n              if(Math.sign(grp.shapes_g[i].distance_to_line_center)==0){\n                grp.shapes_g[i].distance_to_line_center=-this.GiveSignOfDistance(grp.shapes_g[i],shape)*Math.sqrt((distX)**2 +(distY)**2);\n              \n              }else{\n                grp.shapes_g[i].distance_to_line_center=Math.sign(grp.shapes_g[i].distance_to_line_center)*Math.sqrt((distX)**2 +(distY)**2);\n              }\n              if(Math.sign((grp.shapes_g[i].x-last_shapex))!=Math.sign(distX)){\n                grp.shapes_g[i].distance_to_line_center=-grp.shapes_g[i].distance_to_line_center;\n              }\n              */\n             if(Math.sign(grp.line.occupiedDistances[i])==0){\n                //if(grp.line.rotation!=-90 && grp.line.rotation!=90){\n                  //grp.line.occupiedDistances[i]=-this.GiveSignOfDistance(grp.shapes_g[i],shape)*Math.sqrt((distX)**2 +(distY)**2);\n                //}else{\n                  grp.line.occupiedDistances[i]=this.GiveSignOfDistance(grp.shapes_g[i],shape)*Math.sqrt((distX)**2 +(distY)**2);\n                  \n                //}\n              \n              }else{\n                grp.line.occupiedDistances[i]=Math.sign(grp.line.occupiedDistances[i])*Math.sqrt((distX)**2 +(distY)**2);\n              }\n\n              \n              if(Math.sign((grp.shapes_g[i].x-last_shapex))!=Math.sign(distX) && Math.sign((grp.shapes_g[i].x-last_shapex))!=0 && grp.line.rotation!=90 && grp.line.rotation!=-90){\n                \n                grp.line.occupiedDistances[i]=-grp.line.occupiedDistances[i];\n              }\n              if(Math.sign((grp.shapes_g[i].y-last_shapey))!=Math.sign(distY) && Math.sign((grp.shapes_g[i].y-last_shapey))!=0 && (grp.line.rotation==90 || grp.line.rotation==-90)){\n                grp.line.occupiedDistances[i]=-grp.line.occupiedDistances[i];\n              }\n              //this.checkIfShapesOnLine(this.selectedShapeId);  \n            \n            //this.checkIfShapesOnLine(this.selectedShapeId);\n            //grp.line.occupiedDistances[i]=grp.shapes_g[i].distance_to_line_center;\n            \n          }\n          for (let i=0;i<shape.freeDistances.length;i++){\n            let distX=last_shapex-shape.x;\n            let distY=last_shapey-shape.y; \n            let dist=Math.sqrt(distX**2+distY**2);\n            if(shape.rotation<-90 ||shape.rotation>90){\n              shape.freeDistances[i]=shape.freeDistances[i]-Math.sign(last_shapex-shape.x)*dist;\n            } else if(shape.rotation==90 || shape.rotation==-90){\n              shape.freeDistances[i]=shape.freeDistances[i]-distY\n            } else{\n              shape.freeDistances[i]=shape.freeDistances[i]+Math.sign(last_shapex-shape.x)*dist;\n            \n            }\n          }\n         }\n          this.update();\n          this.updateGrp(e, this.selectedShapeId);\n          this.checkIfShapesOnLine(this.selectedShapeId);\n\n          // We now see if freeDistances need to be delete(so if they are bigger than the half of the stickyline);\n          \n        }\n        for(let i=0;i<grp.shapes_g.length;i++){\n            \n          this.updateDragFunc(grp.shapes_g[i],shape);\n\n        }\n      }else if(res.grp_id!='-1'){\n        //this.update();\n        //let layer=e.target.getParent().getLayer();\n        //layer.batchDraw();\n        this.updateAllPosInGrp(res.grp_id);\n        this.updateOccupiedDistance(res.grp_id);\n        e.target.x(e.target.getParent().attrs.shapes_g.find((r)=>r.id===e.target.id()).x);\n        e.target.y(e.target.getParent().attrs.shapes_g.find((r)=>r.id===e.target.id()).y);\n        this.groups.find((r)=>r.id===res.grp_id).shapes_g.find((r)=>r.id===e.target.id()).personalRotation=e.target.rotation()-e.target.getParent().attrs.line.rotation;\n        \n        \n        this.updateAllPosInGrp(res.grp_id);\n        this.checkIfShapesOnLine(res.grp_id);\n        this.updateDragFuncOfCenter();\n      \n      }\n      else{\n        this.update();\n        \n        this.updateDragFuncOfCenter();\n      }\n      this.center.x=e.target.attrs.x;\n      this.center.y=e.target.attrs.y;\n    },\n    \n    handleTransformation(e) {\n      if (e.evt==undefined) {\n        return;\n      }\n      if(this.eraseMode==1){\n        this.eraserAction(e);\n        return;\n      }\n      \n      //If we click on the stage, we have to remove the transformer from the node where it was.\n      if (e.target === e.target.getStage()) {\n        this.selectedShapeId = 'NoId';\n        this.eraseNodefromTransformer(\"lineTransformer\");\n        this.eraseNodefromTransformer(\"shapeTransformer\");\n        this.center.opacity=0;\n        return;\n      }\n\n      // If we click on a transformer, nothing happen.\n      const clickedOnTransformer = e.target.getParent().className === 'Transformer';\n      if (clickedOnTransformer) {\n        return;\n      }\n      \n      const id = e.target.id();\n      let transformer_id;\n      let shape=this.findShape(id).shape_data;\n\n      //if it is a line, we need the transformer dedicated to the line (ie transformer with id=\"lineTransformer\")\n      //if it is a classic shape, we need the transformer dedicated to the shape (ie transformer with id=\"shapeTransformer\")\n      if(e.target.attrs.id==\"center\"){\n        return;\n      }\n      if(e.target.className==\"Line\"){\n        transformer_id=\"lineTransformer\"\n        shape = this.groups.find((r) => r.id === id).line;\n        this.center.draggable=false;\n        this.selectedShapeAlignment=shape.defaultAlignment;\n        this.eraseNodefromTransformer(\"shapeTransformer\");\n      }else{\n        transformer_id=\"shapeTransformer\"\n        this.center.draggable=true;\n        this.selectedShapeAlignment=shape.centerPosition;\n        this.eraseNodefromTransformer(\"lineTransformer\");\n      }\n      \n      if (shape!=undefined) {\n        this.selectedShapeId = id;\n        this.center.opacity=1;\n        this.updateTransformer(transformer_id);\n      } else{\n        /*Only if the center is not selected.\n        When the center is dragged, this function is called.\n        But a shape is actualy selected (the one of the center).\n        */\n        this.selectedShapeId = 'NoId';\n      }\n      //this.updateTransformer(transformer_id);\n      \n      this.updateDragFuncOfCenter()\n    },\n\n    //remove node from transformer with id=transformer_id\n    eraseNodefromTransformer(transformer_id) {\n      let stage= this.$refs.stage.getStage();      \n      const transformerNode = stage.find(\"#\"+transformer_id)[0]; \n      transformerNode.nodes([]);\n    },\n\n    //Update transformer with id=transformer_id\n    //It places the transformer regarding what node is selected\n    updateTransformer(transformer_id) {\n\n      let stage= this.$refs.stage.getStage();\n      const transformerNode = stage.find(\"#\"+transformer_id)[0];\n      let selectedNode;\n      if (transformer_id==\"lineTransformer\"){\n        selectedNode = stage.children[0].getChildren().filter((r)=> r.attrs.className==\"Group\" && r.attrs.id==this.selectedShapeId)[0]\n        .getChildren().filter(r=>r.attrs.className==\"Line\" && r.attrs.id==this.selectedShapeId)[0];\n      }else{\n      selectedNode = stage.children[0].getChildren().filter((r)=>r.attrs.className!=\"Group\" && r.attrs.id==this.selectedShapeId)[0];\n\n      let isFunded=true;\n      if(selectedNode==undefined){\n        isFunded=false;\n      }\n      let i=0;\n      while(!isFunded){\n        if(i<this.groups.length){\n          selectedNode=stage.children[0].getChildren().filter((r)=>r.attrs.className==\"Group\")[i].getChildren().find((r)=>r.attrs.id==this.selectedShapeId && r.attrs.className!=\"Line\");\n        if(selectedNode==undefined){\n          isFunded=false;\n        }else{\n          isFunded=true;\n        }\n        i++;\n        }else{        \n          isFunded=true;\n        }\n      }\n      }\n      /*\n      if (transformer_id==\"lineTransformer\"){\n        selectedNode = stage.children[0].getChildren().filter((r)=> r.attrs.className==\"Group\" && r.attrs.id==this.selectedShapeId)[0]\n        .getChildren().filter(r=>r.attrs.className==\"Line\" && r.attrs.id==this.selectedShapeId)[0];\n      }\n      */\n     \n      //If the selected node has already the transformer on it, nothing happen\n      if (selectedNode === transformerNode.node()) {\n        return;\n      }\n\n      //If a node is selected\n      if (selectedNode!=undefined) {\n        //We attach the transformer to the node\n        transformerNode.nodes([selectedNode]);\n      } else {\n        //if no node is selected, we remove the transformer from its node.\n        transformerNode.nodes([]);\n      }\n      this.center.x=selectedNode.attrs.x;\n      this.center.y=selectedNode.attrs.y;\n      \n    },\n/*\n  DisplayCenterMenu(e){\n    CenterMenu.props.ConcernedShape=e.target;\n   document.getElementById(\"center_menu\").style.display=\"initial\";\n   document.getElementById(\"center_menu\").style.top=e.target.getStage().getPointerPosition().y+8+\"px\";\n  document.getElementById(\"center_menu\").style.left=e.target.getStage().getPointerPosition().x+8+\"px\";\n  },\n  */\n\n  //display context menu according to the target\n  \n  DisplayContextMenu(e){\n    e.evt.preventDefault()\n    if (e.target.className!=undefined && e.target.attrs.id!=\"center\"){\n      this.isStageOnlySelected=false;\n      ContextMenu.data().dM='initial';\n      this.$emit('needmenu');\n      this.needMenu=true;\n      ContextMenu.props.ConcernedShape=e.target;\n      if (e.target.attrs.className==\"Line\"){\n        this.isALineSelected=true;\n        this.isAGroupedShapeSelected=true;\n        //We precise the text which depends on the line where we clicked.\n        this.keepDistanceButtonText=e.target.attrs.keepDistanceButtonText;\n      } else if(e.target.getParent().attrs.className==\"Group\"){\n        this.isAGroupedShapeSelected=true;\n      }\n      else{\n        this.isALineSelected=false;\n        this.isAGroupedShapeSelected=false;\n      }\n      \n      document.getElementById(\"activeReuseSubstrate\").style.display=\"initial\";\n      document.getElementById(\"activeReuseSubstrate\").style.top= document.getElementById(\"reuseSubstrateDemo\").getBoundingClientRect().top+document.documentElement.scrollTop+e.target.getStage().getPointerPosition().y+\"px\";\n      document.getElementById(\"activeReuseSubstrate\").style.left= document.getElementById(\"reuseSubstrateDemo\").getBoundingClientRect().left+document.documentElement.scrollLeft+e.target.getStage().getPointerPosition().x+\"px\";\n    }\n    if (e.target === e.target.getStage()) {\n      this.needMenu=true;\n      this.isALineSelected=false;\n      this.isAGroupedShapeSelected=false;\n      this.isStageOnlySelected=true;\n      document.getElementById(\"activeReuseSubstrate\").style.display=\"initial\";\n      document.getElementById(\"activeReuseSubstrate\").style.top=document.getElementById(\"reuseSubstrateDemo\").getBoundingClientRect().top+document.documentElement.scrollTop+e.target.getStage().getPointerPosition().y+\"px\";\n      document.getElementById(\"activeReuseSubstrate\").style.left=document.getElementById(\"reuseSubstrateDemo\").getBoundingClientRect().left+document.documentElement.scrollLeft+e.target.getStage().getPointerPosition().x+\"px\";\n    \n    }\n  },\n\n  //hide context menu\n  HideContextMenu(){\n    this.needMenu=false;\n    document.getElementById(\"activeReuseSubstrate\").style.display=\"none\";\n  },\n\n\n  \n ChangeCenter(e){\n  let res=this.findShape(this.selectedShapeId);\n  let shape=res.shape_data;\n  let threshold1;\n  let threshold2;\n  let dist=this.GiveSignOfDistanceBtwCenterAndShape(e.target.attrs,shape)*Math.sqrt((e.target.y()-(shape.y))**2+(e.target.x()-shape.x)**2)+shape.offsetY*shape.scaleY;\n  \n  //let last_offsetX=shape.offsetX;\n  let last_offsetY=shape.offsetY;\n  if(shape==undefined){\n    shape=this.groups.find((r)=>r.id==this.selectedShapeId).line;\n\n  }else{\n    \n      if(shape.className==\"Rect\") {\n        threshold1=shape.height*shape.scaleY/3;\n        threshold2=shape.height*shape.scaleY*2/3;\n        if(dist>=threshold1 && dist<=threshold2){\n          shape.offsetX=shape.width/2;\n          shape.offsetY=shape.height/2;\n          shape.centerPosition=\"Middle\";\n        }else if(dist>threshold2){\n          shape.offsetX=shape.width/2;\n          shape.offsetY=shape.height;\n          shape.centerPosition=\"Bottom\";\n        }\n        else{\n          shape.offsetX=shape.width/2;\n          shape.offsetY=0;\n          shape.centerPosition=\"Top\";\n        }\n      }\n      else if(shape.className==\"Circle\") {\n        dist=dist+shape.radius*shape.scaleY;\n        threshold1=shape.radius*shape.scaleY*2/3;\n        threshold2=shape.radius*shape.scaleY*4/3;\n        if(dist>=threshold1 && dist<=threshold2){\n          shape.offsetX=0;\n          shape.offsetY=0;\n          shape.centerPosition=\"Middle\";\n        }else if(dist>threshold2){\n          shape.offsetX=0;\n          shape.offsetY=shape.radius;\n          shape.centerPosition=\"Bottom\";\n        }else{\n          shape.offsetX=0;\n          shape.offsetY=-shape.radius;\n          shape.centerPosition=\"Top\";\n        } \n      }\n      else if(shape.className==\"Image\") {\n        threshold1=shape.image.height*shape.scaleY/3;\n        threshold2=shape.image.height*shape.scaleY*2/3;\n        if(dist>=threshold1 && dist<=threshold2){\n          shape.offsetX=shape.image.width/2;\n          shape.offsetY=shape.image.height/2;\n          shape.centerPosition=\"Middle\";\n        }else if(dist>threshold2){\n          shape.offsetX=shape.image.width/2;\n          shape.offsetY=shape.image.height;\n          shape.centerPosition=\"Bottom\";\n        }\n        else {\n          shape.offsetX=shape.image.width/2;\n          shape.offsetY=0;\n          shape.centerPosition=\"Top\";\n        }\n      }\n      else if(shape.className==\"Text\") {\n        threshold1=shape.length_y*shape.scaleY/3;\n        threshold2=shape.length_y*shape.scaleY*2/3;\n        if(dist>=threshold1 && dist<=threshold2){\n          shape.offsetX=shape.length_x/2;\n          shape.offsetY=shape.length_y/2;\n          shape.centerPosition=\"Middle\";\n        }else if(dist>threshold2){\n          shape.offsetX=shape.length_x/2;\n          shape.offsetY=shape.length_y;\n          shape.centerPosition=\"Bottom\";\n        }\n        else{\n          shape.offsetX=shape.length_x/2;\n          shape.offsetY=0;\n          shape.centerPosition=\"Top\";\n        }\n      }\n      else if(shape.className==\"Triangle\") {\n        dist=dist+shape.radius*shape.scaleY;\n        threshold1=shape.radius*shape.scaleY/2;\n        threshold2=shape.radius*shape.scaleY*5/4;\n        if(dist>=threshold1 && dist<=threshold2){\n          shape.offsetX=0;\n          shape.offsetY=0;\n        }else if(dist>threshold2){\n          shape.offsetX=0;\n          shape.offsetY=shape.radius/2\n          shape.centerPosition=\"Bottom\";\n        }\n        else{\n          shape.offsetX=0;\n          shape.offsetY=-shape.radius;\n          shape.centerPosition=\"Top\";\n        }\n      }\n      shape.y=shape.y-(last_offsetY-shape.offsetY)*shape.scaleY*Math.cos(shape.rotation*(Math.PI/180));\n      shape.x=shape.x+(last_offsetY-shape.offsetY)*shape.scaleY*Math.sin(shape.rotation*(Math.PI/180));\n      this.selectedShapeAlignment=shape.centerPosition;\n\n      if (res.grp_id!='-1'){\n        this.updateAllPosInGrp(res.grp_id);\n      }\n        \n      e.target.x(shape.x);\n      e.target.y(shape.y);\n\n     \n\n      \n  }\n  },\n  /*\n  ChangeAlignCenter(align_choice){\n    let center=CenterMenu.props.ConcernedShape;\n    let grp=this.groups.find((r)=>r.id===this.selectedShapeId);\n    let shape;\n    if(grp!=undefined){\n      for(let i=0;i<grp.shapes_g.length;i++){\n        this.ChangeCenterRegardingCommand(grp.shapes_g[i].id,align_choice)\n      }\n      center.x(grp.line.x);\n      center.y(grp.line.y);\n      if(grp.line.defaultAlignment==align_choice){\n        grp.line.defaultAlignment='' //If we select again the same alogn_choice, we deselect it, no alignement center is fixed.\n      }else{\n        grp.line.defaultAlignment=align_choice;\n      }\n      this.selectedShapeAlignment=grp.line.defaultAlignment;\n    }else{\n      shape=this.findShape(this.selectedShapeId).shape_data;\n      this.ChangeCenterRegardingCommand(shape.id,align_choice)\n      this.selectedShapeAlignment=shape.centerPosition;\n      center.x(shape.x);\n      center.y(shape.y);\n    }\n  },\n  */\n  //Allow to change the center regarding a text command (Top,Middle or Bottom)\n  ChangeCenterRegardingCommand(shape_id,command){\n    let res=this.findShape(shape_id);\n    let shape=res.shape_data;\n    let last_offsetY=shape.offsetY;\n    if(shape.className==\"Rect\" ){\n      if(command==\"Top\"){\n        shape.offsetY=0;\n        shape.offsetX=shape.width/2;\n      }\n      else if(command==\"Middle\"){\n          shape.offsetX=shape.width/2;\n          shape.offsetY=shape.height/2;\n      }else if(command==\"Bottom\"){\n            shape.offsetX=shape.width/2;\n            shape.offsetY=shape.height;\n      }\n    }\n      else if(shape.className==\"Circle\") {\n        if(command==\"Top\"){\n          shape.offsetX=0;\n          shape.offsetY=-shape.radius;\n        }else if(command==\"Middle\"){\n          shape.offsetX=0;\n          shape.offsetY=0\n        }else if(command==\"Bottom\"){\n          shape.offsetX=0;\n          shape.offsetY=shape.radius;\n        } \n      }\n      else if(shape.className==\"Image\") {\n        if(command==\"Middle\"){\n          shape.offsetX=shape.image.width/2;\n          shape.offsetY=shape.image.height/2;\n        }else if(command==\"Bottom\"){\n          shape.offsetX=shape.image.width/2;\n          shape.offsetY=shape.image.height;\n        }\n        else if (command==\"Top\"){\n          shape.offsetX=shape.image.width/2;\n          shape.offsetY=0;\n        }\n      }\n      else if(shape.className==\"Text\") {\n        if(command==\"Middle\"){\n          shape.offsetX=shape.length_x/2;\n          shape.offsetY=shape.length_y/2;\n        }else if(command==\"Bottom\"){\n          shape.offsetX=shape.length_x/2;\n          shape.offsetY=shape.length_y;\n        }\n        else if(command==\"Top\"){\n          shape.offsetX=shape.length_x/2;\n          shape.offsetY=0;\n        }\n      }\n      else if(shape.className==\"Triangle\") {\n        if(command==\"Middle\"){\n          shape.offsetX=0;\n          shape.offsetY=0;\n        }else if(command==\"Bottom\"){\n          shape.offsetX=0;\n          shape.offsetY=shape.radius/2;\n        }\n        else if(command==\"Top\"){\n          shape.offsetX=0;\n          shape.offsetY=-shape.radius;\n        }\n      }\n      shape.centerPosition=command;\n      shape.y=shape.y-(last_offsetY-shape.offsetY)*shape.scaleY*Math.cos(shape.rotation*(Math.PI/180));\n      shape.x=shape.x+(last_offsetY-shape.offsetY)*shape.scaleY*Math.sin(shape.rotation*(Math.PI/180));\n\n      if (res.grp_id!='-1'){\n        this.updateAllPosInGrp(res.grp_id);\n      }\n        \n      //center.x(shape.x);\n      //center.y(shape.y);\n  },\n  updateDragFuncOfCenter(){\n    let shape=this.findShape(this.selectedShapeId).shape_data\n    let center=this.center;\n    let angle=shape.rotation*(Math.PI/180);\n    if(angle>=-Math.PI/2 && angle<=0){\n      angle-=90*(Math.PI/180);\n    }else if(angle<-Math.PI/2){\n      angle+=(Math.PI/2);\n      angle=Math.PI+angle;\n    } else if(angle<=Math.PI && angle>0){\n      angle-=90*(Math.PI/180);\n    } \n    if (angle<=0 && angle>=-Math.PI/4){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x +(pos.x-shape.x)*Math.cos(angle),\n          y: shape.y+(pos.x-shape.x)*Math.sin(angle),\n        };\n      }\n    } else if (angle<-Math.PI/4 && angle>=-Math.PI/2){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x-(pos.y-shape.y)*Math.cos(angle),\n          y: shape.y-(pos.y-shape.y)*Math.sin(angle),\n        };\n      }\n    }\n    else if (angle<-Math.PI/2 && angle>=-3*Math.PI/4){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x-(pos.y-shape.y)*Math.cos(angle),\n          y: shape.y-(pos.y-shape.y)*Math.sin(angle),\n        };\n      }\n    } else if (angle<-3*Math.PI/4 && angle>=-Math.PI){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x-(pos.x-shape.x)*Math.cos(angle),\n          y: shape.y-(pos.x-shape.x)*Math.sin(angle),\n        };\n      }\n    }else if (angle<=Math.PI && angle>=3*Math.PI/4){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x-(pos.x-shape.x)*Math.cos(angle),\n          y: shape.y-(pos.x-shape.x)*Math.sin(angle),\n        };\n      }\n    } else if (angle<3*Math.PI/4 && angle>=Math.PI/2){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x+(pos.y-shape.y)*Math.cos(angle),\n          y: shape.y+(pos.y-shape.y)*Math.sin(angle),\n        };\n      }\n    } else if (angle<Math.PI/2 && angle>=Math.PI/4){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x+(pos.y-shape.y)*Math.cos(angle),\n          y: shape.y+(pos.y-shape.y)*Math.sin(angle),\n        };\n      }\n    }else if (angle<Math.PI/4 && angle>=0){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x+(pos.x-shape.x)*Math.cos(angle),\n          y: shape.y+(pos.x-shape.x)*Math.sin(angle),\n        };\n      }\n    }\n  },\n  MovingCenter(){\n    //let shape=this.findShape(this.selectedShapeId)\n    //console.log(e.target)\n  },\n  /*\n  //called when the \"Change Center\" button is clicked\n  ChangeCenterButtonAction(){\n      let shape= ContextMenu.props.ConcernedShape;\n      if(shape.attrs.className==\"Line\"){\n        let shapes_g=shape.getParent().attrs.shapes_g //the list of the shapes which are on the line is in the corresponding group.\n        for (let j=0;j<shapes_g.length;j++){\n          this.ChangeCenter(shapes_g[j]);\n        }\n      }else{\n        let shape_data=this.shapes.find(i => i.id ===shape.attrs.id);\n        let isFunded=true;\n        if(shape_data==undefined){\n          isFunded=false;\n        }\n        let i=0;\n        while(!isFunded){\n          if(i<this.groups.length){\n            shape_data=this.groups[i].shapes_g.find(i => i.id === shape.attrs.id);\n          if(shape_data==undefined){\n            isFunded=false;\n          }else{\n            isFunded=true;\n          }\n          i++;\n          }else{        \n            isFunded=true;\n          }\n        }\n        this.ChangeCenter(shape_data)\n      }\n    },\n    */\n    \n    //allow to copy a target\n    \n    Copy(){\n      ContextMenu.props.CopiedShape=ContextMenu.props.ConcernedShape;\n      ContextMenu.props.pastOneObject=true;\n    },\n    \n    CopyAll(){\n      ContextMenu.props.CopiedShape=ContextMenu.props.ConcernedShape;\n      ContextMenu.props.pastOneObject=false;\n    },\n    \n    Past(){   \n      //Prevent error when no shape is copied\n      if(ContextMenu.props.CopiedShape.attrs==undefined){\n        return;\n      }\n      let clone=ContextMenu.props.CopiedShape.clone({\n        id: ''+this.max_id_figures,\n      })\n      //let layer=ContextMenu.props.CopiedShape.getLayer();\n      let i= this.groups.length\n      //let new_id=i+1;\n      if(ContextMenu.props.CopiedShape.attrs.className==\"Line\"){\n        this.max_id_figures=this.max_id_figures+1;\n        if(!ContextMenu.props.pastOneObject){\n          //let i= this.groups.length;\n          //let new_id=i+1;\n        \n          clone=ContextMenu.props.CopiedShape.getParent().clone({\n            id: ''+ this.max_id_figures,\n            name: \"group\"+this.max_id_figures,\n            shapes_g:[],\n          })\n          clone.attrs.line.id=''+this.max_id_figures;\n          clone.attrs.line.x=ContextMenu.props.ConcernedShape.getStage().getPointerPosition().x;\n          clone.attrs.line.y=ContextMenu.props.ConcernedShape.getStage().getPointerPosition().y;\n          let positionPoints=Object.assign([],clone.attrs.line.positionPoints);\n            let length=positionPoints.length;\n            clone.attrs.line.positionPoints=[];\n            for(let i=0;i<length.valueOf();i++){\n              let clone_positionPoint=ContextMenu.props.CopiedShape.getParent().getChildren().find((r)=>r.attrs.id===positionPoints[i].id).clone({\n              id:'positionPoint'+clone.attrs.line.id+i,\n              });\n              clone.attrs.line.positionPoints.push(clone_positionPoint.attrs,);\n            }\n          \n          //layer= ContextMenu.props.CopiedShape.getParent().getLayer();\n          this.groups.push(clone.attrs,);\n          let shapesg=this.groups[this.groups.indexOf(this.groups.find((r)=> r.id==ContextMenu.props.CopiedShape.getParent().attrs.id))].shapes_g;\n          let shapesg_length=shapesg.length;\n          for (let j=0; j<shapesg_length;j++){\n            this.max_id_figures=this.max_id_figures + 1;\n            let clone_shape=ContextMenu.props.CopiedShape.getParent().getChildren().find((r)=>r.attrs.id===shapesg[j].id).clone({\n              id:''+this.max_id_figures,\n            });\n           // this.updateDragFunc(clone_shape,clone_line);\n            this.groups[i].shapes_g.push(clone_shape.attrs,);\n            this.updateDragFunc(this.groups[i].shapes_g[this.groups[i].shapes_g.length-1],this.groups[i].line);\n          }\n          this.updateAllPosInGrp(clone.attrs.id);\n        }else{\n          //let i= this.groups.length;\n          //let new_id=i+1;\n        \n          clone=ContextMenu.props.CopiedShape.getParent().clone({\n            id: ''+this.max_id_figures,\n            name: \"group\"+this.max_id_figures,\n            shapes_g:[],\n          })\n          clone.attrs.line.id=''+this.max_id_figures;\n          clone.attrs.line.x=ContextMenu.props.ConcernedShape.getStage().getPointerPosition().x;\n          clone.attrs.line.y=ContextMenu.props.ConcernedShape.getStage().getPointerPosition().y;\n          for(let j=0;j<clone.attrs.line.occupiedDistances.length;j++){\n            clone.attrs.line.freeDistances.push(clone.attrs.line.occupiedDistances[j],);\n          }\n          clone.attrs.line.occupiedDistances=[];\n          if(clone.attrs.line.keepDistribution!=1){\n            let positionPoints=Object.assign([],clone.attrs.line.positionPoints);\n            let length=positionPoints.length;\n            clone.attrs.line.positionPoints=[];\n            for(let i=0;i<length.valueOf();i++){\n              let clone_positionPoint=ContextMenu.props.CopiedShape.getParent().getChildren().find((r)=>r.attrs.id===positionPoints[i].id).clone({\n              id:'positionPoint'+clone.attrs.line.id+i,\n              });\n              clone.attrs.line.positionPoints.push(clone_positionPoint.attrs,);\n            }\n          }\n          //layer= ContextMenu.props.CopiedShape.getParent().getLayer();\n          this.groups.push(clone.attrs,)\n        }\n        this.updateNaration(this.groups[this.groups.length-1]);\n        //In order to actualize the new line (in particular to show the positionPoints):\n        this.updateAllPosInGrp(clone.attrs.id);\n      } \n      else{\n        this.max_id_figures=this.max_id_figures + 1;\n        clone=ContextMenu.props.CopiedShape.clone({\n          id: ''+this.max_id_figures,  \n          x:ContextMenu.props.ConcernedShape.getStage().getPointerPosition().x,\n          y:ContextMenu.props.ConcernedShape.getStage().getPointerPosition().y,\n        });\n        clone.attrs.dragBoundFunc=function (pos) {\n          return {\n            x: pos.x,\n            y: pos.y,\n          };\n        };\n        clone.attrs.isGrouped=0;\n        this.shapes.push(clone.attrs,); \n         \n      }\n      //layer.batchDraw(); \n      \n    },\n    //RemoveShape(shape)\n    Remove(shape){\n      //let shape=ContextMenu.props.ConcernedShape;\n      if(shape.attrs.className==\"Line\"){\n        let grp=this.groups.find((r)=>r.id===shape.attrs.id);\n        const length=grp.shapes_g.length;\n        for(let i=0;i<length;i++){\n          grp.shapes_g[i].dragBoundFunc= dragFunc;\n          grp.shapes_g[i].isGrouped=0;\n          this.shapes.push(grp.shapes_g[i],);\n        }\n        this.eraseNodefromTransformer(\"lineTransformer\");\n        this.groups.splice(this.groups.indexOf(grp),1);\n        shape.getParent().destroy();\n\n        //We give to the circle (representing center of shapes) a default position\n        if(this.groups[0]!=undefined){\n          this.center.x=this.groups[0].line.x;\n          this.center.y=this.groups[0].line.y;\n        } else if(this.shapes[0]!=undefined){\n          this.center.x=this.shapes[0].x;\n          this.center.y=this.shapes[0].y;\n        }\n        this.center.opacity=0;\n        \n      }else if(shape.attrs.className==\"positionPoint\"){\n        let line=shape.getParent().attrs.line;\n        let target_positionPoint=line.positionPoints.find((r)=>r.id===shape.attrs.id);\n        let index=line.freeDistances.indexOf(shape.attrs.distance_to_line_center);\n        \n        if(line.keepDistribution!=1 && index!=-1){\n          line.freeDistances.splice(index,1);\n          line.positionPoints.splice(line.positionPoints.indexOf(target_positionPoint),1)\n        }\n      }\n      else{\n        let res=this.findShape(shape.attrs.id)\n        let shape_data=res.shape_data;\n        let grp_id=res.grp_id;\n        if(shape_data!=undefined){\n        if(grp_id!='-1'){\n        //let shape_data=this.shapes.find(i => i.id ===shape.attrs.id);\n        let grp=this.groups.find((r)=>r.id===grp_id);\n          grp.line.freeDistances.push(grp.line.occupiedDistances[grp.shapes_g.indexOf(shape_data)],)\n          grp.line.occupiedDistances.splice(grp.shapes_g.indexOf(shape_data),1)\n          \n          grp.shapes_g.splice(grp.shapes_g.indexOf(shape_data),1);\n          this.updateOccupiedDistance(grp.id);\n          \n          this.updateAllPosInGrp(grp.id);\n          \n         \n      \n        } else{\n          this.eraseNodefromTransformer(\"shapeTransformer\");\n          this.shapes.splice(this.shapes.indexOf(shape_data),1);\n          //We give to the circle (representing center of shapes) a default position\n          if(this.groups[0]!=undefined){\n            this.center.x=this.groups[0].line.x;\n            this.center.y=this.groups[0].line.y;\n          } else if(this.shapes[0]!=undefined){\n            this.center.x=this.shapes[0].x;\n            this.center.y=this.shapes[0].y;\n          }\n          this.center.opacity=0;\n        }\n        shape.destroy();\n        }\n      }\n    },\n\n    RemoveAll(){\n      let shape=ContextMenu.props.ConcernedShape;\n      if(shape.className==\"Line\"){\n        let grp=this.groups.find((r)=>r.id===shape.attrs.id);\n        while(grp.shapes_g.length!=0){\n          grp.shapes_g[0].dragBoundFunc= dragFunc;\n          grp.shapes_g.splice(0,1);\n        }\n        this.eraseNodefromTransformer(\"lineTransformer\");\n        this.groups.splice(this.groups.indexOf(grp),1);\n        shape.getParent().destroy();\n\n        //We give to the circle (representing center of shapes) a default position\n        if(this.groups[0]!=undefined){\n          this.center.x=this.groups[0].line.x;\n          this.center.y=this.groups[0].line.y;\n        } else if(this.shapes[0]!=undefined){\n          this.center.x=this.shapes[0].x;\n          this.center.y=this.shapes[0].y;\n        }\n        \n      }else{\n        return;\n      }\n    },\n    \n\n    findShape(id){\n      let shape_data=this.shapes.find(i => i.id ===id);\n      let grp_id='-1'; // return grp_id=-1 if the shape doesn't belong to attached group.\n      let isFunded=true;\n      if(shape_data==undefined){\n        isFunded=false;\n      }\n      let i=0;\n      while(!isFunded){\n        if(i<this.groups.length){\n          shape_data=this.groups[i].shapes_g.find(i => i.id === id);\n        if(shape_data==undefined){\n          isFunded=false;\n        }else{\n          grp_id=this.groups[i].id; \n          isFunded=true;\n        }\n        i++;\n        }else{        \n          isFunded=true;\n        }\n      }\n      return {shape_data, grp_id}\n    },\n\n    //detach a shape from its line.\n    DetachShape(shape,target_x,target_y){\n      \n      const added_distance=this.lengthToCapture+5;\n      let grp=this.groups.find((r)=>r.shapes_g.indexOf(shape)!=-1);\n      let i=grp.shapes_g.indexOf(shape);\n      shape.dragBoundFunc= dragFunc;\n      console.log(grp.shapes_g)\n      \n\n      let coord_y1=grp.line.y-grp.line.points[4]*(1/2)*grp.line.scaleX*Math.sin(grp.line.rotation*(Math.PI/180));\n      let coord_x2=grp.line.x+grp.line.points[4]*(1/2)*grp.line.scaleX*Math.cos(grp.line.rotation*(Math.PI/180));\n      let coord_y2= grp.line.y+grp.line.points[4]*(1/2)*grp.line.scaleX*Math.sin(grp.line.rotation*(Math.PI/180));\n      let coord_x1=grp.line.x-grp.line.points[4]*(1/2)*grp.line.scaleX*Math.cos(grp.line.rotation*(Math.PI/180));\n      let a=(coord_y2-coord_y1)/(coord_x2-coord_x1);\n      //let b=grp.line.y-a*grp.line.x;\n      let b=shape.x*(1/a)+shape.y;\n      if (grp.line.rotation<0 && grp.line.rotation>-45){\n        \n        shape.x=shape.x+Math.sign(shape.y-target_y)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } else if (grp.line.rotation<=-45 && grp.line.rotation>-90){\n        \n        shape.x=shape.x+Math.sign(shape.x-target_x)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      }\n      \n      else if(grp.line.rotation<-90 && grp.line.rotation>-135){\n        shape.x=shape.x+Math.sign(shape.x-target_x)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } \n      else if(grp.line.rotation<=-135 && grp.line.rotation>-180){\n        shape.x=shape.x-Math.sign(shape.y-target_y)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } \n      \n      else if( grp.line.rotation>135 && grp.line.rotation<180){\n        \n        shape.x=shape.x-Math.sign(shape.y-target_y)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } else if( grp.line.rotation>90 && grp.line.rotation<=135){\n        \n        shape.x=shape.x-Math.sign(shape.x-target_x)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } else if( grp.line.rotation>45 && grp.line.rotation<=90){\n        \n        shape.x=shape.x-Math.sign(shape.x-target_x)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } else if( grp.line.rotation>0 && grp.line.rotation<=45){\n        \n        shape.x=shape.x+Math.sign(shape.y-target_y)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } \n      else if(grp.line.rotation==-90){\n        shape.x=shape.x-Math.sign(shape.x-target_x)*added_distance\n      } else if(grp.line.rotation==90){\n        shape.x=shape.x+Math.sign(shape.x-target_x)*added_distance\n      } else if(grp.line.rotation==180 || grp.line.rotation==-180){\n        shape.y=shape.y-Math.sign(shape.y-target_y)*added_distance\n      } else if(grp.line.rotation==0){\n        shape.y=shape.y-Math.sign(shape.y-target_y)*added_distance\n      } \n      //shape.rotation=shape.rotation+shape.personalRotation;\n      shape.isGrouped=0;\n      this.shapes.push(shape,)\n      this.center.x=shape.x;\n      this.center.y=shape.y;\n      grp.line.freeDistances.push(grp.line.occupiedDistances[i]);\n      grp.line.occupiedDistances.splice(i,1);\n      grp.shapes_g.splice(i,1);\n      if(grp.line.keepDistribution){\n        grp.line.positionPoints.splice(i,1)\n      }\n      this.updateOccupiedDistance(grp.id)\n      this.updateAllPosInGrp(grp.id);\n      this.updateNaration(grp)\n      \n      this.eraseNodefromTransformer(\"shapeTransformer\");\n    \n    },\n    /*\n    DetachShape(shape){\n      \n      const added_distance=this.lengthToCapture+5;\n      let grp=this.groups.find((r)=>r.shapes_g.indexOf(shape)!=-1);\n      let i=grp.shapes_g.indexOf(shape);\n      shape.dragBoundFunc= dragFunc;\n      console.log(grp.shapes_g)\n      \n\n      let coord_y1=grp.line.y-grp.line.points[4]*(1/2)*grp.line.scaleX*Math.sin(grp.line.rotation*(Math.PI/180));\n      let coord_x2=grp.line.x+grp.line.points[4]*(1/2)*grp.line.scaleX*Math.cos(grp.line.rotation*(Math.PI/180));\n      let coord_y2= grp.line.y+grp.line.points[4]*(1/2)*grp.line.scaleX*Math.sin(grp.line.rotation*(Math.PI/180));\n      let coord_x1=grp.line.x-grp.line.points[4]*(1/2)*grp.line.scaleX*Math.cos(grp.line.rotation*(Math.PI/180));\n      let a=(coord_y2-coord_y1)/(coord_x2-coord_x1);\n      //let b=grp.line.y-a*grp.line.x;\n      let b=shape.x*(1/a)+shape.y;\n      if (grp.line.rotation<0 && grp.line.rotation>-90){\n        \n        shape.x=shape.x-added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } else if(grp.line.rotation<-90){\n        shape.x=shape.x-added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } else if( grp.line.rotation>0 && grp.line.rotation<180){\n        \n        shape.x=shape.x+added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } \n      else if(grp.line.rotation==-90){\n        shape.x=shape.x+added_distance\n      } else if(grp.line.rotation==90){\n        shape.x=shape.x-added_distance\n      } else if(grp.line.rotation==180 || grp.line.rotation==-180){\n        shape.y=shape.y-added_distance\n      } else if(grp.line.rotation==0){\n        shape.y=shape.y-added_distance;\n      } \n      //shape.rotation=shape.rotation+shape.personalRotation;\n      shape.isGrouped=0;\n      this.shapes.push(shape,)\n      this.center.x=shape.x;\n      this.center.y=shape.y;\n      grp.line.freeDistances.push(grp.line.occupiedDistances[i]);\n      grp.line.occupiedDistances.splice(i,1);\n      grp.shapes_g.splice(i,1);\n      if(grp.line.keepDistribution){\n        grp.line.positionPoints.splice(i,1)\n      }\n      this.updateOccupiedDistance(grp.id)\n      this.updateAllPosInGrp(grp.id)\n    \n    },\n    */\n    /*\n\n    //called when the button \"Detach Shape\" is clicked\n    DetachShapeButtonAction(){\n      let shape= ContextMenu.props.ConcernedShape;\n      if(shape.attrs.className==\"Line\"){\n        let shapes_g=shape.getParent().attrs.shapes_g;\n        while(shapes_g.length!=0){\n          this.DetachShape(shapes_g[0]);\n        }\n      }else{\n        let shape_data=this.shapes.find(i => i.id ===shape.attrs.id);\n        let isFunded=true;\n        if(shape_data==undefined){\n          isFunded=false;\n        }\n        let i=0;\n        while(!isFunded){\n          if(i<this.groups.length){\n            shape_data=this.groups[i].shapes_g.find(i => i.id === shape.attrs.id);\n          if(shape_data==undefined){\n            isFunded=false;\n          }else{\n            isFunded=true;\n          }\n          i++;\n          }else{        \n            isFunded=true;\n          }\n        }\n        this.DetachShape(shape_data)\n      }\n    },\n\n    //called when the button \"keep/liberate distribution\" is clicked.\n    KeepDistribution(){\n      let grp=this.groups.find(i => i.id === ContextMenu.props.ConcernedShape.attrs.id);\n      let line=grp.line;\n      if(line==undefined){\n        return;\n      }else{\n        if(line.keepDistribution){\n          line.keepDistribution=false;\n          for (let i=0;i<grp.shapes_g.length;i++){\n            grp.shapes_g[i].distance_to_line_center=line.occupiedDistances[i]\n          }\n          line.freeDistances=[];\n\n          line.stroke='blue'\n          grp.line.keepDistanceButtonText=\"Keep Distribution\";\n          //ContextMenu.props.ConcernedShape.attrs.keepDistanceButtonText=\"Keep Distribution\";\n        }else{\n          line.keepDistribution=true;\n          for (let i=0;i<grp.shapes_g.length;i++){\n            line.occupiedDistances[i]=grp.shapes_g[i].distance_to_line_center;\n          }\n          line.stroke='black'\n          grp.line.keepDistanceButtonText=\"Liberate Distribution\";\n          //ContextMenu.props.ConcernedShape.attrs.keepDistanceButtonText=\"Liberate Distribution\";\n          this.updateOccupiedDistance(line.id);\n          this.updateAllPosInGrp(line.id);\n        }\n      }\n    },\n    */\n    createNewShape(shape){\n      if(shape.attrs.className==\"Line\"){\n        \n        this.max_id_figures=this.max_id_figures+1;\n\n          let clone=shape.getParent().clone({\n            id: ''+this.max_id_figures,\n            name: \"group\"+this.max_id_figures,\n            shapes_g:[],\n          })\n          clone.attrs.line.id=''+this.max_id_figures;\n          clone.attrs.line.x=shape.getStage().getPointerPosition().x;\n          clone.attrs.line.y=shape.getStage().getPointerPosition().y;\n          clone.attrs.line.draggable=true;\n          this.groups.push(clone.attrs,)\n          \n        \n      }else{\n        \n        this.max_id_figures=this.max_id_figures+1\n        let clone=shape.clone({\n          id: ''+this.max_id_figures,\n          draggable: true,\n        })\n        clone.attrs.isGrouped=0;\n        this.shapes.push(clone.attrs,);\n      }\n      \n\n    },\n    \n  \n  eraserAction(e){\n    this.Remove(e.target);\n    \n  },\n  unshowSelectedShape(e){\n    if(e.target.attrs.className==\"Line\" && this.eraseMode==0){\n      e.target.opacity(0.5)\n    }\n    else if(e.target.attrs.className==\"Line\" && this.eraseMode==1){\n      if(e.target.attrs.keepDistribution==1){\n        e.target.stroke(\"rgb(48,48,48)\")\n      }else{\n        e.target.stroke(\"blue\")\n      }\n    }\n    else if(e.target.attrs.className==\"positionPoint\" && this.eraseMode==1){\n      if(e.target.getParent().attrs.line.keepDistribution!=1){\n        e.target.strokeWidth(0)\n      }\n    }\n    else if(this.eraseMode==1){\n      e.target.strokeWidth(0)\n    }\n  },\n  showSelectedShape(e){\n    if(e.target.attrs.className==\"Line\" && this.eraseMode==0){\n      e.target.opacity(1)\n    }\n    else if(e.target.attrs.className==\"Line\" && this.eraseMode==1){\n      e.target.stroke('rgb(200, 59, 218)')\n    }\n    else if(e.target.attrs.className==\"positionPoint\" && this.eraseMode==1){\n      let line=e.target.getParent().attrs.line;\n      if(line.freeDistances.indexOf(e.target.attrs.distance_to_line_center)!=-1){\n        if(line.keepDistribution!=1){\n          e.target.stroke('rgb(200, 59, 218)')\n          e.target.strokeWidth(3)\n        }\n      }\n    }\n    else if(this.eraseMode==1){\n      e.target.stroke('rgb(200, 59, 218)')\n      e.target.strokeWidth(3)\n    }\n    /*\n    let shape=e.target;\n    if(this.eraseMode==1){\n    let shape_data=this.shapes.find(i => i.id ===shape.attrs.id);\n    let isFunded=true;\n    if(shape_data==undefined){\n      isFunded=false;\n      let i=0;\n      while(!isFunded){\n        if(i<this.groups.length){\n          shape_data=this.groups[i].shapes_g.find(i => i.id === shape.attrs.id);\n        if(shape_data==undefined){\n          isFunded=false;\n          i++;\n        }else{\n          isFunded=true;\n        }\n        }else{        \n          isFunded=true;\n        }\n      }\n    }\n    if (shape_data!=undefined){\n      shape_data.opacity=0.3\n    }\n    */\n\n  },\n  editText(e){\n    //let valuey=document.getElementById(\"stage\").style.top+e.target.y()\n    //let valuex=document.getElementById(\"stage\").style.left+e.target.x()\n    let stageBox=e.target.getStage().attrs.container.getBoundingClientRect();\n    document.getElementById(\"input\").style.top=stageBox.y+e.target.getAbsolutePosition().y+'px';\n    document.getElementById(\"input\").style.left=stageBox.x+e.target.getAbsolutePosition().x-document.getElementById(\"input\").size*5+'px';\n    document.getElementById(\"input\").style.display=\"initial\"\n    this.editedText=e.target\n  },\n  updateText(e){\n    let shape=this.shapes.find(i => i.id ===this.editedText.attrs.id);\n    let isFunded=true;\n    if(shape==undefined){\n      isFunded=false;\n    }\n    let i=0;\n    while(!isFunded){\n      if(i<this.groups.length){\n        shape=this.groups[i].shapes_g.find(i => i.id === this.editedText.attrs.id);\n      if(shape==undefined){\n        isFunded=false;\n      }else{\n        isFunded=true;\n      }\n      i++;\n      }else{        \n        isFunded=true;\n      }\n    }\n    if(shape!=undefined){\n    let last_width;\n    let last_height;\n    let diff_width;\n    let diff_height;\n\n    last_width=this.editedText.width();\n    last_height=this.editedText.height();\n\n    shape.text=e.target.value;\n\n    this.editedText.text(e.target.value);\n    diff_width=this.editedText.width()-last_width;\n    diff_height=this.editedText.height()-last_height;\n\n    \n    shape.offsetX=shape.offsetX+diff_width/2\n    shape.offsetY=shape.offsetY+diff_height/2\n    shape.length_x=this.editedText.width()\n    shape.length_y=this.editedText.height()\n    document.getElementById(\"input\").style.display=\"none\"\n    }\n\n  },\n  \n  updateNaration(grp){\n      let text;\n      if(grp.line.id==1){\n      text=\"<strong>Substrate with id=\"+grp.id+\":</strong><br>\"\n      text=text+\"- <mark class='blue'> StickyLine\"+\" with id=\"+ grp.line.id+\"</mark><br>\";\n      }else{\n       text=\"<strong>Copied substrate with id=\"+grp.id+\":</strong><br>\";\n       text=text+\"- <mark class='blue'> copied StickyLine\"+\" with id=\"+ grp.line.id+\"</mark><br>\"; \n      }\n      text=text+\"Relation: <i>alignement and distance with</i>:\";\n      for(let j=0;j<grp.shapes_g.length;j++){\n        text=text+\"<br>\"+\"- \"+grp.shapes_g[j].className+\" with id=\"+grp.shapes_g[j].id\n      }\n      text=text+\"<br>Distance kept in memory:\"\n      //+grp.line.occupiedDistances+\",<mark class='green'>\"+grp.line.freeDistances+\"</mark>\";\n      for(let i=0;i<grp.line.occupiedDistances.length;i++){\n        text=text+grp.line.occupiedDistances[i].toFixed(1)+\",\";\n      }\n      text=text+\"<mark class='green'>\"\n      for(let i=0;i<grp.line.freeDistances.length-1;i++){\n        text=text+grp.line.freeDistances[i].toFixed(1)+\",\";\n      }if(grp.line.freeDistances.length>0){\n      text=text+grp.line.freeDistances[grp.line.freeDistances.length-1].toFixed(1);\n      }\n      text=text+\"</mark>\"\n      this.$emit('explain',{origin:\"Substrate - Reuse<br><mark class='blue'> The substrate consists of the Stickyline and the objects that it applies to, and can be reused together. </mark>\",text:text});\n  },\n\n  //In order to initialize the naration for this canvas.\n  initialNaration(groups){\n    if(!this.narationHasBeenInitialized){\n      let grp;\n      let text=''; \n    for(let i=0;i<groups.length-1;i++){\n      grp=groups[i];\n      if(grp.line.id==1){\n      text=text+\"<strong>Substrate with id=\"+grp.id+\":</strong><br>\"\n      text=text+\"- <mark class='blue'> StickyLine\"+\" with id=\"+ grp.line.id+\"</mark><br>\";\n      }else{\n       text=text+\"<strong>Copied substrate with id=\"+grp.id+\":</strong><br>\";\n       text=text+\"- <mark class='blue'> copied StickyLine\"+\" with id=\"+ grp.line.id+\"</mark><br>\"; \n      }\n      text=text+\"Relation: <i>alignement and distance with</i>:\";\n      for(let j=0;j<grp.shapes_g.length;j++){\n        text=text+\"<br>\"+\"- \"+grp.shapes_g[j].className+\" with id=\"+grp.shapes_g[j].id\n      }\n      text=text+\"<br>Distance kept in memory:\"\n      //+grp.line.occupiedDistances+\",<mark class='green'>\"+grp.line.freeDistances+\"</mark>\";\n      for(let i=0;i<grp.line.occupiedDistances.length;i++){\n        text=text+grp.line.occupiedDistances[i].toFixed(1)+\",\";\n      }\n      text=text+\"<mark class='green'>\"\n      for(let i=0;i<grp.line.freeDistances.length-1;i++){\n        text=text+grp.line.freeDistances[i].toFixed(1)+\",\";\n      }if(grp.line.freeDistances.length>0){\n      text=text+grp.line.freeDistances[grp.line.freeDistances.length-1].toFixed(1);\n      }\n      text=text+\"</mark>\"\n      text=text+\"<br>***<br>\"\n    }\n    grp=groups[groups.length-1]\n      if(grp.line.id==1){\n      text=text+\"<strong>Substrate with id=\"+grp.id+\":</strong><br>\"\n      text=text+\"- <mark class='blue'> StickyLine\"+\" with id=\"+ grp.line.id+\"</mark><br>\";\n      }else{\n       text=text+\"<strong>Copied substrate with id=\"+grp.id+\":</strong><br>\";\n       text=text+\"- <mark class='blue'> copied StickyLine\"+\" with id=\"+ grp.line.id+\"</mark><br>\"; \n      }\n      text=text+\"Relation: <i>alignement and distance with</i>:\";\n      for(let j=0;j<grp.shapes_g.length;j++){\n        text=text+\"<br>\"+\"- \"+grp.shapes_g[j].className+\" with id=\"+grp.shapes_g[j].id\n      }\n      text=text+\"<br>Distance kept in memory:\"\n      //+grp.line.occupiedDistances+\",<mark class='green'>\"+grp.line.freeDistances+\"</mark>\";\n      for(let i=0;i<grp.line.occupiedDistances.length;i++){\n        text=text+grp.line.occupiedDistances[i].toFixed(1)+\",\";\n      }\n      text=text+\"<mark class='green'>\"\n      for(let i=0;i<grp.line.freeDistances.length-1;i++){\n        text=text+grp.line.freeDistances[i].toFixed(1)+\",\";\n      }if(grp.line.freeDistances.length>0){\n      text=text+grp.line.freeDistances[grp.line.freeDistances.length-1].toFixed(1);\n      }\n      text=text+\"</mark>\"\n      \n      this.narationHasBeenInitialized=true\n      this.$emit('explain',{origin:\"Substrate - Reuse<br><mark class='blue'> The substrate consists of the Stickyline and the objects that it applies to, and can be reused together. </mark>\",text:text});\n      //In order to avoid the copy of things from one cell to another.\n      ContextMenu.props.CopiedShape=undefined;\n    }\n  },\n  stopInitialisation(e){\n    console.log(\"stop\")\n      this.narationHasBeenInitialized=true;\n      e.stopPropagation();\n  }\n},\n};\n\n</script>\n<style>\n#playground{\n  cursor: default\n}\n#activeReuseSubstrate{\n  position:absolute;\n  display: none;\n  top: 0px;\n  left: 0px;\n  width: 60px;\n  background-color: white;\n  box-shadow: 0 0 5px grey;\n  border-radius: 3px;\n}\n#center_menu{\n  position: absolute;\n  display: none;\n  top: 0px;\n  left: 0px;\n  width: 60px;\n  background-color: white;\n  box-shadow: 0 0 5px grey;\n  border-radius: 3px;\n}\ninput{\n  position:absolute;\n  display: none;\n  top:0px;\n  left:0px; \n}\n</style> ","import { render } from \"./ReuseSubstrateDemo.vue?vue&type=template&id=7c813266\"\nimport script from \"./ReuseSubstrateDemo.vue?vue&type=script&lang=js\"\nexport * from \"./ReuseSubstrateDemo.vue?vue&type=script&lang=js\"\n\nimport \"./ReuseSubstrateDemo.vue?vue&type=style&index=0&id=7c813266&lang=css\"\n\nimport exportComponent from \"/Users/junhangyu/Desktop/PE code/github/teachingApp/node_modules/vue-loader/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render]])\n\nexport default __exports__","<template>\n\n<div @click=\"HideContextMenu\" id=\"ReificationSubstrateDemo\"\n@mousedown=\"updateNaration(this.groups[0])\">\n<!--\n  <ToolBar :height=\"100\" :width=\"400\"\n  @need_new_shape=\"createNewShape\" @eraser_is_selected=\"switchEraseMode\"></ToolBar>\n  -->\n  <v-stage\n    ref=\"stage\"\n    id=\"stage\"\n    :config=\"stageSize\"\n    @dragmove=\"update\"\n    @mousedown=\"handleTransformation\"\n    @touchstart=\"handleTransformation\"\n    @fusion=\"makeGroup\"\n    @contextMenu=\"DisplayContextMenu\"\n  >\n    <v-layer ref=\"layer\">\n      <!--\n        see if a group should contain more than one line\n      -->\n      <!--\n      <v-circle :key=\"center.id\" :config=\"center\"/>\n      -->\n      <v-group ref=\"groups\" v-for=\"step in groups\" :key=\"step.id\" :config=\"step\">\n      \n      \n      \n        <v-rect\n        v-for=\"item in step.shapes_g.filter(i=>i.className=='Rect')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        \n       \n        @transformend=\"updateTransformedShape\"\n        @dragend= \"updatePosInGrp($event,step.id) \"\n        @dragmove=\"CheckIfNeedToDetach\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n      />\n      <v-circle\n        v-for=\"item in step.shapes_g.filter(i=>i.className=='Circle')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragend=\"updatePosInGrp($event,step.id)\"\n        @dragmove=\"CheckIfNeedToDetach\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n      />\n      \n      <v-image\n        v-for=\"item in step.shapes_g.filter(i=>i.className=='Image')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragend=\"updatePosInGrp($event,step.id)\"\n        @dragmove=\"CheckIfNeedToDetach\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n      />\n      <v-text\n        v-for=\"item in step.shapes_g.filter(i=>i.className=='Text')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragend=\"updatePosInGrp($event,step.id)\"\n        @dragmove=\"CheckIfNeedToDetach\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n\n        @dblclick=\"editText\"\n        />\n        <v-regular-polygon\n        v-for=\"item in step.shapes_g.filter(i=>i.className=='Triangle')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragend=\"updatePosInGrp($event,step.id)\"\n        @dragmove=\"CheckIfNeedToDetach\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n      />\n        <v-line \n        :key=\"step.line.id\"\n        :config=\"step.line\"\n        @transformend=\"updateTransformedShape\"\n        @dragmove=\"updateGrp($event,step.id)\"\n        @mouseout=\"unshowSelectedShape\"\n        @mouseenter=\"showSelectedShape\"\n        />\n    <v-circle\n        v-for=\"item in step.line.positionPoints\"\n        :key=\"item.id\"\n        :config=\"item\"\n        \n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n      />\n      </v-group>\n      <v-rect\n        v-for=\"item in shapes.filter(i=>i.className=='Rect')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragmove=\"updatePos\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n        \n      />\n      \n      <v-circle\n        v-for=\"item in shapes.filter(i=>i.className=='Circle')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragmove=\"updatePos\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n        \n      />\n      <!--\n      <v-image\n        v-for=\"item in shapes.filter(i=>i.className=='Image')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragmove=\"updatePos\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n        />\n     \n      <v-text\n        v-for=\"item in shapes.filter(i=>i.className=='Text')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragmove=\"updatePos\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n        \n        @dblclick=\"editText\"\n        /> \n      -->\n      <v-regular-polygon\n        v-for=\"item in shapes.filter(i=>i.className=='Triangle')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragmove=\"updatePos\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n        />\n      \n      \n      <v-transformer  v-for=\"item in transformers\" :key=\"item.id\" :config=\"item\"/>\n      <v-circle :key=\"center.id\" :config=\"center\"\n      @dragend=\"ChangeCenter\"\n      @click=\"DisplayCenterMenu\"/>\n      <!--\n      <v-transformer id=\"shapeTransformer\"/>\n      <v-transformer id=\"lineTransformer\" :config=\"{enabledAnchors: ['middle-left', 'middle-right'],}\" />\n      -->\n    </v-layer>\n    \n  </v-stage>\n  \n  <!--\n  <div id=\"activeReuseSubstrate\">\n  <ContextMenu :menu-of-stage=\"isStageOnlySelected\" :menu-of-line=isALineSelected \n  :menu-of-grouped-shape=isAGroupedShapeSelected :keep-distance-button-text=\"this.keepDistanceButtonText\" \n  :need-copy-button=\"false\" :need-switch-distribution-mode-button=\"false\"\n  @changecenter-button=\"ChangeCenterButtonAction\" @detachshape-button=\"DetachShapeButtonAction\" @keepdistance-button=\"KeepDistribution\"\n  @copy-button=\"Copy\" @copy-all-button=\"CopyAll\" @past-button=\"Past\" @remove-button=\"Remove\" @remove-all-button=\"RemoveAll\"></ContextMenu>\n  </div>\n  -->\n  <!--\n  <div id=\"center_menu\">\n  <CenterMenu :defaultAlignment=\"this.selectedShapeAlignment\" @center-button=\"ChangeAlignCenter\"></CenterMenu>\n  </div>\n  -->\n  \n  \n  </div>\n</template>\n\n<script>\n\n//import ContextMenu from \"./ContextMenu.vue\"\n//import CenterMenu from \"./CenterMenu.vue\"\n//import ToolBar from \"./ToolBar.vue\";\n\nconst dragFunc=function (pos) {\n  let width=this.getStage().width();\n  let height=this.getStage().height();\n  let strokeSize=10\n    if(pos.x>width-strokeSize && pos.y>height-strokeSize){\n      return{\n        x: width-strokeSize,\n        y: height-strokeSize,\n      }\n    } else if(pos.x>width-strokeSize && pos.y<strokeSize){\n      return{\n        x: width-strokeSize,\n        y: strokeSize,\n      }\n    } else if(pos.y>height-strokeSize && pos.x<strokeSize){\n      return{\n        x: strokeSize,\n        y: height-strokeSize,\n      }\n    } else if(pos.x<strokeSize && pos.y<strokeSize){\n      return{\n        x: strokeSize,\n        y: strokeSize,\n      }\n    } else if(pos.x<strokeSize){\n      return{\n        x: strokeSize,\n        y: pos.y,\n      }\n    }else if(pos.y<strokeSize){\n      return{\n        x: pos.x,\n        y: strokeSize,\n      }\n    }else if(pos.x>width-strokeSize){\n      return{\n        x: width-strokeSize,\n        y: pos.y,\n      }\n    }else if(pos.y>height-strokeSize){\n      return{\n        x: pos.x,\n        y: height-strokeSize,\n      }\n    } else{\n      return {\n        x: pos.x,\n        y: pos.y,\n      };\n    }\n};\n\n\nexport default {\n  props:{\n    width:{\n      type: Number,\n      default:window.innerWidth,\n    },\n    height:{\n      type: Number,\n      default:window.innerHeight,\n    }\n  },\n  components:{\n    //ContextMenu,\n    //CenterMenu,\n    //ToolBar,\n},\n  data() {\n    return {\n      stageSize: {\n        width: this.width,\n        height: this.height,\n      },\n      lengthToCapture:10,\n      lengthToDetach:15,\n      editedText:null,\n\n      eraseMode:0,\n\n      selectedShapeAlignment:'',\n      \n      needMenu: 'initial', //say if the context menu has to be \"active\" or not.\n      isALineSelected:false, \n      isAGroupedShapeSelected:false,\n      isStageOnlySelected: false,\n      //dragItemId: null, //id of the item which is dragging.\n      //text which will appear on the button corresponding to the management of the distribution\n      keepDistanceButtonText:\"Liberate Distribution\",\n      max_id_figures: 6, //max among id of shapes and line since the canvas exist (line excluded) \n      //max_id_lines: 2, //max among id of lines since the canvas exist (line excluded) \n      //groups of shapes (ie a line with shapes on it)\n      \n\n      groups:[{\n        //rotation: 20,\n        name: \"group\",\n        className: \"Group\",\n        id: '1',\n        x:0,\n        y:0,\n        offsetX:0,\n        offsetY:0,\n        rotation: 0,\n        draggable: false,\n        shapes_g:[ {\n        rotation:0,\n        x: 30,\n        y: 220,\n        scaleX:1,\n        scaleY:1,\n        offsetX: 0,\n        offsetY: 40,\n        radius: 40,\n        fill: 'orange',\n        strokeWidth: 0,\n        stroke: 'black',\n        draggable:true,\n        isGrouped: 1,\n        className:\"Circle\",\n        /*When it is on a line, a shape can be rotate by the user independently from the line.\n          To keep the independant rotation of the attached shape, we add the parameter \"personalRotation\".\n          So, when the shape is attached, is final rotation is the sum of this parameter with the rotation of the line.\n          */\n        personalRotation:0, \n        id:'6',\n        dragBoundFunc: dragFunc,\n        centerPosition:'Bottom',\n      },{\n          rotation: 0,\n          id:'8',\n          x: 150,\n          y: 220,\n          width: 70,\n          height: 70,\n          scaleX: 1,\n          scaleY: 1,\n          strokeWidth: 0,\n          stroke: 'black',\n          fill: 'green',\n          name: 'rect2',\n          draggable: true,\n          className:\"Rect\",\n          isGrouped: 0,\n          dragBoundFunc: dragFunc,\n          offsetX: 70/2,\n          offsetY: 70,\n          /*When it is on a line, a shape can be rotate by the user independently from the line.\n          To keep the independant rotation of the attached shape, we add the parameter \"personalRotation\".\n          So, when the shape is attached, is final rotation is the sum of this parameter with the rotation of the line.\n          */\n          personalRotation:0, \n          centerPosition:'Bottom',\n        },{\n          rotation: 0,\n          id:'7',\n          x: 250,\n          y: 220,\n          sides:3,\n          radius:45,\n          width: 90,\n          height: 90,\n          scaleX: 1,\n          scaleY: 1,\n          strokeWidth: 0,\n          stroke: 'black',\n          fill: 'purple',\n          name: 'triangle1',\n          draggable: true,\n          className:\"Triangle\",\n          isGrouped: 0,\n          dragBoundFunc: dragFunc,\n          offsetX: 0,\n          offsetY: 22.5,\n          personalRotation:0, \n          centerPosition:'Bottom',\n        },], //list of shapes that are on the line\n        //the line of the group:\n        aShapeHasBeenDetach:0,\n        line:{\n          x:150,\n          y:220,\n          points: [0, 0, 0, 0, 250, 0],\n          positionPoints:[{\n        x: 300,\n        y: 500,\n        scaleX:1,\n        scaleY:1,\n        offsetX: 0,\n        offsetY: 0,\n        radius: 3,\n        fill: 'yellow',\n        opacity:1,\n        draggable:false,\n        isGrouped: 0,\n        className:\"positionPoint\",\n        id:'positionPoint1',\n        distance_to_line_center:undefined,\n      },{\n        x: 300,\n        y: 500,\n        scaleX:1,\n        scaleY:1,\n        offsetX: 0,\n        offsetY: 0,\n        radius: 3,\n        fill: 'yellow',\n        opacity:1,\n        draggable:false,\n        isGrouped: 0,\n        className:\"positionPoint\",\n        id:'positionPoint2',\n        distance_to_line_center:undefined,\n      },{\n        x: 300,\n        y: 500,\n        scaleX:1,\n        scaleY:1,\n        offsetX: 0,\n        offsetY: 0,\n        radius: 3,\n        fill: 'yellow',\n        opacity:1,\n        draggable:false,\n        isGrouped: 0,\n        className:\"positionPoint\",\n        id:'positionPoint3',\n        distance_to_line_center:undefined,\n      },],\n          strokeWidth: 10,\n          rotation: 0,\n          tension:0,\n          closed: true,\n          draggable: true,\n          scaleX:1,\n          scaleY:1,\n          opacity:0.5,\n          offset:{\n            x:125,\n            y:0,\n          },\n          name: \"ligne\",\n          className: \"Line\",\n          stroke: 'red',\n          id:'1',\n          //distShapesToCenter:[],\n          keepDistribution: false, //say of we keep the distribution on the line or not\n          freeDistances:[], // distance that can be taken by other shapes (if we keep distribution on the line).\n          occupiedDistances:[-95,-15,100], //distance already \"taken\" by shapes on the line.       \n          //text which will appear on the button corresponding to the management of the distribution:\n          keepDistanceButtonText:\"Liberate Distribution\",\n          //function which determine how the line can be dragged:\n          defaultAlignment:\"Bottom\",\n          dragBoundFunc: dragFunc,\n        },\n      },\n      /*{\n        name: \"group2\",\n        className: \"Group\",\n        id: '7',\n        x:0,\n        y:0,\n        offsetX:0,\n        offsetY:0,\n        rotation: 0,\n        draggable: false,\n        shapes_g:[],\n        line:{\n        x:500,\n        y:300,\n        points: [0, 0, 0, 0, 300, 0],\n        positionPoints:[],\n        strokeWidth: 10,\n        rotation: 0,\n        tension:0,\n        closed: true,\n        draggable: true,\n        scaleX:1,\n        scaleY:1,\n        opacity:0.5,\n        offset:{\n          x:150,\n          y:0,\n        },\n        //draggable:true,\n        name: \"ligne\",\n        className: \"Line\",\n        stroke: 'black',\n        id:'7',\n        distShapesToCenter:[],\n        keepDistribution: true,\n        freeDistances:[],\n        occupiedDistances:[],\n        keepDistanceButtonText:\"Liberate Distribution\",\n        defaultAlignment:\"Middle\",\n        dragBoundFunc: dragFunc,\n      },\n      \n      }*/\n      ],\n      transformers:[\n        {\n          id: 'lineTransformer',\n          enabledAnchors: [],\n          rotateEnabled: false,\n          borderEnabled:false,\n          flipEnabled: false, // in order to not have a rotation of the transformer which lead to problem related to shapes position on a line\n          nodes: [],\n\n        },\n        {\n          id: 'shapeTransformer',\n          nodes: [],\n        }\n      ],\n      shapes: [],\n      center:{\n        x: 300,\n        y: 500,\n        scaleX:1,\n        scaleY:1,\n        offsetX: 0,\n        offsetY: 0,\n        radius: 4,\n        fill: 'black',\n        opacity:1,\n        draggable:true,\n        isGrouped: 0,\n        className:\"Circle\",\n        id:'center',\n        dragBoundFunc:dragFunc,\n      },\n      positionPoint:{\n        x: 300,\n        y: 500,\n        scaleX:1,\n        scaleY:1,\n        offsetX: 0,\n        offsetY: 0,\n        radius: 3,\n        fill: 'yellow',\n        opacity:1,\n        draggable:false,\n        isGrouped: 0,\n        className:\"positionPoint\",\n        id:'positionPoint',\n        distance_to_line_center:undefined,\n      },\n      selectedShapeId: '',\n    };\n  },\n  mounted(){\n    let texts=this.$refs.stage.getStage().getChildren()[0].getChildren().filter((r)=>r.attrs.className=='Text');\n    \n    \n    for(let i=0;i<texts.length;i++){\n      texts[i].attrs.length_x=texts[i].width();\n      texts[i].attrs.length_y=texts[i].height();\n      texts[i].offsetX(texts[i].attrs.length_x/2);\n    }\n    let grp=this.groups[0];\n    let line=grp.line;\n    let shapes_g=grp.shapes_g;\n    for(let i=0;i<shapes_g.length;i++){\n      this.updateDragFunc(shapes_g[i],line);\n      \n      this.updateAllPosInGrp(grp.id);\n    }\n  },\n  created(){\n    //nb of shapes on the canvas (line excluded), we consider that there is no shape on line:\n    this.max_id_figures=this.shapes.length +this.groups.length; \n    //this.max_id_lines=this.groups.length;\n    /*\n    const image = new window.Image();\n    image.src = require(\"@/assets/exsitu.png\");\n    // set image only when it is loaded\n    image.height=150;\n    image.width=150;\n    image.onload = () => {\n      this.shapes.find((r)=>r.className===\"Image\").image= image;\n      this.shapes.find((r)=>r.className===\"Image\").offsetX=image.width/2;\n      this.shapes.find((r)=>r.className===\"Image\").offsetY=0; \n    };\n    */\n    \n  },\n  methods: {\n\n    switchEraseMode(){\n      if(this.eraseMode==0){\n        this.eraseMode=1;\n        document.getElementById(\"playground\").style.cursor='url('+require('@/assets/ugly_eraser.png')+'),default';\n        \n      this.eraseNodefromTransformer(\"shapeTransformer\");\n      this.eraseNodefromTransformer(\"lineTransformer\");\n      } else{\n        this.eraseMode=0;\n        document.getElementById(\"playground\").style.cursor=\"default\";\n      }\n    },\n    /*\n    Check if all shapes that are supposed to be on a line still in this line.\n    id_grp is the id of the group which contains the line.\n    */\n    checkIfShapesOnLine(id_grp){\n      const grp= this.groups.find((r) => r.id===id_grp);\n      const line=grp.line;\n      const groupedShapes = grp.shapes_g;\n      //const lengthToDetach=10;\n      \n      /*\n      To determine if a shape is on a line, we see if the point is not on the corresponding\n      straight line y=a*x+b regarding certains intervals for x and y.Those intervals depends of the rotation of\n      the line. \n      */\n     /*\n      let coord_y1=line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x1=line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let coord_y2= line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x2=line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let a=(coord_y1-coord_y2)/(coord_x2-coord_x1);\n      let b=line.y-a*line.x;\n      let is_on_straight_line=false;\n      */\n      \n      let i=0;\n      while(i<groupedShapes.length){\n        /*\n        if(Math.abs(coord_x1-coord_x2)>1){\n        is_on_straight_line=(Math.abs(a*groupedShapes[i].x+b-groupedShapes[i].y)<this.lengthToDetach);\n      }else{\n        is_on_straight_line=(Math.abs(groupedShapes[i].x-line.x)<this.lengthToDetach);\n      }\n        if (\n          !(is_on_straight_line)\n        ||((line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].y\n        ||line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].y)\n        && ((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n        ||((line.x+line.points[4]*line.scaleX*(1/2)*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].x\n        ||line.x-line.points[4]*line.scaleX*(1/2)*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].x)\n        &&((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n        ||((line.y+line.points[4]*line.scaleX*(1/2)*Math.sin(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].y\n        ||line.y-line.points[4]*line.scaleX*(1/2)*Math.sin(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].y)\n        &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>=-Math.PI)))\n\n        ||((line.x+line.points[4]*line.scaleX*(1/2)*Math.cos(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].x\n        ||line.x-line.points[4]*line.scaleX*(1/2)*Math.cos(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].x)\n        &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>=-Math.PI)))\n\n        ||((line.y+line.points[4]*line.scaleX*(1/2)*Math.sin(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].y\n        ||line.y-line.points[4]*line.scaleX*(1/2)*Math.sin(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].y)\n        &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n        ||((line.x+line.points[4]*line.scaleX*(1/2)*Math.cos(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].x\n        ||line.x-line.points[4]*line.scaleX*(1/2)*Math.cos(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].x)\n        &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n        ||((line.y+line.points[4]*line.scaleX*(1/2)*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].y\n        ||line.y-line.points[4]*line.scaleX*(1/2)*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].y)\n        &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>0)))\n\n        ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].x\n        ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].x)\n        &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>0)))\n        )\n        */\n       if(!this.isCoordinateOnLine(groupedShapes[i].x,groupedShapes[i].y,line.id)){\n          console.log(\"a shape is not on a line\");\n          groupedShapes[i].dragBoundFunc= dragFunc;\n          groupedShapes[i].isGrouped=0;\n          line.positionPoints.splice(i,1)\n          \n          this.shapes.push(groupedShapes[i],)\n          line.freeDistances.push(line.occupiedDistances[i]);\n          line.occupiedDistances.splice(i,1);\n          groupedShapes.splice(i,1);\n          \n          this.updateNaration(grp)\n        }else{\n          i=i+1;\n        }\n      }\n    },\n\n    //say of {x,y} is a point from the line\n    isCoordinateOnLine(x,y,id_grp){\n      const grp=this.groups.find((r) => r.id===id_grp);\n      const line=grp.line;\n      let is_not_on_straight_line=true;\n      let coord_y1=line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x1=line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let coord_y2= line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x2=line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let a=(coord_y1-coord_y2)/(coord_x2-coord_x1);\n      let b=line.y-a*line.x;\n      if(Math.abs(coord_x1-coord_x2)>1){\n        is_not_on_straight_line=(Math.abs(a*x+b-y)>1);\n      }else{\n        is_not_on_straight_line=(Math.abs(x-line.x)>1)\n      }\n      if(\n        (is_not_on_straight_line)\n\n      ||((line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<y\n      ||line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>y)\n      && ((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<x\n        ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>x)\n      &&((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<y\n        ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>y)\n      &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>-Math.PI)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>x)\n      &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>-Math.PI)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>y)\n      &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>x)\n      &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>y)\n      &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>=0)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>x)\n      &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>=0)))\n\n      ||(!is_not_on_straight_line && Math.sqrt((line.x-x)**2+(line.y-y)**2)>line.points[4]*line.scaleX/2)\n\n      )\n      {\n        return false; \n      } else{\n        return true;\n      }\n    },\n\n    //update a group with the id id_grp\n    updateGrp(e,id_grp){\n      const grep=this.groups.find((r)=>r.id===id_grp);\n      const line= grep.line;\n      grep.offsetX=line.offsetX;\n      grep.offsetY=line.offsetY;\n      \n      line.x=e.target.x();\n      line.y=e.target.y();\n      this.center.x=line.x;\n      this.center.y=line.y;\n      /*\n      if(line.keepDistribution){\n        this.updateOccupiedDistance(line.id);\n      }\n      */\n      this.updateAllPosInGrp(line.id); \n      this.checkIfShapesOnLine(line.id);\n    },\n\n\n    //update the position of all shapes that are on the line of the group with the id id_grp.\n    updateAllPosInGrp(id_grp){\n      const grp= this.groups.find((r) => r.id===id_grp);     \n      const line= grp.line;\n      const shapes_g = grp.shapes_g;\n      for (let i=0;i<shapes_g.length;i++){\n          if(line.keepDistribution){\n            shapes_g[i].x=line.x+line.occupiedDistances[i]*Math.cos(line.rotation*(Math.PI/180));\n            shapes_g[i].y=line.y+line.occupiedDistances[i]*Math.sin(line.rotation*(Math.PI/180));\n            shapes_g[i].distance_to_line_center=line.occupiedDistances[i];\n            shapes_g[i].rotation=shapes_g[i].personalRotation+line.rotation;\n            \n          } else{\n            shapes_g[i].x=line.x+line.occupiedDistances[i]*Math.cos(line.rotation*(Math.PI/180));\n            shapes_g[i].y=line.y+line.occupiedDistances[i]*Math.sin(line.rotation*(Math.PI/180));\n            shapes_g[i].distance_to_line_center=line.occupiedDistances[i];\n            shapes_g[i].rotation=shapes_g[i].personalRotation+line.rotation;\n          }\n          line.positionPoints[i].x=shapes_g[i].x;\n          line.positionPoints[i].y=shapes_g[i].y;\n          line.positionPoints[i].distance_to_line_center=shapes_g[i].distance_to_line_center;\n      }\n      let i=shapes_g.length;\n      while(i<line.positionPoints.length){\n        if(line.keepDistribution){\n          line.positionPoints.splice(i,1);\n        }else{\n        line.positionPoints[i].x=line.x+line.freeDistances[i-shapes_g.length]*Math.cos(line.rotation*(Math.PI/180));\n        line.positionPoints[i].y=line.y+line.freeDistances[i-shapes_g.length]*Math.sin(line.rotation*(Math.PI/180));\n        line.positionPoints[i].distance_to_line_center=line.freeDistances[i-shapes_g.length];\n        i++;\n        }\n        \n      }\n    \n    },\n    isOutsideTheLine(shape,line){\n      let coord_y1=line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x1=line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let coord_y2= line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x2=line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let a=(coord_y1-coord_y2)/(coord_x2-coord_x1);\n      let b=line.y-a*line.x;\n      let is_on_straight_line=false;\n      if(Math.abs(coord_x1-coord_x2)>=1){\n        is_on_straight_line=(Math.abs(a*shape.x+b-shape.y)<1);\n      }else{\n        is_on_straight_line=(Math.abs(shape.x-line.x)<1);\n      }\n      if(\n        !(is_on_straight_line)\n      ||((line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n        ||line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      && ((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>-Math.PI)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>-Math.PI)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>=0)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>=0)))\n      ){\n        return true;\n      }else{ return false}\n    },\n    \n    //update the canvas\n    update(){\n      const shapes = this.shapes\n      \n      //const lengthToCapture=10; //bigger is the number, bigger is the intervals of x and y where a shape can be added to a line.\n      let is_on_straight_line=false;\n      for (let i=0;i<shapes.length;i++){\n        let x=shapes[i].x;\n        let y=shapes[i].y;\n      for (let j=0;j<this.groups.length;j++){\n      \n        let line=this.groups[j].line;\n\n        \n        let coord_y1=line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n        let coord_x1=line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n        let coord_y2= line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n        let coord_x2=line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n        let a=(coord_y1-coord_y2)/(coord_x2-coord_x1);\n        let b=line.y-a*line.x;\n        if(Math.abs(coord_x1-coord_x2)>1){\n          is_on_straight_line=(Math.abs(a*x+b-y)<=this.lengthToCapture);\n        }else{\n          is_on_straight_line=(Math.abs(x-line.x)<=this.lengthToCapture);\n          //is_on_straight_line=true;\n        }\n        if(\n        (\n          is_on_straight_line\n      &&(line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToCapture>=y\n      && line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToCapture<=y)\n      &&(line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToCapture>=x\n      && line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToCapture<=x)\n      &&(line.rotation*(Math.PI/180)<=0 \n      && line.rotation*(Math.PI/180)>-Math.PI/2))\n\n      ||(\n        is_on_straight_line\n      &&(line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))+this.lengthToCapture>=y\n      && line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))-this.lengthToCapture<=y) \n      &&(line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))+this.lengthToCapture>=x\n      && line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))-this.lengthToCapture<=x)\n      &&(line.rotation*(Math.PI/180)<=-Math.PI/2 \n      && line.rotation*(Math.PI/180)>=-Math.PI))\n\n      ||(\n        is_on_straight_line\n      &&(line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))+this.lengthToCapture>=y\n      &&line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))-this.lengthToCapture<=y)\n      &&(line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))+this.lengthToCapture>=x\n      && line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))-this.lengthToCapture<=x)\n      &&(line.rotation*(Math.PI/180)<=Math.PI \n      && line.rotation*(Math.PI/180)>Math.PI/2))\n\n      ||(\n        is_on_straight_line\n      &&(line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToCapture>=y\n      && line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToCapture<=y)\n      &&(line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToCapture>=x\n      && line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToCapture<=x)\n      &&(line.rotation*(Math.PI/180)<=Math.PI/2\n      && line.rotation*(Math.PI/180)>=0))\n      )\n       {\n          shapes[i].isGrouped=1;\n          this.makeGroup(line.id);\n        }\n      }\n      }\n    },\n\n    CheckIfNeedToDetach(e){\n      let grp=this.groups.find((r)=>r.id===e.target.getParent().attrs.id);\n      let shape= grp.shapes_g.find((r)=>r.id==e.target.id());\n      let dist=Math.sqrt((e.target.getStage().getPointerPosition().y-e.target.y())**2+(e.target.getStage().getPointerPosition().x-e.target.x())**2);\n      if(e.target.className==\"Rect\"){\n        dist-=e.target.attrs.height*e.target.attrs.scaleY;\n      } else if(e.target.className==\"Circle\"){\n        dist-=(2*e.target.attrs.radius)*e.target.attrs.scaleY;\n      } else if(e.target.className==\"Text\"){\n        dist-=e.target.attrs.length_y*e.target.attrs.scaleY;\n      } else if(e.target.className==\"Image\"){\n        dist-=e.target.height()*e.target.scaleY();\n      } else if(e.target.attrs.className==\"Triangle\"){\n        dist-=e.target.height()*e.target.scaleY();\n      } \n      \n      if (dist>50){\n        //let shape= this.groups.find((r)=>r.id===e.target.getParent().attrs.id).shapes_g.find((r)=>r.id==e.target.id());\n        //this.groups.find((r)=>r.id===e.target.getParent().attrs.id).shapes_g.find((r)=>r.id==e.target.id()).needToBeDetach=1;\n        /*\n        shape.dragBoundFunc= function (pos) {\n              return {\n                x: pos.x,\n                y: pos.y,\n              };\n        }\n        */\n        //shape.x=e.target.getStage().getPointerPosition().x;\n        //shape.y=e.target.getStage().getPointerPosition().y;\n        //if (Math.abs(e.target.getStage().getPointerPosition().y-e.target.y())>220){\n          \n        //shape.x=e.target.getStage().getPointerPosition().x;\n        //shape.y=e.target.getStage().getPointerPosition().y;\n        this.groups.find((r)=>r.id===e.target.getParent().attrs.id).aShapeHasBeenDetach=1;\n        this.DetachShape(shape,e.target.getStage().getPointerPosition().x,e.target.getStage().getPointerPosition().y);\n        \n        \n        \n        \n      }\n    },\n\n    //Give the sign of the distance of shape from the center of a line.\n    GiveSignOfDistance(shape,line){\n      let result;\n      let angle=line.rotation*(Math.PI/180);\n      let distX=shape.x-line.x;\n      let distY=shape.y-line.y;\n      /*\n      \n      if(angle<=-Math.PI/4 || angle>=-Math.PI/2){\n        result=-Math.sign(distY);\n      }\n      else if(angle<=-Math.PI/2 || angle>=-3*Math.PI/4){\n        result=Math.sign(distY);\n      }\n      else if(angle<=-3*Math.PI/4 || angle>=-Math.PI){\n        result=-Math.sign(distX);\n      }else if(angle>=3*Math.PI/4 || angle<=Math.PI){\n        result=Math.sign(distX);\n      }else if(angle>=Math.PI/2 || angle<3*Math.PI/4){\n        result=-Math.sign(distY);\n      } else if(angle<=Math.PI/2 || angle>Math.PI/4){\n        result=-Math.sign(distY);\n      } else if(angle<=Math.PI/4 || angle>=0){\n        result=Math.sign(distX);\n      }\n      */\n      \n      \n      if(Math.abs(distX)<=this.lengthToCapture && line.rotation==-90){\n        \n        result=-Math.sign(distY);\n      } else if (Math.abs(distX)<=this.lengthToCapture && line.rotation==90){\n        result=Math.sign(distY);\n      }\n      else{\n        result=Math.sign(distX);\n      }\n      if(angle<-Math.PI/2 || angle>Math.PI/2){\n        result=-result;\n      }\n      \n      return result;\n    },\n\n    //Different from the previous function bcs the straight line of the center is perdendicular to the line\n    GiveSignOfDistanceBtwCenterAndShape(center,shape){\n      let result;\n      let angle=shape.rotation*(Math.PI/180);\n      let distX=center.x-shape.x;\n      let distY=center.y-shape.y;\n      /*\n      \n      if(angle<=-Math.PI/4 || angle>=-Math.PI/2){\n        result=-Math.sign(distY);\n      }\n      else if(angle<=-Math.PI/2 || angle>=-3*Math.PI/4){\n        result=Math.sign(distY);\n      }\n      else if(angle<=-3*Math.PI/4 || angle>=-Math.PI){\n        result=-Math.sign(distX);\n      }else if(angle>=3*Math.PI/4 || angle<=Math.PI){\n        result=Math.sign(distX);\n      }else if(angle>=Math.PI/2 || angle<3*Math.PI/4){\n        result=-Math.sign(distY);\n      } else if(angle<=Math.PI/2 || angle>Math.PI/4){\n        result=-Math.sign(distY);\n      } else if(angle<=Math.PI/4 || angle>=0){\n        result=Math.sign(distX);\n      }\n      */\n      \n      \n      if(Math.abs(distY)<=this.lengthToCapture && shape.rotation==-90){\n        \n        result=Math.sign(distX);\n      } else if (Math.abs(distY)<=this.lengthToCapture && shape.rotation==90){\n        result=-Math.sign(distX);\n      }\n      else{\n        result=Math.sign(distY);\n      }\n      if(angle<-Math.PI/2 || angle>Math.PI/2){\n        result=-result;\n      }\n      \n      return result;\n    },\n\n    /*add shapes with isGrouped==1 to the group with the id id_grp.\n    */\n    makeGroup(id_grp){\n      this.eraseNodefromTransformer(\"shapeTransformer\");\n      this.eraseNodefromTransformer(\"lineTransformer\");\n      const grp=this.groups.find((r)=> r.id===id_grp);\n      const line=grp.line;\n      const shapes = this.shapes;\n      line.freeDistances.sort(this.isSmaller); //we will give the shortest available distance to the added shape\n      shapes.sort(this.isBeforeRegardingX);\n      for (let i=0;i<shapes.length;i++){\n        if(shapes[i].isGrouped==1){\n          const positionPoint=Object.assign({},this.positionPoint);\n          let distX=shapes[i].x-line.x;\n          let distY=shapes[i].y-line.y; \n          shapes[i].personalRotation=0;\n          //let pot_dist=this.GiveSignOfDistance(shapes[i],line)*Math.sqrt((distX)**2+(distY)**2);\n          /*\n          if(line.keepDistribution && line.freeDistances.length>0){\n          let distances=line.freeDistances+line.occupiedDistances;\n          console.log(distances);\n           let freeDistance=this.isNearest(line.freeDistances,pot_dist);\n           //shapes[i].distance_to_line_center=freeDistance.res; \n           shapes[i].distance_to_line_center=this.GiveSignOfDistance(shapes[i],line)*Math.sqrt((distX)**2+(distY)**2);\n            \n           line.occupiedDistances.push(shapes[i].distance_to_line_center,);\n           line.freeDistances.splice(freeDistance.indice,1);\n\n          } else{\n            */\n            //let distX=shapes[i].x-line.x;\n            //let distY=shapes[i].y-line.y;\n            shapes[i].distance_to_line_center=this.GiveSignOfDistance(shapes[i],line)*Math.sqrt((distX)**2+(distY)**2);\n            /*If the distance is a little bit to far from the center \n            we adjust it so that the shape can be at one of the border of the stickyline*/\n            if(Math.abs(shapes[i].distance_to_line_center)>=line.points[4]*line.scaleX/2){\n              shapes[i].distance_to_line_center=Math.sign(shapes[i].distance_to_line_center)*line.points[4]*line.scaleX/2\n            }\n            this.ChangeCenterRegardingCommand(shapes[i].id,grp.line.defaultAlignment);\n            \n              //shapes[i].isGrouped=0;\n              this.updateDragFunc(shapes[i],line);\n              grp.shapes_g.push(shapes[i],);\n              console.log(\"no 'free distance' anymore\")\n              grp.line.occupiedDistances.push(shapes[i].distance_to_line_center,);\n              positionPoint.id=\"positionPoint\"+grp.id+grp.line.positionPoints.length;\n              grp.line.positionPoints.push(positionPoint,);\n              //shapes[i].distance_to_line_center=this.GiveSignOfDistance(shapes[i],line)*Math.sqrt((distX)**2+(distY)**2);\n            \n            //line.occupiedDistances.push(shapes[i].distance_to_line_center,);\n          //}\n          console.log(\"A new shape has been added with a distance\"+shapes[i].distance_to_line_center);\n          //shapes[i].isGrouped=0;\n          //this.updateDragFunc(shapes[i],line);\n          //grp.shapes_g.push(shapes[i],);\n          this.updateOccupiedDistance(line.id);\n          \n          this.updateAllPosInGrp(id_grp);\n          shapes.splice(i,1);\n          \n          this.updateNaration(grp)\n        }\n      }\n      this.center.x=line.x;\n      this.center.y=line.y;\n    },\n\n    updateOccupiedDistance(id_grp){\n      \n      const grp=this.groups.find((r)=> r.id===id_grp);\n      //this.updateAllPosInGrp(id_grp);\n      this.sortByDistToLineCenter(grp);\n      \n      //let l=grp.line.points[4]/2;\n      if(grp.line.keepDistribution){\n      let L=grp.line.points[4];\n      let nb_shapes=grp.shapes_g.length;\n      let d=(L/(nb_shapes-1))*grp.line.scaleX;\n      if(nb_shapes%2==0){\n        \n      for (let i =1;i<=nb_shapes/2-1;i++){\n        //grp.line.occupiedDistances[i-1]=-(l/i);\n        grp.line.occupiedDistances[i-1]=-((nb_shapes/2-1)-i+1)*d-d/2\n      }\n      for (let i =1;i<=nb_shapes/2-1;i++){\n        grp.line.occupiedDistances[nb_shapes/2+i]=i*d+d/2;\n      }\n      grp.line.occupiedDistances[nb_shapes/2-1]=-d/2\n      grp.line.occupiedDistances[nb_shapes/2]=d/2\n      } else{\n        for (let i =1;i<=(nb_shapes-1)/2;i++){\n          grp.line.occupiedDistances[i-1]=-d*(((nb_shapes-1)/2)-i+1);\n        }\n        for (let i =1;i<=(nb_shapes-1)/2;i++){\n          grp.line.occupiedDistances[((nb_shapes-1)/2)+i]=d*i;\n        }\n        grp.line.occupiedDistances[(nb_shapes-1)/2]=0;\n      }\n      \n      for (let i=0;i<grp.shapes_g.length;i++){\n        grp.shapes_g[i].distance_to_line_center=grp.line.occupiedDistances[i];\n      }\n      }\n      else{\n        grp.line.occupiedDistances.sort(this.isSmaller);\n      }\n      \n      \n      \n    \n\n    },\n\n   isSmaller(a,b){\n    if(a<b){\n      return -1;\n    }else{\n      return 1\n    }\n   },\n\n   isBeforeRegardingX(a,b){\n    if(a.x<b.x){\n      return -1;\n    }else{\n      return 1;\n    }\n   },\n\n    \n   updateOccDist(grp,shape){\n    let res=this.isNearest(grp.line,shape);\n    //let grp=this.groups.find((r)=>r.id===line.id);\n    if(res.isFree){\n      shape.distance_to_line_center=grp.line.freeDistances[res.indice];\n      grp.line.freeDistances.splice(res.indice,1);\n      this.sortByDistToLineCenter(grp);\n      for(let l=0;l<grp.shapes_g.length;l++){\n        if(grp.line.occupiedDistances.length==l){\n          grp.line.occupiedDistances.push(grp.shapes_g[l].distance_to_line_center,);\n        }else{\n          grp.line.occupiedDistances[l]=grp.shapes_g[l].distance_to_line_center;\n        }\n      } \n    } else{\n      grp.shapes_g.find((r)=>r.id==shape.id).distance_to_line_center=grp.line.occupiedDistances[res.indice];\n      grp.line.occupiedDistances.splice(res.indice,1);\n      //line.occupiedDistances.push(shape.distance_to_line_center,);\n      //line.freeDistances.splice(res.indice,1);   \n      this.updateOccDist(grp,grp.shapes_g[res.indice]);\n    }\n   },\n   isNearest(line,shape){\n    let ecart;\n    let invx=line.x+line.freeDistances[0]*Math.cos(line.rotation*(Math.PI/180));\n    let invy=line.y+line.freeDistances[0]*Math.sin(line.rotation*(Math.PI/180));\n    let ecart_min=Math.sqrt((invx-shape.x)**2+(invy-shape.y)**2);\n    let indice=0;\n    for(let i=1;i<line.freeDistances.length;i++){\n      invx=line.x+line.freeDistances[i]*Math.cos(line.rotation*(Math.PI/180));\n      invy=line.y+line.freeDistances[i]*Math.sin(line.rotation*(Math.PI/180));\n      ecart=Math.sqrt((invx-shape.x)**2+(invy-shape.y)**2);\n      if(ecart<ecart_min){\n        //res=line.freeDistances[i];\n        ecart_min=ecart;\n        indice=i;\n      }\n    }\n    return indice;\n    /*\n    let allDist=line.freeDistances.concat(line.occupiedDistances);\n    console.log(allDist);\n    \n    let ecart;\n    let invx=line.x+allDist[0]*Math.cos(line.rotation*(Math.PI/180));\n    let invy=line.y+allDist[0]*Math.sin(line.rotation*(Math.PI/180));\n    let ecart_min=Math.sqrt((invx-shape.x)**2+(invy-shape.y)**2)\n    let indice=0;\n    console.log(ecart_min);\n    for(let i=1;i<allDist.length;i++){\n      invx=line.x+allDist[i]*Math.cos(line.rotation*(Math.PI/180));\n      invy=line.y+allDist[i]*Math.sin(line.rotation*(Math.PI/180));\n      ecart=Math.sqrt((invx-shape.x)**2+(invy-shape.y)**2);\n      if(this.groups.find((r)=>r.id==line.id).shapes_g.indexOf(shape)!=-1){\n        console.log(ecart_min);\n        console.log(ecart);\n        if(ecart<ecart_min && ecart!=0){\n          //res=allDist[i];\n          ecart_min=ecart;\n          indice=i;\n        }\n      }else if(ecart<ecart_min){\n        //res=allDist[i];\n        ecart_min=ecart;\n        indice=i;\n      }\n    }\n    console.log(indice);\n    if(indice>=line.freeDistances.length){\n      return{\n        isFree: false,\n        indice: indice-line.freeDistances.length,\n      }\n    }else{\n      return{\n        isFree: true,\n        indice: indice,\n      }\n    }\n    */\n\n    /*\n    line.freeDistances.sort(this.isSmaller);\n    let ecart;\n    let invx=line.x+line.freeDistances[0]*Math.cos(line.rotation*(Math.PI/180));\n    let invy=line.y+line.freeDistances[0]*Math.sin(line.rotation*(Math.PI/180));\n    let ecart_min=Math.sqrt((invx-shape.x)**2+(invy-shape.y)**2)\n    let indice=0;\n    for(let i=0;i<line.freeDistances.length;i++){\n      invx=line.x+line.freeDistances[i]*Math.cos(line.rotation*(Math.PI/180));\n      invy=line.y+line.freeDistances[i]*Math.sin(line.rotation*(Math.PI/180));\n      ecart=Math.sqrt((invx-shape.x)**2+(invy-shape.y)**2)\n      if(ecart<ecart_min){\n        //res=freeDistances[i];\n        ecart_min=ecart;\n        indice=i;\n      }\n    }\n    return indice;\n    */\n    /*\n    if(shapeDistance>=0){\n      for(let i=0;i<freeDistances.length;i++){\n        if(freeDistances[i]>shapeDistance){\n          return i;\n        }\n      }\n      return freeDistances.length-1;\n    }else{\n      let ecart_min=Math.abs(Math.abs(freeDistances[0])-Math.abs(shapeDistance))\n      let indice=0;\n      for(let i=0;i<freeDistances.length;i++){\n        let ecart=Math.abs(Math.abs(freeDistances[i])-Math.abs(shapeDistance));\n        if(ecart<ecart_min){\n          //res=freeDistances[i];\n          ecart_min=ecart;\n          indice=i;\n        }\n      }\n      return indice;\n    }\n    */\n    /*\n    //let res=freeDistances[0];\n    let ecart_min=Math.abs(Math.abs(freeDistances[0])-Math.abs(shapeDistance))\n    let indice=0;\n    for(let i=0;i<freeDistances.length;i++){\n      let ecart=Math.abs(Math.abs(freeDistances[i])-Math.abs(shapeDistance));\n      if(ecart<ecart_min){\n        //res=freeDistances[i];\n        ecart_min=ecart;\n        indice=i;\n      }\n    }\n    return indice;\n    */\n   },\n   \n\n   sortByDistToLineCenter(grp){\n    //this.updateAllPosInGrp(grp.id)\n    //let last_distX=new Array(grp.shapes_g.length);\n    \n    //let distX;\n    //let distY;\n    //let sign;\n    //let dist=new Array(grp.shapes_g.length);\n    //let angle;\n    if(grp.line.keepDistribution){\n      for (let l=0;l<grp.shapes_g.length;l++){\n          let distX=grp.shapes_g[l].x-grp.line.x;\n          let distY=grp.shapes_g[l].y-grp.line.y;\n          //dist[l]=this.GiveSignOfDistance(grp.shapes_g[l],grp.line)*Math.sqrt((distX)**2+(distY)**2);\n          grp.shapes_g[l].distance_to_line_center=this.GiveSignOfDistance(grp.shapes_g[l],grp.line)*Math.sqrt((distX)**2+(distY)**2);\n          //last_distX[l]=distX;\n        }\n    }\n    for(let i=1;i<grp.shapes_g.length;i++){\n      \n     \n      let shape=grp.shapes_g[i];\n      //let distance=dist[i];\n      let j=i\n      while(j>0 && grp.shapes_g[j-1].distance_to_line_center>shape.distance_to_line_center){\n        grp.shapes_g[j]=grp.shapes_g[j-1];\n        //dist[j]=dist[j-1]\n        j=j-1;\n      }\n      grp.shapes_g[j]=shape;\n      //dist[j]=distance;\n    }\n   },\n   \n\n   sortAnyShapesByDistToLineCenter(shapes,line){\n    //this.updateAllPosInGrp(grp.id)\n    //let last_distX=new Array(grp.shapes_g.length);\n    \n    //let distX;\n    //let distY;\n    //let sign;\n    //let dist=new Array(grp.shapes_g.length);\n    //let angle;\n    for (let l=0;l<shapes.length;l++){\n        let distX=shapes[l].x-line.x;\n        let distY=shapes[l].y-line.y;\n        /*\n        angle=grp.shapes_g[l].rotation*(Math.PI/180);\n\n      \n      if(angle<=-Math.PI/4 || angle>=-Math.PI/2){\n        sign=-Math.sign(distY);\n      }\n      else if(angle<=-Math.PI/2 || angle>=-3*Math.PI/4){\n        sign=Math.sign(distY);\n      }\n      else if(angle<=-3*Math.PI/4 || angle>=-Math.PI){\n        sign=-Math.sign(distX);\n      }else if(angle>=3*Math.PI/4 || angle<=Math.PI){\n        sign=Math.sign(distX);\n      }else if(angle>=Math.PI/2 || angle<3*Math.PI/4){\n        sign=-Math.sign(distY);\n      } else if(angle<=Math.PI/2 || angle>Math.PI/4){\n        sign=-Math.sign(distY);\n      } else if(angle<=Math.PI/4 || angle>=0){\n        sign=Math.sign(distX);\n      }\n       console.log(sign);\n        */\n       \n        /*\n        if(Math.sin(grp.line.rotation*(Math.PI/180))==0){\n            grp.shapes_g[l].distance_to_line_center=grp.shapes_g[l].x-grp.line.x;\n        }else{\n            grp.shapes_g[l].distance_to_line_center=Math.sign(distX)*Math.sqrt((distX)**2+(distY)**2);\n          \n            if(grp.line.rotation*(Math.PI/180)<=-Math.PI/2 || grp.line.rotation*(Math.PI/180)<=Math.PI/2 &&grp.line.rotation*(Math.PI/180)>=0){\n              grp.shapes_g[l].distance_to_line_center=-grp.shapes_g[l].distance_to_line_center\n            }\n        }\n        */\n        //dist[l]=this.GiveSignOfDistance(grp.shapes_g[l],grp.line)*Math.sqrt((distX)**2+(distY)**2);\n        shapes.distance_to_line_center=this.GiveSignOfDistance(shapes,line)*Math.sqrt((distX)**2+(distY)**2);\n        /*\n        if((grp.line.rotation*(Math.PI/180)<=-Math.PI/2 || (grp.line.rotation*(Math.PI/180)<=Math.PI/2 && grp.line.rotation*(Math.PI/180)>=0)) && (Math.sign(last_distX[l])!=Math.sign(distX))){\n          grp.shapes_g[l].distance_to_line_center=-grp.shapes_g[l].distance_to_line_center\n        }\n        */\n        //last_distX[l]=distX;\n      }\n    for(let i=1;i<shapes.length;i++){\n      \n     \n      let shape=shapes[i];\n      //let distance=dist[i];\n      let j=i\n      while(j>0 && shapes[j-1].distance_to_line_center>shape.distance_to_line_center){\n        shapes[j]=shapes[j-1];\n        //dist[j]=dist[j-1]\n        j=j-1;\n      }\n      shapes[j]=shape;\n      //dist[j]=distance;\n    }\n   },\n\n  \n\n   /*\n   update the drag function of a shape which is on a line. \n   */\n   updateDragFunc(shape,line){\n          let angle=line.rotation*(Math.PI/180);\n          if (angle<=0 && angle>=-Math.PI/4){\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x +(pos.x-line.x)*Math.cos(angle),\n                y: line.y+(pos.x-line.x)*Math.sin(angle),\n              };\n            }\n          } else if (angle<-Math.PI/4 && angle>=-Math.PI/2){\n            // We prefer, in this case, moving the shape of the line regarding the y of the mouse position instead of the x.\n            // So that the user can move the shape more intuitively\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x-(pos.y-line.y)*Math.cos(angle),\n                y: line.y-(pos.y-line.y)*Math.sin(angle),\n              };\n            }\n          }\n          else if (angle<-Math.PI/2 && angle>=-3*Math.PI/4){\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x-(pos.y-line.y)*Math.cos(angle),\n                y: line.y-(pos.y-line.y)*Math.sin(angle),\n              };\n            }\n          } else if (angle<-3*Math.PI/4 && angle>=-Math.PI){\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x-(pos.x-line.x)*Math.cos(angle),\n                y: line.y-(pos.x-line.x)*Math.sin(angle),\n              };\n            }\n          }else if (angle<=Math.PI && angle>=3*Math.PI/4){\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x-(pos.x-line.x)*Math.cos(angle),\n                y: line.y-(pos.x-line.x)*Math.sin(angle),\n              };\n            }\n          } else if (angle<3*Math.PI/4 && angle>=Math.PI/2){\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x+(pos.y-line.y)*Math.cos(angle),\n                y: line.y+(pos.y-line.y)*Math.sin(angle),\n              };\n            }\n          } else if (angle<Math.PI/2 && angle>=Math.PI/4){\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x+(pos.y-line.y)*Math.cos(angle),\n                y: line.y+(pos.y-line.y)*Math.sin(angle),\n              };\n            }\n          }else if (angle<Math.PI/4 && angle>=0){\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x+(pos.x-line.x)*Math.cos(angle),\n                y: line.y+(pos.x-line.x)*Math.sin(angle),\n              };\n            }\n          }\n   },\n\n   /*\n   Update the position of a free shape when it is dragging.\n   */\n    updatePos(e){\n      const shape = this.shapes.find(i => i.id === e.target.id());\n      shape.x=e.target.x();\n      shape.y=e.target.y();\n      this.center.x=e.target.x();\n      this.center.y=e.target.y();\n\n      let pos = { x: shape.x, y: shape.y };\n      e.target.position(pos);\n      e.target.getLayer().batchDraw();\n      \n    },\n\n    /*\n    Update the positio  of shape attached to a line (from the group with id=id_grp) when it is dragging.\n     */\n    updatePosInGrp(e,id_grp){\n      let distX;\n      let distY;\n      let distance_to_line_center;\n      const grp=this.groups.find((r)=> r.id===id_grp);\n      \n      if(grp.aShapeHasBeenDetach==1){\n        grp.aShapeHasBeenDetach=0;\n        return;\n      }\n      const line=grp.line;\n      const shape = grp.shapes_g.find(i => i.id === e.target.id());\n      const shapes_g = grp.shapes_g; \n      //const lengthToDetach=10;\n      if(shape.needToBeDetach==1){\n        shape.needToBeDetach=0;\n        this.DetachShape(shape);\n        this.updateAllPosInGrp(e.target.getParent().attrs.id);\n      }\n      if(line.keepDistribution){\n        if(this.isCoordinateOnLine(e.target.x(),e.target.y(),line.id)){\n          distX=shape.x-e.target.x();\n          distY=shape.y -e.target.y();\n          let L=grp.line.points[4];\n          let nb_shapes=grp.shapes_g.length;\n          let d=(L/(nb_shapes-1))*grp.line.scaleX;\n          let dist=Math.sqrt(distX**2 +distY**2);\n          if(dist>=d){\n            shape.x=e.target.x();\n            shape.y=e.target.y();\n            this.updateOccupiedDistance(line.id)\n            shape.x=line.x+line.occupiedDistances[shapes_g.indexOf(shape)]*Math.cos(line.rotation*(Math.PI/180));\n            shape.y=line.y+line.occupiedDistances[shapes_g.indexOf(shape)]*Math.sin(line.rotation*(Math.PI/180));\n            shape.distance_to_line_center=line.occupiedDistances[shapes_g.indexOf(shape)];\n            shape.rotation=line.rotation;\n            this.updateAllPosInGrp(line.id);\n          }else{\n            shape.x=line.x+line.occupiedDistances[shapes_g.indexOf(shape)]*Math.cos(line.rotation*(Math.PI/180));\n            shape.y=line.y+line.occupiedDistances[shapes_g.indexOf(shape)]*Math.sin(line.rotation*(Math.PI/180));\n            shape.distance_to_line_center=line.occupiedDistances[shapes_g.indexOf(shape)];\n            shape.rotation=line.rotation; \n          }   \n        }else{\n          shape.x=e.target.x();\n          shape.y=e.target.y();\n        }\n        line.positionPoints[grp.shapes_g.indexOf(shape)].x=shape.x;\n        line.positionPoints[grp.shapes_g.indexOf(shape)].y=shape.y;\n        line.positionPoints[grp.shapes_g.indexOf(shape)].distance_to_line_center=shape.distance_to_line_center; \n      } else{\n        \n          line.positionPoints[grp.shapes_g.indexOf(shape)].x=shape.x;\n          line.positionPoints[grp.shapes_g.indexOf(shape)].y=shape.y;\n          shape.x=e.target.x();\n          shape.y=e.target.y();\n          \n          if(Math.sin(line.rotation*(Math.PI/180))==0){\n            distance_to_line_center=shape.x-line.x;\n          }else{\n            if(Math.sign(shape.x-line.x)!=0){\n              distance_to_line_center=Math.sign(-shape.rotation)*Math.sign(shape.x-line.x)*Math.sqrt((shape.x-line.x)**2+(shape.y-line.y)**2);\n            } else{\n             distance_to_line_center=Math.sign(-shape.rotation)*Math.sign(shape.y-line.y)*Math.sqrt((shape.x-line.x)**2+(shape.y-line.y)**2); \n            }\n          \n            if(shape.rotation*(Math.PI/180)<=-Math.PI/2 || (shape.rotation*(Math.PI/180)<=Math.PI/2 && shape.rotation*(Math.PI/180)>=0)){\n              distance_to_line_center=-distance_to_line_center\n            }\n          }\n          //shape.distance_to_line_center=distance_to_line_center;\n          //grp.line.occupiedDistances[shapes_g.indexOf(shape)]=shape.distance_to_line_center;\n        line.positionPoints[grp.shapes_g.indexOf(shape)].distance_to_line_center=shape.distance_to_line_center;\n          \n      }\n      let pos = { x: shape.x, y: shape.y };\n      this.center.x=shape.x;\n      this.center.y=shape.y;\n      e.target.position(pos);\n      e.target.getLayer().batchDraw();\n      if(!this.isCoordinateOnLine(shape.x,shape.y,line.id)){\n        shape.dragBoundFunc= dragFunc;\n        shape.isGrouped=0;\n        this.shapes.push(shape,)\n        for (let i=0;i<shapes_g.length;i++){\n          if(shapes_g[i].id==shape.id){\n            line.freeDistances.push(line.occupiedDistances[i]);\n            line.occupiedDistances.splice(i,1);\n            line.positionPoints.splice(i,1);\n            shapes_g.splice(i,1);\n            console.log(\"a shape has been removed from the line\");\n          }\n        } \n      }else{\n        if(!line.keepDistribution){\n          grp.line.occupiedDistances[shapes_g.indexOf(shape)]=distance_to_line_center;\n        }else{\n        grp.line.occupiedDistances[shapes_g.indexOf(shape)]=shape.distance_to_line_center;\n        }\n        \n      line.positionPoints[grp.shapes_g.indexOf(shape)].x=shape.x;\n      line.positionPoints[grp.shapes_g.indexOf(shape)].y=shape.y;\n      line.positionPoints[grp.shapes_g.indexOf(shape)].distance_to_line_center=shape.distance_to_line_center;\n       \n      }\n      /*\n      let coord_y1=line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x1=line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let coord_y2= line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x2=line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let a=(coord_y1-coord_y2)/(coord_x2-coord_x1);\n      let b=line.y-a*line.x;\n      let is_on_straight_line=false;\n      if(Math.abs(coord_x1-coord_x2)>=1){\n        is_on_straight_line=(Math.abs(a*shape.x+b-shape.y)<1);\n      }else{\n        is_on_straight_line=(Math.abs(shape.x-line.x)<1);\n      }\n      if(\n        !(is_on_straight_line)\n      ||((line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n        ||line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      && ((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>-Math.PI)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>-Math.PI)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>=0)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>=0)))\n      )\n      {\n        shape.dragBoundFunc= dragFunc;\n        this.shapes.push(shape,)\n        for (let i=0;i<shapes_g.length;i++){\n          if(shapes_g[i].id==shape.id){\n            line.freeDistances.push(line.occupiedDistances[i]);\n            line.occupiedDistances.splice(i,1);\n            shapes_g.splice(i,1);\n            console.log(\"a shape has been removed from the line\");\n          }\n        } \n      }else{\n        if(!line.keepDistribution){\n          grp.line.occupiedDistances[shapes_g.indexOf(shape)]=distance_to_line_center;\n        }else{\n        grp.line.occupiedDistances[shapes_g.indexOf(shape)]=shape.distance_to_line_center;\n        }\n      }\n      */\n      //this.updateOccupiedDistance(line.id);\n      \n          if(line.keepDistribution){\n            this.updateOccupiedDistance(line.id);\n          }\n          \n          this.updateAllPosInGrp(line.id);\n    },\n\n    \n    /*\n    Function called when the transformation of a shape with a transfomer is finished.\n    */\n    updateTransformedShape(e) {\n      \n\n      let res;\n      let shape; //Object concerned by the transformation\n      if(e.target.className==\"Line\"){\n\n        shape=this.groups.find(\n        (r) => r.id === this.selectedShapeId\n      ).line;\n\n      }else{\n\n        res=this.findShape(this.selectedShapeId)\n        shape=res.shape_data;\n        if(shape== undefined){\n          return;\n        }\n\n      }\n\n      \n      let last_shapex= shape.x;\n      let last_shapey= shape.y;\n\n      //update data of the transformed object.\n      shape.x = e.target.x();\n      shape.y = e.target.y();\n      shape.rotation = e.target.rotation();\n      let last_scaleX= shape.scaleX;\n      shape.scaleX = e.target.scaleX();\n      shape.scaleY = e.target.scaleY();\n\n      //if the transformed object is a stickyline\n      if(e.target.className==\"Line\"){\n        const grp=this.groups.find((r)=> r.id===shape.id);\n\n        if(shape.keepDistribution){\n\n          //We update distances on the line in case it has been resize\n          for (let i=0;i<shape.occupiedDistances.length;i++){\n            shape.occupiedDistances[i]=(shape.occupiedDistances[i]/last_scaleX)*shape.scaleX;\n          }\n          \n          //We do all the necessary update as consequence.\n          this.update();\n          this.updateGrp(e);\n          this.checkIfShapesOnLine(this.selectedShapeId); \n\n        }else{\n          \n          //if the line has been resize\n          if(last_scaleX!=shape.scaleX){\n\n            //If the line has been resize, we update the distances from the shapes to the center of the line \n            for(let i=0;i<grp.shapes_g.length;i++){\n              \n              let distX=grp.shapes_g[i].x-shape.x;\n              let distY=grp.shapes_g[i].y-shape.y;\n              \n              if(Math.sign(grp.line.occupiedDistances[i])==0){\n                \n                grp.line.occupiedDistances[i]=this.GiveSignOfDistance(grp.shapes_g[i],shape)*Math.sqrt((distX)**2 +(distY)**2);\n              \n              }else{\n                grp.line.occupiedDistances[i]=Math.sign(grp.line.occupiedDistances[i])*Math.sqrt((distX)**2 +(distY)**2);\n              }\n\n              \n              if(Math.sign((grp.shapes_g[i].x-last_shapex))!=Math.sign(distX) && Math.sign((grp.shapes_g[i].x-last_shapex))!=0 && grp.line.rotation!=90 && grp.line.rotation!=-90){\n                \n                grp.line.occupiedDistances[i]=-grp.line.occupiedDistances[i];\n              }\n              if(Math.sign((grp.shapes_g[i].y-last_shapey))!=Math.sign(distY) && Math.sign((grp.shapes_g[i].y-last_shapey))!=0 && (grp.line.rotation==90 || grp.line.rotation==-90)){\n                grp.line.occupiedDistances[i]=-grp.line.occupiedDistances[i];\n              }\n\n            }\n            \n            //We update also \"free distances\"\n            for (let i=0;i<shape.freeDistances.length;i++){\n              let distX=last_shapex-shape.x;\n              let distY=last_shapey-shape.y; \n              let dist=Math.sqrt(distX**2+distY**2);\n              if(shape.rotation<-90 ||shape.rotation>90){\n                shape.freeDistances[i]=shape.freeDistances[i]-Math.sign(last_shapex-shape.x)*dist;\n              } else if(shape.rotation==90 || shape.rotation==-90){\n                shape.freeDistances[i]=shape.freeDistances[i]-distY\n              } else{\n                shape.freeDistances[i]=shape.freeDistances[i]+Math.sign(last_shapex-shape.x)*dist;\n              \n              }\n            }\n          }\n\n          //We do the necessary update as consequences.\n          this.update();\n          this.updateGrp(e);\n          this.checkIfShapesOnLine(this.selectedShapeId);\n\n          // We now see if freeDistances need to be deleted(so if they are bigger than the half of the stickyline);\n          let i=0;\n          while(i<shape.freeDistances.length){\n            if((1/2)*((shape.points[4])*shape.scaleX)+2<Math.abs(shape.freeDistances[i])){\n              let corresponding_positionPoint=shape.positionPoints.find((r)=>r.distance_to_line_center==shape.freeDistances[i])\n              let index=shape.positionPoints.indexOf(corresponding_positionPoint);\n              shape.positionPoints.splice(index,1);\n              shape.freeDistances.splice(i,1);\n            }else{\n              i=i+1;\n            }\n          }\n        }\n        //another necessary update\n        for(let i=0;i<grp.shapes_g.length;i++){\n            \n          this.updateDragFunc(grp.shapes_g[i],shape);\n\n        }\n        for(let i=0;i<grp.line.positionPoints.length;i++){\n            \n          this.updateDragFunc(grp.line.positionPoints[i],shape);\n\n        }\n\n      }else if(res.grp_id!='-1'){\n        //In this case, the object that has been transformed is not a stickyline\n\n        /*res.grp_id!=-1 means that the shape that has been find with \n        the method findShape is part of group with id=res.grp_id*/\n\n        this.groups.find((r)=>r.id===res.grp_id).shapes_g.find((r)=>r.id===e.target.id()).personalRotation=e.target.rotation()-e.target.getParent().attrs.line.rotation;\n        \n\n        this.updateAllPosInGrp(res.grp_id);\n        this.updateOccupiedDistance(res.grp_id);\n        \n        /*We actualize the target node in order to no wait actualization of the DOM regarding vue component's data \n        to show the shape at the good position.*/\n        e.target.x(e.target.getParent().attrs.shapes_g.find((r)=>r.id===e.target.id()).x);\n        e.target.y(e.target.getParent().attrs.shapes_g.find((r)=>r.id===e.target.id()).y);\n        //this.groups.find((r)=>r.id===res.grp_id).shapes_g.find((r)=>r.id===e.target.id()).personalRotation=e.target.rotation()-e.target.getParent().attrs.line.rotation;\n        \n        //this.updateAllPosInGrp(res.grp_id);\n        this.checkIfShapesOnLine(res.grp_id);\n        this.updateDragFuncOfCenter(); \n      \n      }\n      else{\n        this.update();\n        this.updateDragFuncOfCenter();\n      }\n\n      //We update the center position\n      this.center.x=e.target.attrs.x;\n      this.center.y=e.target.attrs.y;\n    },\n    \n    /*\n    Called when we touch anything on the stage (including nothing).\n    In particular, it put a transformer if the target can be transform.\n    If we are in \"eraser mode\", this method call the method eraserAction.\n    */\n    handleTransformation(e) {\n      \n      //for prevention\n      if (e.evt==undefined) {\n        return;\n      }\n      \n      //If we click on the stage, we have to remove the transformer from the node where it was.\n      if (e.target === e.target.getStage()) {\n        this.selectedShapeId = 'NoId';\n        this.eraseNodefromTransformer(\"lineTransformer\");\n        this.eraseNodefromTransformer(\"shapeTransformer\");\n        this.center.visible=false;\n        return;\n      }\n\n      // If we click on a transformer, nothing happen.\n      const clickedOnTransformer = e.target.getParent().className === 'Transformer';\n      if (clickedOnTransformer) {\n        return;\n      }\n      \n      const id = e.target.id();\n      let transformer_id;\n      let shape=this.findShape(id).shape_data;\n\n      //if we click on the center or \"position points\" we do nothing.\n      if(e.target.attrs.id==\"center\" || e.target.attrs.className==\"positionPoint\"){\n        return;\n      }\n\n      //if it is a line, we need the transformer dedicated to the line (ie transformer with id=\"lineTransformer\")\n      //if it is a classic shape, we need the transformer dedicated to the shape (ie transformer with id=\"shapeTransformer\")\n      if(e.target.className==\"Line\"){\n        transformer_id=\"lineTransformer\"\n        shape = this.groups.find((r) => r.id === id).line;\n        this.center.draggable=false;\n        this.selectedShapeAlignment=shape.defaultAlignment;\n        this.eraseNodefromTransformer(\"shapeTransformer\");\n      }else{\n        transformer_id=\"shapeTransformer\"\n        this.center.draggable=true;\n        this.selectedShapeAlignment=shape.centerPosition;\n        this.eraseNodefromTransformer(\"lineTransformer\");\n      }\n      \n      if (shape!=undefined) {\n        this.selectedShapeId = id;\n        this.center.visible=true; // We make the center visible on the target shape\n        this.updateTransformer(transformer_id); //We update the transformer\n      } else{\n        this.selectedShapeId = 'NoId';\n      }\n      \n      this.updateDragFuncOfCenter() //We update the drag function of the center accordingly to the target shape's orientaion.\n    },\n\n    //remove node from transformer with id=transformer_id\n    eraseNodefromTransformer(transformer_id) {\n      let stage= this.$refs.stage.getStage();      \n      const transformerNode = stage.find(\"#\"+transformer_id)[0]; \n      transformerNode.nodes([]);\n    },\n\n\n    //Update transformer with id=transformer_id\n    //It places the transformer regarding what node is selected\n    updateTransformer(transformer_id) {\n      \n      let stage= this.$refs.stage.getStage();\n      let transformerNode = stage.find(\"#\"+transformer_id)[0];\n      let selectedNode;\n      if (transformer_id==\"lineTransformer\"){\n        //if the transformer is the one for stickylines, it means that the selectedNode has to be a stickyline\n        selectedNode = stage.children[0].getChildren().filter((r)=> r.attrs.className==\"Group\" && r.attrs.id==this.selectedShapeId)[0]\n        .getChildren().filter(r=>r.attrs.className==\"Line\" && r.attrs.id==this.selectedShapeId)[0];\n      }else{\n        selectedNode = stage.children[0].getChildren().filter((r)=>r.attrs.className!=\"Group\" && r.attrs.id==this.selectedShapeId)[0];\n\n        let isFunded=true;\n        if(selectedNode==undefined){\n          isFunded=false;\n        }\n        let i=0;\n\n        //If we selectedNode is undefined it means that the selected node is an atttached shape and not a free one.\n        //The follow loop is executed in order to find this node.\n        while(!isFunded){\n          if(i<this.groups.length){\n            selectedNode=stage.children[0].getChildren().filter((r)=>r.attrs.className==\"Group\")[i].getChildren().find((r)=>r.attrs.id==this.selectedShapeId && r.attrs.className!=\"Line\");\n          if(selectedNode==undefined){\n            isFunded=false;\n          }else{\n            isFunded=true;\n          }\n          i++;\n          }else{        \n            isFunded=true;\n          }\n        }\n      }\n      \n     \n      //If the selected node has already the transformer on it, nothing happen\n      if (selectedNode === transformerNode.node()) {\n        return;\n      }\n\n      //If a node is selected\n      if (selectedNode!=undefined) {\n        //We attach the transformer to the node\n        transformerNode.nodes([selectedNode]);\n      } else {\n        //if no node is selected, we remove the transformer from its node.\n        transformerNode.nodes([]);\n      }\n\n      this.center.x=selectedNode.attrs.x;\n      this.center.y=selectedNode.attrs.y;\n      \n    },\n/*\n  DisplayCenterMenu(e){\n    CenterMenu.props.ConcernedShape=e.target;\n   document.getElementById(\"center_menu\").style.display=\"initial\";\n   document.getElementById(\"center_menu\").style.top=e.target.getStage().getPointerPosition().y+8+\"px\";\n  document.getElementById(\"center_menu\").style.left=e.target.getStage().getPointerPosition().x+8+\"px\";\n  },\n  */\n\n  //display context menu according to the target\n  /*\n  DisplayContextMenu(e){\n    e.evt.preventDefault()\n    if (e.target.className!=undefined && e.target.attrs.id!=\"center\"){\n      this.isStageOnlySelected=false;\n      ContextMenu.data().dM='initial';\n      this.$emit('needmenu');\n      this.needMenu=true;\n      ContextMenu.props.ConcernedShape=e.target;\n      if (e.target.attrs.className==\"Line\"){\n        this.isALineSelected=true;\n        this.isAGroupedShapeSelected=true;\n        //We precise the text which depends on the line where we clicked.\n        this.keepDistanceButtonText=e.target.attrs.keepDistanceButtonText;\n      } else if(e.target.getParent().attrs.className==\"Group\"){\n        this.isAGroupedShapeSelected=true;\n      }\n      else{\n        this.isALineSelected=false;\n        this.isAGroupedShapeSelected=false;\n      }\n      \n      document.getElementById(\"activeReuseSubstrate\").style.display=\"initial\";\n      document.getElementById(\"activeReuseSubstrate\").style.top= document.getElementById(\"ReificationSubstrateDemo\").getBoundingClientRect().top+document.documentElement.scrollTop+e.target.getStage().getPointerPosition().y+\"px\";\n      document.getElementById(\"activeReuseSubstrate\").style.left= document.getElementById(\"ReificationSubstrateDemo\").getBoundingClientRect().left+document.documentElement.scrollLeft+e.target.getStage().getPointerPosition().x+\"px\";\n    }\n    if (e.target === e.target.getStage()) {\n      this.needMenu=true;\n      this.isALineSelected=false;\n      this.isAGroupedShapeSelected=false;\n      this.isStageOnlySelected=true;\n      document.getElementById(\"activeReuseSubstrate\").style.display=\"initial\";\n      document.getElementById(\"activeReuseSubstrate\").style.top=document.getElementById(\"ReificationSubstrateDemo\").getBoundingClientRect().top+document.documentElement.scrollTop+e.target.getStage().getPointerPosition().y+\"px\";\n      document.getElementById(\"activeReuseSubstrate\").style.left=document.getElementById(\"ReificationSubstrateDemo\").getBoundingClientRect().left+document.documentElement.scrollLeft+e.target.getStage().getPointerPosition().x+\"px\";\n    \n    }\n  },\n\n  //hide context menu\n  HideContextMenu(){\n    this.needMenu=false;\n    document.getElementById(\"activeReuseSubstrate\").style.display=\"none\";\n    document.getElementById(\"center_menu\").style.display=\"none\";\n  },\n*/\n\n  \n ChangeCenter(e){\n  let res=this.findShape(this.selectedShapeId);\n  let shape=res.shape_data;\n  let threshold1;\n  let threshold2;\n  let dist=this.GiveSignOfDistanceBtwCenterAndShape(e.target.attrs,shape)*Math.sqrt((e.target.y()-(shape.y))**2+(e.target.x()-shape.x)**2)+shape.offsetY*shape.scaleY;\n  \n  //let last_offsetX=shape.offsetX;\n  let last_offsetY=shape.offsetY;\n  if(shape==undefined){\n    shape=this.groups.find((r)=>r.id==this.selectedShapeId).line;\n\n  }else{\n    \n      if(shape.className==\"Rect\") {\n        threshold1=shape.height*shape.scaleY/3;\n        threshold2=shape.height*shape.scaleY*2/3;\n        if(dist>=threshold1 && dist<=threshold2){\n          shape.offsetX=shape.width/2;\n          shape.offsetY=shape.height/2;\n          shape.centerPosition=\"Middle\";\n        }else if(dist>threshold2){\n          shape.offsetX=shape.width/2;\n          shape.offsetY=shape.height;\n          shape.centerPosition=\"Bottom\";\n        }\n        else{\n          shape.offsetX=shape.width/2;\n          shape.offsetY=0;\n          shape.centerPosition=\"Top\";\n        }\n      }\n      else if(shape.className==\"Circle\") {\n        dist=dist+shape.radius*shape.scaleY;\n        threshold1=shape.radius*shape.scaleY*2/3;\n        threshold2=shape.radius*shape.scaleY*4/3;\n        if(dist>=threshold1 && dist<=threshold2){\n          shape.offsetX=0;\n          shape.offsetY=0;\n          shape.centerPosition=\"Middle\";\n        }else if(dist>threshold2){\n          shape.offsetX=0;\n          shape.offsetY=shape.radius;\n          shape.centerPosition=\"Bottom\";\n        }else{\n          shape.offsetX=0;\n          shape.offsetY=-shape.radius;\n          shape.centerPosition=\"Top\";\n        } \n      }\n      else if(shape.className==\"Image\") {\n        threshold1=shape.image.height*shape.scaleY/3;\n        threshold2=shape.image.height*shape.scaleY*2/3;\n        if(dist>=threshold1 && dist<=threshold2){\n          shape.offsetX=shape.image.width/2;\n          shape.offsetY=shape.image.height/2;\n          shape.centerPosition=\"Middle\";\n        }else if(dist>threshold2){\n          shape.offsetX=shape.image.width/2;\n          shape.offsetY=shape.image.height;\n          shape.centerPosition=\"Bottom\";\n        }\n        else {\n          shape.offsetX=shape.image.width/2;\n          shape.offsetY=0;\n          shape.centerPosition=\"Top\";\n        }\n      }\n      else if(shape.className==\"Text\") {\n        threshold1=shape.length_y*shape.scaleY/3;\n        threshold2=shape.length_y*shape.scaleY*2/3;\n        if(dist>=threshold1 && dist<=threshold2){\n          shape.offsetX=shape.length_x/2;\n          shape.offsetY=shape.length_y/2;\n          shape.centerPosition=\"Middle\";\n        }else if(dist>threshold2){\n          shape.offsetX=shape.length_x/2;\n          shape.offsetY=shape.length_y;\n          shape.centerPosition=\"Bottom\";\n        }\n        else{\n          shape.offsetX=shape.length_x/2;\n          shape.offsetY=0;\n          shape.centerPosition=\"Top\";\n        }\n      }\n      else if(shape.className==\"Triangle\") {\n        dist=dist+shape.radius*shape.scaleY;\n        threshold1=shape.radius*shape.scaleY/2;\n        threshold2=shape.radius*shape.scaleY*5/4;\n        if(dist>=threshold1 && dist<=threshold2){\n          shape.offsetX=0;\n          shape.offsetY=0;\n        }else if(dist>threshold2){\n          shape.offsetX=0;\n          shape.offsetY=shape.radius/2\n          shape.centerPosition=\"Bottom\";\n        }\n        else{\n          shape.offsetX=0;\n          shape.offsetY=-shape.radius;\n          shape.centerPosition=\"Top\";\n        }\n      }\n      shape.y=shape.y-(last_offsetY-shape.offsetY)*shape.scaleY*Math.cos(shape.rotation*(Math.PI/180));\n      shape.x=shape.x+(last_offsetY-shape.offsetY)*shape.scaleY*Math.sin(shape.rotation*(Math.PI/180));\n      this.selectedShapeAlignment=shape.centerPosition;\n\n      if (res.grp_id!='-1'){\n        this.updateAllPosInGrp(res.grp_id);\n      }\n        \n      e.target.x(shape.x);\n      e.target.y(shape.y);\n\n     \n\n      \n  }\n  },\n  \n  /*\n  ChangeAlignCenter(align_choice){\n    let center=CenterMenu.props.ConcernedShape;\n    let grp=this.groups.find((r)=>r.id===this.selectedShapeId);\n    let shape;\n    if(grp!=undefined){\n      for(let i=0;i<grp.shapes_g.length;i++){\n        this.ChangeCenterRegardingCommand(grp.shapes_g[i].id,align_choice)\n      }\n      center.x(grp.line.x);\n      center.y(grp.line.y);\n      if(grp.line.defaultAlignment==align_choice){\n        grp.line.defaultAlignment='' //If we select again the same alogn_choice, we deselect it, no alignement center is fixed.\n      }else{\n        grp.line.defaultAlignment=align_choice;\n      }\n      this.selectedShapeAlignment=grp.line.defaultAlignment;\n    }else{\n      shape=this.findShape(this.selectedShapeId).shape_data;\n      this.ChangeCenterRegardingCommand(shape.id,align_choice)\n      this.selectedShapeAlignment=shape.centerPosition;\n      center.x(shape.x);\n      center.y(shape.y);\n    }\n  },\n  */\n  //Allow to change the center regarding a text command (Top,Middle or Bottom)\n  ChangeCenterRegardingCommand(shape_id,command){\n    let res=this.findShape(shape_id);\n    let shape=res.shape_data;\n    let last_offsetY=shape.offsetY;\n    if(shape.className==\"Rect\" ){\n      if(command==\"Top\"){\n        shape.offsetY=0;\n        shape.offsetX=shape.width/2;\n      }\n      else if(command==\"Middle\"){\n          shape.offsetX=shape.width/2;\n          shape.offsetY=shape.height/2;\n      }else if(command==\"Bottom\"){\n            shape.offsetX=shape.width/2;\n            shape.offsetY=shape.height;\n      }\n    }\n      else if(shape.className==\"Circle\") {\n        if(command==\"Top\"){\n          shape.offsetX=0;\n          shape.offsetY=-shape.radius;\n        }else if(command==\"Middle\"){\n          shape.offsetX=0;\n          shape.offsetY=0\n        }else if(command==\"Bottom\"){\n          shape.offsetX=0;\n          shape.offsetY=shape.radius;\n        } \n      }\n      else if(shape.className==\"Image\") {\n        if(command==\"Middle\"){\n          shape.offsetX=shape.image.width/2;\n          shape.offsetY=shape.image.height/2;\n        }else if(command==\"Bottom\"){\n          shape.offsetX=shape.image.width/2;\n          shape.offsetY=shape.image.height;\n        }\n        else if (command==\"Top\"){\n          shape.offsetX=shape.image.width/2;\n          shape.offsetY=0;\n        }\n      }\n      else if(shape.className==\"Text\") {\n        if(command==\"Middle\"){\n          shape.offsetX=shape.length_x/2;\n          shape.offsetY=shape.length_y/2;\n        }else if(command==\"Bottom\"){\n          shape.offsetX=shape.length_x/2;\n          shape.offsetY=shape.length_y;\n        }\n        else if(command==\"Top\"){\n          shape.offsetX=shape.length_x/2;\n          shape.offsetY=0;\n        }\n      }\n      else if(shape.className==\"Triangle\") {\n        if(command==\"Middle\"){\n          shape.offsetX=0;\n          shape.offsetY=0;\n        }else if(command==\"Bottom\"){\n          shape.offsetX=0;\n          shape.offsetY=shape.radius/2;\n        }\n        else if(command==\"Top\"){\n          shape.offsetX=0;\n          shape.offsetY=-shape.radius;\n        }\n      }\n      shape.centerPosition=command;\n      shape.y=shape.y-(last_offsetY-shape.offsetY)*shape.scaleY*Math.cos(shape.rotation*(Math.PI/180));\n      shape.x=shape.x+(last_offsetY-shape.offsetY)*shape.scaleY*Math.sin(shape.rotation*(Math.PI/180));\n\n      if (res.grp_id!='-1'){\n        this.updateAllPosInGrp(res.grp_id);\n      }\n        \n      //center.x(shape.x);\n      //center.y(shape.y);\n  },\n  updateDragFuncOfCenter(){\n    let shape=this.findShape(this.selectedShapeId).shape_data\n    let center=this.center;\n    let angle=shape.rotation*(Math.PI/180);\n    if(angle>=-Math.PI/2 && angle<=0){\n      angle-=90*(Math.PI/180);\n    }else if(angle<-Math.PI/2){\n      angle+=(Math.PI/2);\n      angle=Math.PI+angle;\n    } else if(angle<=Math.PI && angle>0){\n      angle-=90*(Math.PI/180);\n    } \n    if (angle<=0 && angle>=-Math.PI/4){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x +(pos.x-shape.x)*Math.cos(angle),\n          y: shape.y+(pos.x-shape.x)*Math.sin(angle),\n        };\n      }\n    } else if (angle<-Math.PI/4 && angle>=-Math.PI/2){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x-(pos.y-shape.y)*Math.cos(angle),\n          y: shape.y-(pos.y-shape.y)*Math.sin(angle),\n        };\n      }\n    }\n    else if (angle<-Math.PI/2 && angle>=-3*Math.PI/4){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x-(pos.y-shape.y)*Math.cos(angle),\n          y: shape.y-(pos.y-shape.y)*Math.sin(angle),\n        };\n      }\n    } else if (angle<-3*Math.PI/4 && angle>=-Math.PI){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x-(pos.x-shape.x)*Math.cos(angle),\n          y: shape.y-(pos.x-shape.x)*Math.sin(angle),\n        };\n      }\n    }else if (angle<=Math.PI && angle>=3*Math.PI/4){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x-(pos.x-shape.x)*Math.cos(angle),\n          y: shape.y-(pos.x-shape.x)*Math.sin(angle),\n        };\n      }\n    } else if (angle<3*Math.PI/4 && angle>=Math.PI/2){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x+(pos.y-shape.y)*Math.cos(angle),\n          y: shape.y+(pos.y-shape.y)*Math.sin(angle),\n        };\n      }\n    } else if (angle<Math.PI/2 && angle>=Math.PI/4){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x+(pos.y-shape.y)*Math.cos(angle),\n          y: shape.y+(pos.y-shape.y)*Math.sin(angle),\n        };\n      }\n    }else if (angle<Math.PI/4 && angle>=0){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x+(pos.x-shape.x)*Math.cos(angle),\n          y: shape.y+(pos.x-shape.x)*Math.sin(angle),\n        };\n      }\n    }\n  },\n  MovingCenter(){\n    //let shape=this.findShape(this.selectedShapeId)\n    //console.log(e.target)\n  },\n  /*\n  //called when the \"Change Center\" button is clicked\n  ChangeCenterButtonAction(){\n      let shape= ContextMenu.props.ConcernedShape;\n      if(shape.attrs.className==\"Line\"){\n        let shapes_g=shape.getParent().attrs.shapes_g //the list of the shapes which are on the line is in the corresponding group.\n        for (let j=0;j<shapes_g.length;j++){\n          this.ChangeCenter(shapes_g[j]);\n        }\n      }else{\n        let shape_data=this.shapes.find(i => i.id ===shape.attrs.id);\n        let isFunded=true;\n        if(shape_data==undefined){\n          isFunded=false;\n        }\n        let i=0;\n        while(!isFunded){\n          if(i<this.groups.length){\n            shape_data=this.groups[i].shapes_g.find(i => i.id === shape.attrs.id);\n          if(shape_data==undefined){\n            isFunded=false;\n          }else{\n            isFunded=true;\n          }\n          i++;\n          }else{        \n            isFunded=true;\n          }\n        }\n        this.ChangeCenter(shape_data)\n      }\n    },\n    */\n    \n    //allow to copy a target\n    \n    /*\n    Copy(){\n      ContextMenu.props.CopiedShape=ContextMenu.props.ConcernedShape;\n      ContextMenu.props.pastOneObject=true;\n    },\n    \n    CopyAll(){\n      ContextMenu.props.CopiedShape=ContextMenu.props.ConcernedShape;\n      ContextMenu.props.pastOneObject=false;\n    },\n    \n    Past(){   \n      //Prevent error when no shape is copied\n      if(ContextMenu.props.CopiedShape.attrs==undefined){\n        return;\n      }\n      let clone=ContextMenu.props.CopiedShape.clone({\n        id: ''+this.max_id_figures,\n      })\n      //let layer=ContextMenu.props.CopiedShape.getLayer();\n      let i= this.groups.length\n      //let new_id=i+1;\n      if(ContextMenu.props.CopiedShape.attrs.className==\"Line\"){\n        this.max_id_figures=this.max_id_figures+1;\n        if(!ContextMenu.props.pastOneObject){\n          //let i= this.groups.length;\n          //let new_id=i+1;\n        \n          clone=ContextMenu.props.CopiedShape.getParent().clone({\n            id: ''+ this.max_id_figures,\n            name: \"group\"+this.max_id_figures,\n            shapes_g:[],\n          })\n          clone.attrs.line.id=''+this.max_id_figures;\n          clone.attrs.line.x=ContextMenu.props.ConcernedShape.getStage().getPointerPosition().x;\n          clone.attrs.line.y=ContextMenu.props.ConcernedShape.getStage().getPointerPosition().y;\n          let positionPoints=Object.assign([],clone.attrs.line.positionPoints);\n            let length=positionPoints.length;\n            clone.attrs.line.positionPoints=[];\n            for(let i=0;i<length.valueOf();i++){\n              let clone_positionPoint=ContextMenu.props.CopiedShape.getParent().getChildren().find((r)=>r.attrs.id===positionPoints[i].id).clone({\n              id:'positionPoint'+clone.attrs.line.id+i,\n              });\n              clone.attrs.line.positionPoints.push(clone_positionPoint.attrs,);\n            }\n          \n          //layer= ContextMenu.props.CopiedShape.getParent().getLayer();\n          this.groups.push(clone.attrs,);\n          let shapesg=this.groups[this.groups.indexOf(this.groups.find((r)=> r.id==ContextMenu.props.CopiedShape.getParent().attrs.id))].shapes_g;\n          let shapesg_length=shapesg.length;\n          for (let j=0; j<shapesg_length;j++){\n            this.max_id_figures=this.max_id_figures + 1;\n            let clone_shape=ContextMenu.props.CopiedShape.getParent().getChildren().find((r)=>r.attrs.id===shapesg[j].id).clone({\n              id:''+this.max_id_figures,\n            });\n           // this.updateDragFunc(clone_shape,clone_line);\n            this.groups[i].shapes_g.push(clone_shape.attrs,);\n            this.updateDragFunc(this.groups[i].shapes_g[this.groups[i].shapes_g.length-1],this.groups[i].line);\n          }\n          this.updateAllPosInGrp(clone.attrs.id);\n        }else{\n          //let i= this.groups.length;\n          //let new_id=i+1;\n        \n          clone=ContextMenu.props.CopiedShape.getParent().clone({\n            id: ''+this.max_id_figures,\n            name: \"group\"+this.max_id_figures,\n            shapes_g:[],\n          })\n          clone.attrs.line.id=''+this.max_id_figures;\n          clone.attrs.line.x=ContextMenu.props.ConcernedShape.getStage().getPointerPosition().x;\n          clone.attrs.line.y=ContextMenu.props.ConcernedShape.getStage().getPointerPosition().y;\n          for(let j=0;j<clone.attrs.line.occupiedDistances.length;j++){\n            clone.attrs.line.freeDistances.push(clone.attrs.line.occupiedDistances[j],);\n          }\n          clone.attrs.line.occupiedDistances=[];\n          if(clone.attrs.line.keepDistribution!=1){\n            let positionPoints=Object.assign([],clone.attrs.line.positionPoints);\n            let length=positionPoints.length;\n            clone.attrs.line.positionPoints=[];\n            for(let i=0;i<length.valueOf();i++){\n              let clone_positionPoint=ContextMenu.props.CopiedShape.getParent().getChildren().find((r)=>r.attrs.id===positionPoints[i].id).clone({\n              id:'positionPoint'+clone.attrs.line.id+i,\n              });\n              clone.attrs.line.positionPoints.push(clone_positionPoint.attrs,);\n            }\n          }\n          //layer= ContextMenu.props.CopiedShape.getParent().getLayer();\n          this.groups.push(clone.attrs,)\n        }\n        //In order to actualize the new line (in particular to show the positionPoints):\n        this.updateAllPosInGrp(clone.attrs.id)\n      } \n      else{\n        this.max_id_figures=this.max_id_figures + 1;\n        clone=ContextMenu.props.CopiedShape.clone({\n          id: ''+this.max_id_figures,  \n          x:ContextMenu.props.ConcernedShape.getStage().getPointerPosition().x,\n          y:ContextMenu.props.ConcernedShape.getStage().getPointerPosition().y,\n        });\n        clone.attrs.dragBoundFunc=function (pos) {\n          return {\n            x: pos.x,\n            y: pos.y,\n          };\n        };\n        clone.attrs.isGrouped=0;\n        this.shapes.push(clone.attrs,); \n         \n      }\n      //layer.batchDraw(); \n      \n    },\n    \n    //RemoveShape(shape)\n    Remove(shape){\n      //let shape=ContextMenu.props.ConcernedShape;\n      if(shape.attrs.className==\"Line\"){\n        let grp=this.groups.find((r)=>r.id===shape.attrs.id);\n        const length=grp.shapes_g.length;\n        for(let i=0;i<length;i++){\n          grp.shapes_g[i].dragBoundFunc= dragFunc;\n          grp.shapes_g[i].isGrouped=0;\n          this.shapes.push(grp.shapes_g[i],);\n        }\n        this.eraseNodefromTransformer(\"lineTransformer\");\n        this.groups.splice(this.groups.indexOf(grp),1);\n        shape.getParent().destroy();\n\n        //We give to the circle (representing center of shapes) a default position\n        if(this.groups[0]!=undefined){\n          this.center.x=this.groups[0].line.x;\n          this.center.y=this.groups[0].line.y;\n        } else if(this.shapes[0]!=undefined){\n          this.center.x=this.shapes[0].x;\n          this.center.y=this.shapes[0].y;\n        }\n        this.center.opacity=0;\n        \n      }else if(shape.attrs.className==\"positionPoint\"){\n        let line=shape.getParent().attrs.line;\n        let target_positionPoint=line.positionPoints.find((r)=>r.id===shape.attrs.id);\n        let index=line.freeDistances.indexOf(shape.attrs.distance_to_line_center);\n        console.log(line.positionPoints);\n        if(line.keepDistribution!=1 && index!=-1){\n          line.freeDistances.splice(index,1);\n          line.positionPoints.splice(line.positionPoints.indexOf(target_positionPoint),1)\n        }\n      }\n      else{\n        let res=this.findShape(shape.attrs.id)\n        let shape_data=res.shape_data;\n        let grp_id=res.grp_id;\n        if(shape_data!=undefined){\n        if(grp_id!='-1'){\n        //let shape_data=this.shapes.find(i => i.id ===shape.attrs.id);\n        let grp=this.groups.find((r)=>r.id===grp_id);\n          grp.line.freeDistances.push(grp.line.occupiedDistances[grp.shapes_g.indexOf(shape_data)],)\n          grp.line.occupiedDistances.splice(grp.shapes_g.indexOf(shape_data),1)\n          \n          grp.shapes_g.splice(grp.shapes_g.indexOf(shape_data),1);\n          this.updateOccupiedDistance(grp.id);\n          \n          this.updateAllPosInGrp(grp.id);\n          \n         console.log(grp.line.positionPoints)\n      \n        } else{\n          this.eraseNodefromTransformer(\"shapeTransformer\");\n          this.shapes.splice(this.shapes.indexOf(shape_data),1);\n          //We give to the circle (representing center of shapes) a default position\n          if(this.groups[0]!=undefined){\n            this.center.x=this.groups[0].line.x;\n            this.center.y=this.groups[0].line.y;\n          } else if(this.shapes[0]!=undefined){\n            this.center.x=this.shapes[0].x;\n            this.center.y=this.shapes[0].y;\n          }\n          this.center.opacity=0;\n        }\n        shape.destroy();\n        }\n      }\n    },\n\n    RemoveAll(){\n      let shape=ContextMenu.props.ConcernedShape;\n      if(shape.className==\"Line\"){\n        let grp=this.groups.find((r)=>r.id===shape.attrs.id);\n        while(grp.shapes_g.length!=0){\n          grp.shapes_g[0].dragBoundFunc= dragFunc;\n          grp.shapes_g.splice(0,1);\n        }\n        this.eraseNodefromTransformer(\"lineTransformer\");\n        this.groups.splice(this.groups.indexOf(grp),1);\n        shape.getParent().destroy();\n\n        //We give to the circle (representing center of shapes) a default position\n        if(this.groups[0]!=undefined){\n          this.center.x=this.groups[0].line.x;\n          this.center.y=this.groups[0].line.y;\n        } else if(this.shapes[0]!=undefined){\n          this.center.x=this.shapes[0].x;\n          this.center.y=this.shapes[0].y;\n        }\n        \n      }else{\n        return;\n      }\n    },\n    */\n\n    findShape(id){ \n      let shape_data=this.shapes.find(i => i.id ===id);\n      let grp_id='-1'; // return grp_id=-1 if the shape doesn't belong to attached group.\n      let isFunded=true;\n      if(shape_data==undefined){\n        isFunded=false;\n      }\n      let i=0;\n      while(!isFunded){\n        if(i<this.groups.length){\n          shape_data=this.groups[i].shapes_g.find(i => i.id === id);\n        if(shape_data==undefined){\n          isFunded=false;\n        }else{\n          grp_id=this.groups[i].id; \n          isFunded=true;\n        }\n        i++;\n        }else{        \n          isFunded=true;\n        }\n      }\n      return {shape_data, grp_id}\n    },\n\n    //detach a shape from its line.\n     DetachShape(shape,target_x,target_y){\n      \n      \n      const added_distance=this.lengthToCapture+5;\n      let grp=this.groups.find((r)=>r.shapes_g.indexOf(shape)!=-1);\n      let i=grp.shapes_g.indexOf(shape);\n      \n      shape.dragBoundFunc= dragFunc;\n\n      let coord_y1=grp.line.y-grp.line.points[4]*(1/2)*grp.line.scaleX*Math.sin(grp.line.rotation*(Math.PI/180));\n      let coord_x2=grp.line.x+grp.line.points[4]*(1/2)*grp.line.scaleX*Math.cos(grp.line.rotation*(Math.PI/180));\n      let coord_y2= grp.line.y+grp.line.points[4]*(1/2)*grp.line.scaleX*Math.sin(grp.line.rotation*(Math.PI/180));\n      let coord_x1=grp.line.x-grp.line.points[4]*(1/2)*grp.line.scaleX*Math.cos(grp.line.rotation*(Math.PI/180));\n      let a=(coord_y2-coord_y1)/(coord_x2-coord_x1);\n      //let b=grp.line.y-a*grp.line.x;\n      let b=shape.x*(1/a)+shape.y;\n      if (grp.line.rotation<0 && grp.line.rotation>-45){\n        \n        shape.x=shape.x+Math.sign(shape.y-target_y)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } else if (grp.line.rotation<=-45 && grp.line.rotation>-90){\n        \n        shape.x=shape.x+Math.sign(shape.x-target_x)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      }\n      \n      else if(grp.line.rotation<-90 && grp.line.rotation>-135){\n        shape.x=shape.x+Math.sign(shape.x-target_x)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } \n      else if(grp.line.rotation<=-135 && grp.line.rotation>-180){\n        shape.x=shape.x-Math.sign(shape.y-target_y)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } \n      \n      else if( grp.line.rotation>135 && grp.line.rotation<180){\n        \n        shape.x=shape.x-Math.sign(shape.y-target_y)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } else if( grp.line.rotation>90 && grp.line.rotation<=135){\n        \n        shape.x=shape.x-Math.sign(shape.x-target_x)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } else if( grp.line.rotation>45 && grp.line.rotation<=90){\n        \n        shape.x=shape.x-Math.sign(shape.x-target_x)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } else if( grp.line.rotation>0 && grp.line.rotation<=45){\n        \n        shape.x=shape.x+Math.sign(shape.y-target_y)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } \n      else if(grp.line.rotation==-90){\n        shape.x=shape.x-Math.sign(shape.x-target_x)*added_distance\n      } else if(grp.line.rotation==90){\n        shape.x=shape.x+Math.sign(shape.x-target_x)*added_distance\n      } else if(grp.line.rotation==180 || grp.line.rotation==-180){\n        shape.y=shape.y-Math.sign(shape.y-target_y)*added_distance\n      } else if(grp.line.rotation==0){\n        shape.y=shape.y-Math.sign(shape.y-target_y)*added_distance\n      } \n      //shape.rotation=shape.rotation+shape.personalRotation;\n      shape.isGrouped=0;\n      this.shapes.push(shape,)\n      this.center.x=shape.x;\n      this.center.y=shape.y;\n      grp.line.freeDistances.push(grp.line.occupiedDistances[i]);\n      grp.line.occupiedDistances.splice(i,1);\n      grp.shapes_g.splice(i,1);\n      grp.line.positionPoints.splice(i,1)\n      \n      this.updateOccupiedDistance(grp.id)\n      this.updateAllPosInGrp(grp.id)\n      this.updateNaration(grp)\n\n      this.eraseNodefromTransformer(\"shapeTransformer\");\n    \n    },\n    /*\n    DetachShape(shape){\n      \n      \n      const added_distance=this.lengthToCapture+5;\n      let grp=this.groups.find((r)=>r.shapes_g.indexOf(shape)!=-1);\n      let i=grp.shapes_g.indexOf(shape);\n      \n      shape.dragBoundFunc= dragFunc;\n\n      let coord_y1=grp.line.y-grp.line.points[4]*(1/2)*grp.line.scaleX*Math.sin(grp.line.rotation*(Math.PI/180));\n      let coord_x2=grp.line.x+grp.line.points[4]*(1/2)*grp.line.scaleX*Math.cos(grp.line.rotation*(Math.PI/180));\n      let coord_y2= grp.line.y+grp.line.points[4]*(1/2)*grp.line.scaleX*Math.sin(grp.line.rotation*(Math.PI/180));\n      let coord_x1=grp.line.x-grp.line.points[4]*(1/2)*grp.line.scaleX*Math.cos(grp.line.rotation*(Math.PI/180));\n      let a=(coord_y2-coord_y1)/(coord_x2-coord_x1);\n      //let b=grp.line.y-a*grp.line.x;\n      let b=shape.x*(1/a)+shape.y;\n      if (grp.line.rotation<0 && grp.line.rotation>-90){\n        \n        shape.x=shape.x-added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } else if(grp.line.rotation<-90){\n        shape.x=shape.x-added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } else if( grp.line.rotation>0 && grp.line.rotation<180){\n        \n        shape.x=shape.x+added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } \n      else if(grp.line.rotation==-90){\n        shape.x=shape.x+added_distance\n      } else if(grp.line.rotation==90){\n        shape.x=shape.x-added_distance\n      } else if(grp.line.rotation==180 || grp.line.rotation==-180){\n        shape.y=shape.y-added_distance\n      } else if(grp.line.rotation==0){\n        shape.y=shape.y+added_distance\n      } \n      //shape.rotation=shape.rotation+shape.personalRotation;\n      shape.isGrouped=0;\n      this.shapes.push(shape,)\n      this.center.x=shape.x;\n      this.center.y=shape.y;\n      grp.line.freeDistances.push(grp.line.occupiedDistances[i]);\n      grp.line.occupiedDistances.splice(i,1);\n      grp.shapes_g.splice(i,1);\n      grp.line.positionPoints.splice(i,1)\n      \n      this.updateOccupiedDistance(grp.id)\n      this.updateAllPosInGrp(grp.id)\n    \n    },\n    */\n    /*\n\n    //called when the button \"Detach Shape\" is clicked\n    DetachShapeButtonAction(){\n      let shape= ContextMenu.props.ConcernedShape;\n      if(shape.attrs.className==\"Line\"){\n        let shapes_g=shape.getParent().attrs.shapes_g;\n        while(shapes_g.length!=0){\n          this.DetachShape(shapes_g[0]);\n        }\n      }else{\n        let shape_data=this.shapes.find(i => i.id ===shape.attrs.id);\n        let isFunded=true;\n        if(shape_data==undefined){\n          isFunded=false;\n        }\n        let i=0;\n        while(!isFunded){\n          if(i<this.groups.length){\n            shape_data=this.groups[i].shapes_g.find(i => i.id === shape.attrs.id);\n          if(shape_data==undefined){\n            isFunded=false;\n          }else{\n            isFunded=true;\n          }\n          i++;\n          }else{        \n            isFunded=true;\n          }\n        }\n        this.DetachShape(shape_data)\n      }\n    },\n\n    //called when the button \"keep/liberate distribution\" is clicked.\n    KeepDistribution(){\n      let grp=this.groups.find(i => i.id === ContextMenu.props.ConcernedShape.attrs.id);\n      let line=grp.line;\n      if(line==undefined){\n        return;\n      }else{\n        if(line.keepDistribution){\n          line.keepDistribution=false;\n          for (let i=0;i<grp.shapes_g.length;i++){\n            grp.shapes_g[i].distance_to_line_center=line.occupiedDistances[i]\n          }\n          line.freeDistances=[];\n\n          line.stroke='blue'\n          grp.line.keepDistanceButtonText=\"Keep Distribution\";\n          //ContextMenu.props.ConcernedShape.attrs.keepDistanceButtonText=\"Keep Distribution\";\n        }else{\n          line.keepDistribution=true;\n          for (let i=0;i<grp.shapes_g.length;i++){\n            line.occupiedDistances[i]=grp.shapes_g[i].distance_to_line_center;\n          }\n          line.stroke='black'\n          grp.line.keepDistanceButtonText=\"Liberate Distribution\";\n          //ContextMenu.props.ConcernedShape.attrs.keepDistanceButtonText=\"Liberate Distribution\";\n          this.updateOccupiedDistance(line.id);\n          this.updateAllPosInGrp(line.id);\n        }\n      }\n    },\n    */\n    createNewShape(shape){\n      if(shape.attrs.className==\"Line\"){\n        \n        this.max_id_figures=this.max_id_figures+1;\n\n          let clone=shape.getParent().clone({\n            id: ''+this.max_id_figures,\n            name: \"group\"+this.max_id_figures,\n            shapes_g:[],\n          })\n          clone.attrs.line.id=''+this.max_id_figures;\n          clone.attrs.line.x=shape.getStage().getPointerPosition().x;\n          clone.attrs.line.y=shape.getStage().getPointerPosition().y;\n          clone.attrs.line.draggable=true;\n          this.groups.push(clone.attrs,)\n          \n        \n      }else{\n        \n        this.max_id_figures=this.max_id_figures+1\n        let clone=shape.clone({\n          id: ''+this.max_id_figures,\n          draggable: true,\n        })\n        clone.attrs.isGrouped=0;\n        this.shapes.push(clone.attrs,);\n      }\n      \n\n    },\n    \n  \n  eraserAction(e){\n    this.Remove(e.target);\n    \n  },\n  unshowSelectedShape(e){\n    if(e.target.attrs.className==\"Line\" && this.eraseMode==0){\n      e.target.opacity(0.5)\n    }\n    else if(e.target.attrs.className==\"Line\" && this.eraseMode==1){\n      if(e.target.attrs.keepDistribution==1){\n        e.target.stroke(\"rgb(48,48,48)\")\n      }else{\n        e.target.stroke(\"blue\")\n      }\n    }\n    else if(e.target.attrs.className==\"positionPoint\" && this.eraseMode==1){\n      if(e.target.getParent().attrs.line.keepDistribution!=1){\n        e.target.strokeWidth(0)\n      }\n    }\n    else if(this.eraseMode==1){\n      e.target.strokeWidth(0)\n    }\n  },\n  showSelectedShape(e){\n    if(e.target.attrs.className==\"Line\" && this.eraseMode==0){\n      e.target.opacity(1)\n    }\n    else if(e.target.attrs.className==\"Line\" && this.eraseMode==1){\n      e.target.stroke('rgb(200, 59, 218)')\n    }\n    else if(e.target.attrs.className==\"positionPoint\" && this.eraseMode==1){\n      let line=e.target.getParent().attrs.line;\n      if(line.freeDistances.indexOf(e.target.attrs.distance_to_line_center)!=-1){\n        if(line.keepDistribution!=1){\n          e.target.stroke('rgb(200, 59, 218)')\n          e.target.strokeWidth(3)\n        }\n      }\n    }\n    else if(this.eraseMode==1){\n      e.target.stroke('rgb(200, 59, 218)')\n      e.target.strokeWidth(3)\n    }\n    /*\n    let shape=e.target;\n    if(this.eraseMode==1){\n    let shape_data=this.shapes.find(i => i.id ===shape.attrs.id);\n    let isFunded=true;\n    if(shape_data==undefined){\n      isFunded=false;\n      let i=0;\n      while(!isFunded){\n        if(i<this.groups.length){\n          shape_data=this.groups[i].shapes_g.find(i => i.id === shape.attrs.id);\n        if(shape_data==undefined){\n          isFunded=false;\n          i++;\n        }else{\n          isFunded=true;\n        }\n        }else{        \n          isFunded=true;\n        }\n      }\n    }\n    if (shape_data!=undefined){\n      shape_data.opacity=0.3\n    }\n    */\n\n  },\n  editText(e){\n    //let valuey=document.getElementById(\"stage\").style.top+e.target.y()\n    //let valuex=document.getElementById(\"stage\").style.left+e.target.x()\n    let stageBox=e.target.getStage().attrs.container.getBoundingClientRect();\n    document.getElementById(\"input\").style.top=stageBox.y+e.target.getAbsolutePosition().y+'px';\n    document.getElementById(\"input\").style.left=stageBox.x+e.target.getAbsolutePosition().x-document.getElementById(\"input\").size*5+'px';\n    document.getElementById(\"input\").style.display=\"initial\"\n    this.editedText=e.target\n  },\n  updateText(e){\n    let shape=this.shapes.find(i => i.id ===this.editedText.attrs.id);\n    let isFunded=true;\n    if(shape==undefined){\n      isFunded=false;\n    }\n    let i=0;\n    while(!isFunded){\n      if(i<this.groups.length){\n        shape=this.groups[i].shapes_g.find(i => i.id === this.editedText.attrs.id);\n      if(shape==undefined){\n        isFunded=false;\n      }else{\n        isFunded=true;\n      }\n      i++;\n      }else{        \n        isFunded=true;\n      }\n    }\n    if(shape!=undefined){\n    let last_width;\n    let last_height;\n    let diff_width;\n    let diff_height;\n\n    last_width=this.editedText.width();\n    last_height=this.editedText.height();\n\n    shape.text=e.target.value;\n\n    this.editedText.text(e.target.value);\n    diff_width=this.editedText.width()-last_width;\n    diff_height=this.editedText.height()-last_height;\n\n    \n    shape.offsetX=shape.offsetX+diff_width/2\n    shape.offsetY=shape.offsetY+diff_height/2\n    shape.length_x=this.editedText.width()\n    shape.length_y=this.editedText.height()\n    document.getElementById(\"input\").style.display=\"none\"\n    }\n\n  },\n  updateNaration(grp){\n      let text=\"<strong>Substrate :</strong><br>\"\n      text=text+\"- <mark class='red'> StickyLine </mark><br>\";\n      text=text+\"Relation: <i>alignement with</i>:\";\n      for(let j=0;j<grp.shapes_g.length;j++){\n        text=text+\"<br>\"+\"- \"+grp.shapes_g[j].className\n      }\n      this.$emit('explain',{origin:\"Substrate - Reification<br><mark class='red'> The Stickyline preserves the relationship of alignment with objects into a substrate. </mark>\",text:text});\n  }\n},\n};\n\n</script>\n<style>\n#playground{\n  cursor: default\n}\n#activeReuseSubstrate{\n  position:absolute;\n  display: none;\n  top: 0px;\n  left: 0px;\n  width: 60px;\n  background-color: white;\n  box-shadow: 0 0 5px grey;\n  border-radius: 3px;\n}\n#center_menu{\n  position: absolute;\n  display: none;\n  top: 0px;\n  left: 0px;\n  width: 60px;\n  background-color: white;\n  box-shadow: 0 0 5px grey;\n  border-radius: 3px;\n}\ninput{\n  position:absolute;\n  display: none;\n  top:0px;\n  left:0px; \n}\n</style> ","import { render } from \"./ReificationSubstrateDemo.vue?vue&type=template&id=0cf1e78f\"\nimport script from \"./ReificationSubstrateDemo.vue?vue&type=script&lang=js\"\nexport * from \"./ReificationSubstrateDemo.vue?vue&type=script&lang=js\"\n\nimport \"./ReificationSubstrateDemo.vue?vue&type=style&index=0&id=0cf1e78f&lang=css\"\n\nimport exportComponent from \"/Users/junhangyu/Desktop/PE code/github/teachingApp/node_modules/vue-loader/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render]])\n\nexport default __exports__","<template>\n<!--Component of the narative box-->\n\n<div id=\"box\">\n    <p id=\"narativebox\" v-for=\"item in sentences\" :key=\"item\" v-html=\"item\"></p>\n</div>\n</template>\n<script>\nexport default {\n  props:['textsForNaration'],\n\n  data() {\n    return {\n        sentences:this.textsForNaration //Text that have to be shown in the \"narative box\"\n    }\n  }\n}\n</script>\n<style>\n#narativebox{\n  width:400px;\n}\n#box{\n  position:absolute;\n  height:720px;\n  width:400px;\n  border: solid;\n  overflow-y: scroll;\n  scroll-behavior: auto;\n}\nmark.red{\n    color:#ff0000;\n    background: none;\n}\nmark.blue{\n    color:blue;\n    background: none;\n}\nmark.yellow{\n  color:yellow;\n  background: none;\n}\nmark.green{\n  color:green;\n  background: none;\n}\nmark.black{\n  color:black;\n  background: none;\n}\nmark.grey{\n  color:rgb(48,48,48);\n  background: none;\n}\nmark.pink{\n  color:rgb(240, 110, 214);\n  background: none;\n}\n\n</style>","import { render } from \"./NarativeBox.vue?vue&type=template&id=6e258c82\"\nimport script from \"./NarativeBox.vue?vue&type=script&lang=js\"\nexport * from \"./NarativeBox.vue?vue&type=script&lang=js\"\n\nimport \"./NarativeBox.vue?vue&type=style&index=0&id=6e258c82&lang=css\"\n\nimport exportComponent from \"/Users/junhangyu/Desktop/PE code/github/teachingApp/node_modules/vue-loader/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render]])\n\nexport default __exports__","import { render } from \"./InstrumentalInteraTableView.vue?vue&type=template&id=109734b7\"\nimport script from \"./InstrumentalInteraTableView.vue?vue&type=script&lang=js\"\nexport * from \"./InstrumentalInteraTableView.vue?vue&type=script&lang=js\"\n\nimport \"./InstrumentalInteraTableView.vue?vue&type=style&index=0&id=109734b7&lang=css\"\n\nimport exportComponent from \"/Users/junhangyu/Desktop/PE code/github/teachingApp/node_modules/vue-loader/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render]])\n\nexport default __exports__","<template>\n\n  <!--Human-Computer Partnerships overview-->\n\n  <div class=\"HCPartnershipsTable\" style=\"display:table\">\n  <div style=\"display:table-cell\">\n    <table>\n      <tr>\n        <th></th>\n        <th>Discoverability</th>\n        <th>Appropriability</th>\n        <th>Expressivity</th>\n      </tr>\n      <tr>\n        <th>Instrument (Input)</th>\n        <td>\n          <div id=\"discoverabilityDemo\">\n          <DiscoverabilityDemo :height=\"height\" :width=\"width\" @explain=\"addExplanation\"></DiscoverabilityDemo>\n          </div>\n          <p class=\"caption\">Use the eraser and see what can be erased</p>\n        </td>\n        <td>\n          <div id=\"appropriabilityDemo\">\n          <AppropriabilityDemo :height=\"height\" :width=\"width\" @explain=\"addExplanation\"></AppropriabilityDemo>\n          </div>\n          <p class=\"caption\">Resize the stickyline to catch each shape with only one vertical movement</p>\n        </td>\n        <td>\n          <div id=\"expressivityDemo\">\n           <ExpressivityDemo :height=\"height\" :width=\"width\" @explain=\"addExplanation\"></ExpressivityDemo>\n         \n            </div>\n          <p class=\"caption\">Tweak Stickyline to align from gravity centers(green dots) rather than geometrical centers(red dots)</p>\n        </td>\n      </tr>\n      <tr>\n        <th>Substrate (Output)</th>\n        <td>\n          <div id=\"discoverabilitySubstrateDemo\">\n          <DiscoverabilitySubstrateDemo :height=\"height\" :width=\"width\" @explain=\"addExplanation\"></DiscoverabilitySubstrateDemo>\n          </div>\n          <p class=\"caption\">Try to swap object by moving them on the stickyline. An indication will appear.</p>\n        </td>\n        <td>\n          <div id=\"appropriabilitySubstrateDemo\">\n          <AppropriabilitySubstrateDemo :height=\"height\" :width=\"width\" @explain=\"addExplanation\"></AppropriabilitySubstrateDemo>\n          </div>\n          <p class=\"caption\">Right click on the line/center to change distribution mode/alignment center. Stretch and rotate the stickyline.</p>\n        </td>\n        <td>\n          <div id=\"expressivitySubstrateDemo\" >\n            <ExpressivitySubstrateDemo :height=\"height\" :width=\"width\" @explain=\"addExplanation\"></ExpressivitySubstrateDemo>\n          </div>\n          <p class=\"caption\">Draw a second Stickyline through the tweaks of the words and use both Stickylines to re-style the text.</p>\n        </td>\n        \n      </tr>\n    </table>\n  </div>\n  \n  <div id=\"narationBox\" style='display:table-cell'>\n  <NarativeBox class=\"narativeBox\" :texts-for-naration=\"naration\" ></NarativeBox>\n  </div>\n  </div>\n</template>\n\n<script>\n// @ is an alias to /src\nimport AppropriabilityDemo from '@/components/canvas/hc-partnerships-demo/AppropriabilityDemo.vue'\nimport AppropriabilitySubstrateDemo from '@/components/canvas/hc-partnerships-demo/AppropriabilitySubstrateDemo.vue'\nimport NarativeBox from '@/components/interactive-components-for-canvas/NarativeBox.vue'\nimport DiscoverabilitySubstrateDemo from '@/components/canvas/hc-partnerships-demo/DiscoverabilitySubstrateDemo.vue'\nimport DiscoverabilityDemo from '@/components/canvas/hc-partnerships-demo/DiscoverabilityDemo.vue'\nimport ExpressivityDemo from '@/components/canvas/hc-partnerships-demo/ExpressivityDemo.vue'\nimport ExpressivitySubstrateDemo from '@/components/canvas/hc-partnerships-demo/ExpressivitySubstrateDemo.vue'\n\n\n\nexport default {\n  name: 'HCPartnershipsTableView',\n  components: {\n    AppropriabilitySubstrateDemo,\n    AppropriabilityDemo,\n    DiscoverabilitySubstrateDemo,\n    DiscoverabilityDemo,\n    ExpressivityDemo,\n    ExpressivitySubstrateDemo,\n    NarativeBox,\n    \n  },\n  created() {\n        this.width = 300;\n        this.height = 260;\n  },\n  updated(){\n    let elem = document.getElementsByClassName(\"narativeBox\")[0]\n    elem.scrollTop=elem.scrollHeight\n  },\n  data(){\n    return{\n      naration:[],\n      last_origin:'',\n      last_text:'',\n    }\n  },\n  methods:{\n    addExplanation(e){\n      let text=e.text\n      if(e.origin!=this.last_origin){\n        this.last_origin=e.origin;\n        this.last_text=text\n        this.naration.splice(0,this.naration.length)\n        this.naration.push(e.origin+\" :<br>\",)\n        \n      this.naration.push(text,);\n      }else if(text!=this.last_text){\n      this.naration.push(\"***\",)\n      this.naration.push(text,);\n      this.last_text=text\n      }\n      let elem = document.getElementsByClassName(\"narativeBox\")[0]\n      \n      elem.scrollTop=elem.scrollHeight\n    },\n  }\n}\n</script>\n\n<style>\ntable, th, td {\n  border: 1px solid black;\n  border-collapse: collapse;\n}\n.caption{\n  width: 300px;\n  height:auto;\n}\n</style>\n","<template>\n\n<div @click=\"HideContextMenu\" id=\"AppropriabilityDemo\"\n    @mousedown=\"updateNaration(this.groups[0])\">\n\n  <ToolBar :height=\"100\" :width=\"400\"\n  @need_new_shape=\"createNewShape\" @eraser_is_selected=\"switchEraseMode\"></ToolBar>\n\n  <v-stage\n    ref=\"stage\"\n    id=\"stage\"\n    :config=\"stageSize\"\n    @dragmove=\"update\"\n    @mousedown=\"handleTransformation\"\n    @touchstart=\"handleTransformation\"\n    @fusion=\"makeGroup\"\n    @contextMenu=\"DisplayContextMenu\"\n  >\n    <v-layer ref=\"layer\">\n      <!--\n        see if a group should contain more than one line\n      -->\n      <!--\n      <v-circle :key=\"center.id\" :config=\"center\"/>\n      -->\n      <v-group ref=\"groups\" v-for=\"step in groups\" :key=\"step.id\" :config=\"step\">\n      \n      \n      \n        <v-rect\n        v-for=\"item in step.shapes_g.filter(i=>i.className=='Rect')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        \n       \n        @transformend=\"updateTransformedShape\"\n        @dragend= \"updatePosInGrp($event,step.id) \"\n        @dragmove=\"CheckIfNeedToDetach\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n      />\n      <v-circle\n        v-for=\"item in step.shapes_g.filter(i=>i.className=='Circle')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragend=\"updatePosInGrp($event,step.id)\"\n        @dragmove=\"CheckIfNeedToDetach\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n      />\n      \n      <v-image\n        v-for=\"item in step.shapes_g.filter(i=>i.className=='Image')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragend=\"updatePosInGrp($event,step.id)\"\n        @dragmove=\"CheckIfNeedToDetach\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n      />\n      <v-text\n        v-for=\"item in step.shapes_g.filter(i=>i.className=='Text')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragend=\"updatePosInGrp($event,step.id)\"\n        @dragmove=\"CheckIfNeedToDetach\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n\n        @dblclick=\"editText\"\n        />\n        <v-regular-polygon\n        v-for=\"item in step.shapes_g.filter(i=>i.className=='Triangle')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragend=\"updatePosInGrp($event,step.id)\"\n        @dragmove=\"CheckIfNeedToDetach\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n      />\n        <v-line \n        :key=\"step.line.id\"\n        :config=\"step.line\"\n        @transformend=\"updateTransformedShape\"\n        @dragmove=\"updateGrp($event,step.id)\"\n        @mouseout=\"unshowSelectedShape\"\n        @mouseenter=\"showSelectedShape\"\n        />\n    <v-circle\n        v-for=\"item in step.line.positionPoints\"\n        :key=\"item.id\"\n        :config=\"item\"\n        \n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n      />\n      </v-group>\n      <v-rect\n        v-for=\"item in shapes.filter(i=>i.className=='Rect')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragmove=\"updatePos\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n        \n      />\n      \n      <v-circle\n        v-for=\"item in shapes.filter(i=>i.className=='Circle')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragmove=\"updatePos\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n        \n      />\n      <!--\n      <v-image\n        v-for=\"item in shapes.filter(i=>i.className=='Image')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragmove=\"updatePos\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n        />\n     \n      <v-text\n        v-for=\"item in shapes.filter(i=>i.className=='Text')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragmove=\"updatePos\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n        \n        @dblclick=\"editText\"\n        /> \n      -->\n      <v-regular-polygon\n        v-for=\"item in shapes.filter(i=>i.className=='Triangle')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragmove=\"updatePos\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n        />\n      \n      \n      <v-transformer  v-for=\"item in transformers\" :key=\"item.id\" :config=\"item\"/>\n      <v-circle :key=\"center.id\" :config=\"center\"\n      @dragend=\"ChangeCenter\"\n      @click=\"DisplayCenterMenu\"/>\n      <!--\n      <v-transformer id=\"shapeTransformer\"/>\n      <v-transformer id=\"lineTransformer\" :config=\"{enabledAnchors: ['middle-left', 'middle-right'],}\" />\n      -->\n    </v-layer>\n    \n  </v-stage>\n  \n  <!--\n  <div id=\"active\">\n  <ContextMenu :menu-of-stage=\"isStageOnlySelected\" :menu-of-line=isALineSelected :menu-of-grouped-shape=isAGroupedShapeSelected :keep-distance-button-text=\"this.keepDistanceButtonText\" \n  @changecenter-button=\"ChangeCenterButtonAction\" @detachshape-button=\"DetachShapeButtonAction\" @keepdistance-button=\"KeepDistribution\"\n  @copy-button=\"Copy\" @copy-all-button=\"CopyAll\" @past-button=\"Past\" @remove-button=\"Remove\" @remove-all-button=\"RemoveAll\"></ContextMenu>\n  </div>\n  <div id=\"center_menu\">\n  <CenterMenu :defaultAlignment=\"this.selectedShapeAlignment\" @center-button=\"ChangeAlignCenter\"></CenterMenu>\n  </div>\n  -->\n  \n  <input type=\"text\" id=\"input\" \n        size=\"10\" value=\"a text\"\n       @keyup.enter=\"updateText\"\n       >\n  </div>\n</template>\n\n<script>\n\n//import ContextMenu from \"./ContextMenu.vue\"\n//import CenterMenu from \"./CenterMenu.vue\"\n//import ToolBar from \"./ToolBar.vue\";\n\n\nconst dragFunc=function (pos) {\n  let width=this.getStage().width();\n  let height=this.getStage().height();\n  let strokeSize=10\n    if(pos.x>width-strokeSize && pos.y>height-strokeSize){\n      return{\n        x: width-strokeSize,\n        y: height-strokeSize,\n      }\n    } else if(pos.x>width-strokeSize && pos.y<strokeSize){\n      return{\n        x: width-strokeSize,\n        y: strokeSize,\n      }\n    } else if(pos.y>height-strokeSize && pos.x<strokeSize){\n      return{\n        x: strokeSize,\n        y: height-strokeSize,\n      }\n    } else if(pos.x<strokeSize && pos.y<strokeSize){\n      return{\n        x: strokeSize,\n        y: strokeSize,\n      }\n    } else if(pos.x<strokeSize){\n      return{\n        x: strokeSize,\n        y: pos.y,\n      }\n    }else if(pos.y<strokeSize){\n      return{\n        x: pos.x,\n        y: strokeSize,\n      }\n    }else if(pos.x>width-strokeSize){\n      return{\n        x: width-strokeSize,\n        y: pos.y,\n      }\n    }else if(pos.y>height-strokeSize){\n      return{\n        x: pos.x,\n        y: height-strokeSize,\n      }\n    } else{\n      return {\n        x: pos.x,\n        y: pos.y,\n      };\n    }\n};\n\n\nexport default {\n  props:{\n    width:{\n      type: Number,\n      default:window.innerWidth,\n    },\n    height:{\n      type: Number,\n      default:window.innerHeight,\n    }\n  },\n  components:{\n    //ContextMenu,\n    //CenterMenu,\n    //ToolBar,\n},\n  data() {\n    return {\n      stageSize: {\n        width: this.width,\n        height: this.height,\n      },\n      lengthToCapture:10,\n      lengthToDetach:15,\n      editedText:null,\n\n      eraseMode:0,\n\n      selectedShapeAlignment:'',\n      \n      needMenu: 'initial', //say if the context menu has to be \"active\" or not.\n      isALineSelected:false, \n      isAGroupedShapeSelected:false,\n      isStageOnlySelected: false,\n      //dragItemId: null, //id of the item which is dragging.\n      //text which will appear on the button corresponding to the management of the distribution\n      keepDistanceButtonText:\"Liberate Distribution\",\n      max_id_figures: 6, //max among id of shapes and line since the canvas exist (line excluded) \n      //max_id_lines: 2, //max among id of lines since the canvas exist (line excluded) \n      //groups of shapes (ie a line with shapes on it)\n      groups:[{\n        //rotation: 20,\n        name: \"group\",\n        className: \"Group\",\n        id: '6',\n        x:0,\n        y:0,\n        offsetX:0,\n        offsetY:0,\n        rotation: 0,\n        draggable: false,\n        shapes_g:[], //list of shapes that are on the line\n        //the line of the group:\n        aShapeHasBeenDetach:0,\n        line:{\n          x:150,\n          y:250,\n          points: [0, 0, 0, 0, 100, 0],\n          positionPoints:[],\n          strokeWidth: 10,\n          rotation: 0,\n          tension:0,\n          closed: true,\n          draggable: true,\n          scaleX:1,\n          scaleY:1,\n          opacity:0.5,\n          offset:{\n            x:50,\n            y:0,\n          },\n          name: \"ligne\",\n          className: \"Line\",\n          stroke: 'red',\n          id:'6',\n          //distShapesToCenter:[],\n          keepDistribution: false, //say of we keep the distribution on the line or not\n          freeDistances:[], // distance that can be taken by other shapes (if we keep distribution on the line).\n          occupiedDistances:[], //distance already \"taken\" by shapes on the line.       \n          //text which will appear on the button corresponding to the management of the distribution:\n          keepDistanceButtonText:\"Liberate Distribution\",\n          //function which determine how the line can be dragged:\n          defaultAlignment:\"Bottom\",\n          dragBoundFunc: dragFunc,\n        },\n      },\n      /*{\n        name: \"group2\",\n        className: \"Group\",\n        id: '7',\n        x:0,\n        y:0,\n        offsetX:0,\n        offsetY:0,\n        rotation: 0,\n        draggable: false,\n        shapes_g:[],\n        line:{\n        x:500,\n        y:300,\n        points: [0, 0, 0, 0, 300, 0],\n        positionPoints:[],\n        strokeWidth: 10,\n        rotation: 0,\n        tension:0,\n        closed: true,\n        draggable: true,\n        scaleX:1,\n        scaleY:1,\n        opacity:0.5,\n        offset:{\n          x:150,\n          y:0,\n        },\n        //draggable:true,\n        name: \"ligne\",\n        className: \"Line\",\n        stroke: 'black',\n        id:'7',\n        distShapesToCenter:[],\n        keepDistribution: true,\n        freeDistances:[],\n        occupiedDistances:[],\n        keepDistanceButtonText:\"Liberate Distribution\",\n        defaultAlignment:\"Middle\",\n        dragBoundFunc: dragFunc,\n      },\n      \n      }*/\n      ],\n      transformers:[\n        {\n          id: 'lineTransformer',\n          enabledAnchors: ['middle-left', 'middle-right'],\n          flipEnabled: false, // in order to not have a rotation of the transformer which lead to problem related to shapes position on a line\n          nodes: [],\n\n        },\n        {\n          id: 'shapeTransformer',\n          nodes: [],\n        }\n      ],\n      shapes: [\n        /*\n        {\n          rotation: 0,\n          id: '1',\n          x: 100,\n          y: 10,\n          width: 130,\n          height: 100,\n          scaleX: 1,\n          scaleY: 1,\n          strokeWidth: 0,\n          stroke: 'black',\n          fill: 'red',\n          name: 'rect1',\n          draggable: true,\n          className:\"Rect\",\n          isGrouped: 0, //if =0 the shape is not attached to a stickyline. if=1, it does.\n          offsetX:130/2,\n          offsetY:0,\n          personalRotation:0, \n          centerPosition:'Top',\n          dragBoundFunc: dragFunc\n          \n        },\n        */\n        \n        {\n          rotation: 0,\n          id:'2',\n          x: 150,\n          y: 210,\n          width: 70,\n          height: 70,\n          scaleX: 1,\n          scaleY: 1,\n          strokeWidth: 0,\n          stroke: 'black',\n          fill: 'green',\n          name: 'rect2',\n          draggable: true,\n          className:\"Rect\",\n          isGrouped: 0,\n          dragBoundFunc: dragFunc,\n          offsetX: 70/2,\n          offsetY: 70,\n          /*When it is on a line, a shape can be rotate by the user independently from the line.\n          To keep the independant rotation of the attached shape, we add the parameter \"personalRotation\".\n          So, when the shape is attached, is final rotation is the sum of this parameter with the rotation of the line.\n          */\n          personalRotation:0, \n          centerPosition:'Bottom',\n        },\n        {\n        rotation:0,\n        x: 50,\n        y: 100,\n        scaleX:1,\n        scaleY:1,\n        offsetX: 0,\n        offsetY: 40,\n        radius: 40,\n        fill: 'orange',\n        strokeWidth: 0,\n        stroke: 'black',\n        draggable:true,\n        isGrouped: 0,\n        className:\"Circle\",\n        /*When it is on a line, a shape can be rotate by the user independently from the line.\n          To keep the independant rotation of the attached shape, we add the parameter \"personalRotation\".\n          So, when the shape is attached, is final rotation is the sum of this parameter with the rotation of the line.\n          */\n        personalRotation:0, \n        id:'3',\n        dragBoundFunc: dragFunc,\n        centerPosition:'Bottom',\n      },\n      /*\n        {\n            text: 'A text',\n            rotation: 0,\n            x: 400,\n            y: 200,           \n            scaleX:1,\n            scaleY:1,\n            offsetY:0,\n            offsetX: 36,\n            length_x:72,\n            length_y:30,\n            draggable: true,\n            isGrouped: 0,\n            className:\"Text\",    \n            fontSize: 30,\n            fontFamily: 'Calibri',\n          personalRotation:0,\n            id:'4',\n            dragBoundFunc:dragFunc,\n            centerPosition:'Top',\n        },\n        {\n            rotation: 0,\n            x: 700,\n            y: 400,           \n            scaleX:1,\n            scaleY:1,\n            offsetY:0,\n            offsetX:0,\n            //width:72,\n            //height:30,\n            image: null,\n            draggable: true,\n            isGrouped: 0,\n            className:\"Image\", \n               \n            fontSize: 30,\n          personalRotation:0, \n            id:'5',\n            dragBoundFunc:dragFunc,\n            centerPosition:'Top',\n        },\n        */\n         {\n          rotation: 0,\n          id:'8',\n          x: 250,\n          y: 100,\n          sides:3,\n          radius:45,\n          width: 90,\n          height: 90,\n          scaleX: 1,\n          scaleY: 1,\n          strokeWidth: 0,\n          stroke: 'black',\n          fill: 'purple',\n          name: 'triangle1',\n          draggable: true,\n          className:\"Triangle\",\n          isGrouped: 0,\n          dragBoundFunc: dragFunc,\n          offsetX: 0,\n          offsetY: 22.5,\n          personalRotation:0, \n          centerPosition:'Bottom',\n        },\n      ],\n      center:{\n        x: 300,\n        y: 500,\n        scaleX:1,\n        scaleY:1,\n        offsetX: 0,\n        offsetY: 0,\n        radius: 4,\n        fill: 'black',\n        opacity:1,\n        draggable:true,\n        isGrouped: 0,\n        className:\"Circle\",\n        id:'center',\n        dragBoundFunc:dragFunc,\n      },\n      positionPoint:{\n        x: 300,\n        y: 500,\n        scaleX:1,\n        scaleY:1,\n        offsetX: 0,\n        offsetY: 0,\n        radius: 3,\n        fill: 'yellow',\n        opacity:1,\n        draggable:false,\n        isGrouped: 0,\n        className:\"positionPoint\",\n        id:'positionPoint',\n        distance_to_line_center:undefined,\n      },\n      selectedShapeId: '',\n    };\n  },\n  mounted(){\n    let texts=this.$refs.stage.getStage().getChildren()[0].getChildren().filter((r)=>r.attrs.className=='Text');\n    \n    \n    for(let i=0;i<texts.length;i++){\n      texts[i].attrs.length_x=texts[i].width();\n      texts[i].attrs.length_y=texts[i].height();\n      texts[i].offsetX(texts[i].attrs.length_x/2);\n    }\n  },\n  created(){\n    //nb of shapes on the canvas (line excluded), we consider that there is no shape on line:\n    this.max_id_figures=this.shapes.length +this.groups.length; \n    //this.max_id_lines=this.groups.length;\n    /*\n    const image = new window.Image();\n    image.src = require(\"@/assets/exsitu.png\");\n    // set image only when it is loaded\n    image.height=150;\n    image.width=150;\n    image.onload = () => {\n      this.shapes.find((r)=>r.className===\"Image\").image= image;\n      this.shapes.find((r)=>r.className===\"Image\").offsetX=image.width/2;\n      this.shapes.find((r)=>r.className===\"Image\").offsetY=0; \n    };\n    */\n  },\n  methods: {\n\n    switchEraseMode(){\n      if(this.eraseMode==0){\n        this.eraseMode=1;\n        document.getElementById(\"playground\").style.cursor='url('+require('@/assets/ugly_eraser.png')+'),default';\n        \n      this.eraseNodefromTransformer(\"shapeTransformer\");\n      this.eraseNodefromTransformer(\"lineTransformer\");\n      } else{\n        this.eraseMode=0;\n        document.getElementById(\"playground\").style.cursor=\"default\";\n      }\n    },\n    /*\n    Check if all shapes that are supposed to be on a line still in this line.\n    id_grp is the id of the group which contains the line.\n    */\n    checkIfShapesOnLine(id_grp){\n      const grp= this.groups.find((r) => r.id===id_grp);\n      const line=grp.line;\n      const groupedShapes = grp.shapes_g;\n      //const lengthToDetach=10;\n      \n      /*\n      To determine if a shape is on a line, we see if the point is not on the corresponding\n      straight line y=a*x+b regarding certains intervals for x and y.Those intervals depends of the rotation of\n      the line. \n      */\n     /*\n      let coord_y1=line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x1=line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let coord_y2= line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x2=line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let a=(coord_y1-coord_y2)/(coord_x2-coord_x1);\n      let b=line.y-a*line.x;\n      let is_on_straight_line=false;\n      */\n      \n      let i=0;\n      while(i<groupedShapes.length){\n        /*\n        if(Math.abs(coord_x1-coord_x2)>1){\n        is_on_straight_line=(Math.abs(a*groupedShapes[i].x+b-groupedShapes[i].y)<this.lengthToDetach);\n      }else{\n        is_on_straight_line=(Math.abs(groupedShapes[i].x-line.x)<this.lengthToDetach);\n      }\n        if (\n          !(is_on_straight_line)\n        ||((line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].y\n        ||line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].y)\n        && ((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n        ||((line.x+line.points[4]*line.scaleX*(1/2)*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].x\n        ||line.x-line.points[4]*line.scaleX*(1/2)*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].x)\n        &&((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n        ||((line.y+line.points[4]*line.scaleX*(1/2)*Math.sin(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].y\n        ||line.y-line.points[4]*line.scaleX*(1/2)*Math.sin(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].y)\n        &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>=-Math.PI)))\n\n        ||((line.x+line.points[4]*line.scaleX*(1/2)*Math.cos(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].x\n        ||line.x-line.points[4]*line.scaleX*(1/2)*Math.cos(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].x)\n        &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>=-Math.PI)))\n\n        ||((line.y+line.points[4]*line.scaleX*(1/2)*Math.sin(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].y\n        ||line.y-line.points[4]*line.scaleX*(1/2)*Math.sin(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].y)\n        &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n        ||((line.x+line.points[4]*line.scaleX*(1/2)*Math.cos(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].x\n        ||line.x-line.points[4]*line.scaleX*(1/2)*Math.cos(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].x)\n        &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n        ||((line.y+line.points[4]*line.scaleX*(1/2)*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].y\n        ||line.y-line.points[4]*line.scaleX*(1/2)*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].y)\n        &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>0)))\n\n        ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].x\n        ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].x)\n        &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>0)))\n        )\n        */\n       if(!this.isCoordinateOnLine(groupedShapes[i].x,groupedShapes[i].y,line.id)){\n          console.log(\"a shape is not on a line\");\n          groupedShapes[i].dragBoundFunc= dragFunc;\n          groupedShapes[i].isGrouped=0;\n          line.positionPoints.splice(i,1)\n          \n          this.shapes.push(groupedShapes[i],)\n          line.freeDistances.push(line.occupiedDistances[i]);\n          line.occupiedDistances.splice(i,1);\n          groupedShapes.splice(i,1);\n          this.updateNaration(grp)\n        }else{\n          i=i+1;\n        }\n      }\n    },\n\n    //say of {x,y} is a point from the line\n    isCoordinateOnLine(x,y,id_grp){\n      const grp=this.groups.find((r) => r.id===id_grp);\n      const line=grp.line;\n      let is_not_on_straight_line=true;\n      let coord_y1=line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x1=line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let coord_y2= line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x2=line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let a=(coord_y1-coord_y2)/(coord_x2-coord_x1);\n      let b=line.y-a*line.x;\n      if(Math.abs(coord_x1-coord_x2)>1){\n        is_not_on_straight_line=(Math.abs(a*x+b-y)>1);\n      }else{\n        is_not_on_straight_line=(Math.abs(x-line.x)>1)\n      }\n      if(\n        (is_not_on_straight_line)\n\n      ||((line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<y\n      ||line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>y)\n      && ((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<x\n        ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>x)\n      &&((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<y\n        ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>y)\n      &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>-Math.PI)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>x)\n      &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>-Math.PI)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>y)\n      &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>x)\n      &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>y)\n      &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>=0)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>x)\n      &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>=0)))\n      ||(!is_not_on_straight_line && Math.sqrt((line.x-x)**2+(line.y-y)**2)>line.points[4]*line.scaleX/2)\n\n      \n      )\n      {\n        return false; \n      } else{\n        return true;\n      }\n    },\n\n    //update a group with the id id_grp\n    updateGrp(e,id_grp){\n      const grep=this.groups.find((r)=>r.id===id_grp);\n      const line= grep.line;\n      grep.offsetX=line.offsetX;\n      grep.offsetY=line.offsetY;\n      \n      line.x=e.target.x();\n      line.y=e.target.y();\n      this.center.x=line.x;\n      this.center.y=line.y;\n      /*\n      if(line.keepDistribution){\n        this.updateOccupiedDistance(line.id);\n      }\n      */\n      this.updateAllPosInGrp(line.id); \n      this.checkIfShapesOnLine(line.id);\n    },\n\n\n    //update the position of all shapes that are on the line of the group with the id id_grp.\n    updateAllPosInGrp(id_grp){\n      const grp= this.groups.find((r) => r.id===id_grp);     \n      const line= grp.line;\n      const shapes_g = grp.shapes_g;\n      for (let i=0;i<shapes_g.length;i++){\n          if(line.keepDistribution){\n            shapes_g[i].x=line.x+line.occupiedDistances[i]*Math.cos(line.rotation*(Math.PI/180));\n            shapes_g[i].y=line.y+line.occupiedDistances[i]*Math.sin(line.rotation*(Math.PI/180));\n            shapes_g[i].distance_to_line_center=line.occupiedDistances[i];\n            shapes_g[i].rotation=shapes_g[i].personalRotation+line.rotation;\n            \n          } else{\n            shapes_g[i].x=line.x+line.occupiedDistances[i]*Math.cos(line.rotation*(Math.PI/180));\n            shapes_g[i].y=line.y+line.occupiedDistances[i]*Math.sin(line.rotation*(Math.PI/180));\n            shapes_g[i].distance_to_line_center=line.occupiedDistances[i];\n            shapes_g[i].rotation=shapes_g[i].personalRotation+line.rotation;\n          }\n          line.positionPoints[i].x=shapes_g[i].x;\n          line.positionPoints[i].y=shapes_g[i].y;\n          line.positionPoints[i].distance_to_line_center=shapes_g[i].distance_to_line_center;\n      }\n      let i=shapes_g.length;\n      while(i<line.positionPoints.length){\n        if(line.keepDistribution){\n          line.positionPoints.splice(i,1);\n        }else{\n        line.positionPoints[i].x=line.x+line.freeDistances[i-shapes_g.length]*Math.cos(line.rotation*(Math.PI/180));\n        line.positionPoints[i].y=line.y+line.freeDistances[i-shapes_g.length]*Math.sin(line.rotation*(Math.PI/180));\n        line.positionPoints[i].distance_to_line_center=line.freeDistances[i-shapes_g.length];\n        i++;\n        }\n        \n      }\n    \n    },\n    isOutsideTheLine(shape,line){\n      let coord_y1=line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x1=line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let coord_y2= line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x2=line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let a=(coord_y1-coord_y2)/(coord_x2-coord_x1);\n      let b=line.y-a*line.x;\n      let is_on_straight_line=false;\n      if(Math.abs(coord_x1-coord_x2)>=1){\n        is_on_straight_line=(Math.abs(a*shape.x+b-shape.y)<1);\n      }else{\n        is_on_straight_line=(Math.abs(shape.x-line.x)<1);\n      }\n      if(\n        !(is_on_straight_line)\n      ||((line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n        ||line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      && ((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>-Math.PI)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>-Math.PI)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>=0)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>=0)))\n      ){\n        return true;\n      }else{ return false}\n    },\n    \n    //update the canvas\n    update(){\n      const shapes = this.shapes\n      \n      //const lengthToCapture=10; //bigger is the number, bigger is the intervals of x and y where a shape can be added to a line.\n      let is_on_straight_line=false;\n      for (let i=0;i<shapes.length;i++){\n        let x=shapes[i].x;\n        let y=shapes[i].y;\n      for (let j=0;j<this.groups.length;j++){\n      \n        let line=this.groups[j].line;\n\n        \n        let coord_y1=line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n        let coord_x1=line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n        let coord_y2= line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n        let coord_x2=line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n        let a=(coord_y1-coord_y2)/(coord_x2-coord_x1);\n        let b=line.y-a*line.x;\n        if(Math.abs(coord_x1-coord_x2)>1){\n          is_on_straight_line=(Math.abs(a*x+b-y)<=this.lengthToCapture);\n        }else{\n          is_on_straight_line=(Math.abs(x-line.x)<=this.lengthToCapture);\n          //is_on_straight_line=true;\n        }\n        if(\n        (\n          is_on_straight_line\n      &&(line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToCapture>=y\n      && line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToCapture<=y)\n      &&(line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToCapture>=x\n      && line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToCapture<=x)\n      &&(line.rotation*(Math.PI/180)<=0 \n      && line.rotation*(Math.PI/180)>-Math.PI/2))\n\n      ||(\n        is_on_straight_line\n      &&(line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))+this.lengthToCapture>=y\n      && line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))-this.lengthToCapture<=y) \n      &&(line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))+this.lengthToCapture>=x\n      && line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))-this.lengthToCapture<=x)\n      &&(line.rotation*(Math.PI/180)<=-Math.PI/2 \n      && line.rotation*(Math.PI/180)>=-Math.PI))\n\n      ||(\n        is_on_straight_line\n      &&(line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))+this.lengthToCapture>=y\n      &&line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))-this.lengthToCapture<=y)\n      &&(line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))+this.lengthToCapture>=x\n      && line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))-this.lengthToCapture<=x)\n      &&(line.rotation*(Math.PI/180)<=Math.PI \n      && line.rotation*(Math.PI/180)>Math.PI/2))\n\n      ||(\n        is_on_straight_line\n      &&(line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToCapture>=y\n      && line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToCapture<=y)\n      &&(line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToCapture>=x\n      && line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToCapture<=x)\n      &&(line.rotation*(Math.PI/180)<=Math.PI/2\n      && line.rotation*(Math.PI/180)>=0))\n      )\n       {\n          shapes[i].isGrouped=1;\n          this.makeGroup(line.id);\n        }\n      }\n      }\n    },\n\n    CheckIfNeedToDetach(e){\n      let grp=this.groups.find((r)=>r.id===e.target.getParent().attrs.id);\n      let shape= grp.shapes_g.find((r)=>r.id==e.target.id());\n      let dist=Math.sqrt((e.target.getStage().getPointerPosition().y-e.target.y())**2+(e.target.getStage().getPointerPosition().x-e.target.x())**2);\n      if(e.target.className==\"Rect\"){\n        dist-=e.target.attrs.height*e.target.attrs.scaleY;\n      } else if(e.target.className==\"Circle\"){\n        dist-=(2*e.target.attrs.radius)*e.target.attrs.scaleY;\n      } else if(e.target.className==\"Text\"){\n        dist-=e.target.attrs.length_y*e.target.attrs.scaleY;\n      } else if(e.target.className==\"Image\"){\n        dist-=e.target.height()*e.target.scaleY();\n      } else if(e.target.attrs.className==\"Triangle\"){\n        dist-=e.target.height()*e.target.scaleY();\n      } \n      \n      if (dist>50){\n        //let shape= this.groups.find((r)=>r.id===e.target.getParent().attrs.id).shapes_g.find((r)=>r.id==e.target.id());\n        //this.groups.find((r)=>r.id===e.target.getParent().attrs.id).shapes_g.find((r)=>r.id==e.target.id()).needToBeDetach=1;\n        /*\n        shape.dragBoundFunc= function (pos) {\n              return {\n                x: pos.x,\n                y: pos.y,\n              };\n        }\n        */\n        //shape.x=e.target.getStage().getPointerPosition().x;\n        //shape.y=e.target.getStage().getPointerPosition().y;\n        //if (Math.abs(e.target.getStage().getPointerPosition().y-e.target.y())>220){\n\n        //shape.x=e.target.getStage().getPointerPosition().x;\n        //shape.y=e.target.getStage().getPointerPosition().y;\n        this.groups.find((r)=>r.id===e.target.getParent().attrs.id).aShapeHasBeenDetach=1;\n        this.DetachShape(shape,e.target.getStage().getPointerPosition().x,e.target.getStage().getPointerPosition().y);\n        //}\n        \n        \n        \n      }\n    },\n\n    //Give the sign of the distance of shape from the center of a line.\n    GiveSignOfDistance(shape,line){\n      let result;\n      let angle=line.rotation*(Math.PI/180);\n      let distX=shape.x-line.x;\n      let distY=shape.y-line.y;\n      /*\n      \n      if(angle<=-Math.PI/4 || angle>=-Math.PI/2){\n        result=-Math.sign(distY);\n      }\n      else if(angle<=-Math.PI/2 || angle>=-3*Math.PI/4){\n        result=Math.sign(distY);\n      }\n      else if(angle<=-3*Math.PI/4 || angle>=-Math.PI){\n        result=-Math.sign(distX);\n      }else if(angle>=3*Math.PI/4 || angle<=Math.PI){\n        result=Math.sign(distX);\n      }else if(angle>=Math.PI/2 || angle<3*Math.PI/4){\n        result=-Math.sign(distY);\n      } else if(angle<=Math.PI/2 || angle>Math.PI/4){\n        result=-Math.sign(distY);\n      } else if(angle<=Math.PI/4 || angle>=0){\n        result=Math.sign(distX);\n      }\n      */\n      \n      \n      if(Math.abs(distX)<=this.lengthToCapture && line.rotation==-90){\n        \n        result=-Math.sign(distY);\n      } else if (Math.abs(distX)<=this.lengthToCapture && line.rotation==90){\n        result=Math.sign(distY);\n      }\n      else{\n        result=Math.sign(distX);\n      }\n      if(angle<-Math.PI/2 || angle>Math.PI/2){\n        result=-result;\n      }\n      \n      return result;\n    },\n\n    //Different from the previous function bcs the straight line of the center is perdendicular to the line\n    GiveSignOfDistanceBtwCenterAndShape(center,shape){\n      let result;\n      let angle=shape.rotation*(Math.PI/180);\n      let distX=center.x-shape.x;\n      let distY=center.y-shape.y;\n      /*\n      \n      if(angle<=-Math.PI/4 || angle>=-Math.PI/2){\n        result=-Math.sign(distY);\n      }\n      else if(angle<=-Math.PI/2 || angle>=-3*Math.PI/4){\n        result=Math.sign(distY);\n      }\n      else if(angle<=-3*Math.PI/4 || angle>=-Math.PI){\n        result=-Math.sign(distX);\n      }else if(angle>=3*Math.PI/4 || angle<=Math.PI){\n        result=Math.sign(distX);\n      }else if(angle>=Math.PI/2 || angle<3*Math.PI/4){\n        result=-Math.sign(distY);\n      } else if(angle<=Math.PI/2 || angle>Math.PI/4){\n        result=-Math.sign(distY);\n      } else if(angle<=Math.PI/4 || angle>=0){\n        result=Math.sign(distX);\n      }\n      */\n      \n      \n      if(Math.abs(distY)<=this.lengthToCapture && shape.rotation==-90){\n        \n        result=Math.sign(distX);\n      } else if (Math.abs(distY)<=this.lengthToCapture && shape.rotation==90){\n        result=-Math.sign(distX);\n      }\n      else{\n        result=Math.sign(distY);\n      }\n      if(angle<-Math.PI/2 || angle>Math.PI/2){\n        result=-result;\n      }\n      \n      return result;\n    },\n\n    /*add shapes with isGrouped==1 to the group with the id id_grp.\n    */\n    makeGroup(id_grp){\n      this.eraseNodefromTransformer(\"shapeTransformer\");\n      this.eraseNodefromTransformer(\"lineTransformer\");\n      const grp=this.groups.find((r)=> r.id===id_grp);\n      const line=grp.line;\n      const shapes = this.shapes;\n      line.freeDistances.sort(this.isSmaller); //we will give the shortest available distance to the added shape\n      shapes.sort(this.isBeforeRegardingX);\n      for (let i=0;i<shapes.length;i++){\n        if(shapes[i].isGrouped==1){\n          const positionPoint=Object.assign({},this.positionPoint);\n          let distX=shapes[i].x-line.x;\n          let distY=shapes[i].y-line.y; \n          shapes[i].personalRotation=0;\n          //let pot_dist=this.GiveSignOfDistance(shapes[i],line)*Math.sqrt((distX)**2+(distY)**2);\n          /*\n          if(line.keepDistribution && line.freeDistances.length>0){\n          let distances=line.freeDistances+line.occupiedDistances;\n          console.log(distances);\n           let freeDistance=this.isNearest(line.freeDistances,pot_dist);\n           //shapes[i].distance_to_line_center=freeDistance.res; \n           shapes[i].distance_to_line_center=this.GiveSignOfDistance(shapes[i],line)*Math.sqrt((distX)**2+(distY)**2);\n            \n           line.occupiedDistances.push(shapes[i].distance_to_line_center,);\n           line.freeDistances.splice(freeDistance.indice,1);\n\n          } else{\n            */\n            //let distX=shapes[i].x-line.x;\n            //let distY=shapes[i].y-line.y;\n            shapes[i].distance_to_line_center=this.GiveSignOfDistance(shapes[i],line)*Math.sqrt((distX)**2+(distY)**2);\n            /*If the distance is a little bit to far from the center \n            we adjust it so that the shape can be at one of the border of the stickyline*/\n            if(Math.abs(shapes[i].distance_to_line_center)>=line.points[4]*line.scaleX/2){\n              shapes[i].distance_to_line_center=Math.sign(shapes[i].distance_to_line_center)*line.points[4]*line.scaleX/2\n            }\n            this.ChangeCenterRegardingCommand(shapes[i].id,grp.line.defaultAlignment);\n            \n              //shapes[i].isGrouped=0;\n              this.updateDragFunc(shapes[i],line);\n              grp.shapes_g.push(shapes[i],);\n              grp.line.occupiedDistances.push(shapes[i].distance_to_line_center,);\n              positionPoint.id=\"positionPoint\"+grp.id+grp.line.positionPoints.length;\n              grp.line.positionPoints.push(positionPoint,);\n              //shapes[i].distance_to_line_center=this.GiveSignOfDistance(shapes[i],line)*Math.sqrt((distX)**2+(distY)**2);\n            \n            //line.occupiedDistances.push(shapes[i].distance_to_line_center,);\n          //}\n          console.log(\"A new shape has been added with a distance\"+shapes[i].distance_to_line_center);\n          \n          //shapes[i].isGrouped=0;\n          //this.updateDragFunc(shapes[i],line);\n          //grp.shapes_g.push(shapes[i],);\n          this.updateOccupiedDistance(line.id);\n          \n          this.updateAllPosInGrp(id_grp);\n          this.updateNaration(grp);\n          shapes.splice(i,1);\n        }\n      }\n      this.center.x=line.x;\n      this.center.y=line.y;\n    },\n\n    updateOccupiedDistance(id_grp){\n      \n      const grp=this.groups.find((r)=> r.id===id_grp);\n      //this.updateAllPosInGrp(id_grp);\n      this.sortByDistToLineCenter(grp);\n      \n      //let l=grp.line.points[4]/2;\n      if(grp.line.keepDistribution){\n      let L=grp.line.points[4];\n      let nb_shapes=grp.shapes_g.length;\n      let d=(L/(nb_shapes-1))*grp.line.scaleX;\n      if(nb_shapes%2==0){\n        \n      for (let i =1;i<=nb_shapes/2-1;i++){\n        //grp.line.occupiedDistances[i-1]=-(l/i);\n        grp.line.occupiedDistances[i-1]=-((nb_shapes/2-1)-i+1)*d-d/2\n      }\n      for (let i =1;i<=nb_shapes/2-1;i++){\n        grp.line.occupiedDistances[nb_shapes/2+i]=i*d+d/2;\n      }\n      grp.line.occupiedDistances[nb_shapes/2-1]=-d/2\n      grp.line.occupiedDistances[nb_shapes/2]=d/2\n      } else{\n        for (let i =1;i<=(nb_shapes-1)/2;i++){\n          grp.line.occupiedDistances[i-1]=-d*(((nb_shapes-1)/2)-i+1);\n        }\n        for (let i =1;i<=(nb_shapes-1)/2;i++){\n          grp.line.occupiedDistances[((nb_shapes-1)/2)+i]=d*i;\n        }\n        grp.line.occupiedDistances[(nb_shapes-1)/2]=0;\n      }\n      \n      for (let i=0;i<grp.shapes_g.length;i++){\n        grp.shapes_g[i].distance_to_line_center=grp.line.occupiedDistances[i];\n      }\n      }\n      else{\n        grp.line.occupiedDistances.sort(this.isSmaller);\n      }\n      \n      \n      \n    \n\n    },\n\n   isSmaller(a,b){\n    if(a<b){\n      return -1;\n    }else{\n      return 1\n    }\n   },\n\n   isBeforeRegardingX(a,b){\n    if(a.x<b.x){\n      return -1;\n    }else{\n      return 1;\n    }\n   },\n\n    \n   updateOccDist(grp,shape){\n    let res=this.isNearest(grp.line,shape);\n    //let grp=this.groups.find((r)=>r.id===line.id);\n    if(res.isFree){\n      shape.distance_to_line_center=grp.line.freeDistances[res.indice];\n      grp.line.freeDistances.splice(res.indice,1);\n      this.sortByDistToLineCenter(grp);\n      for(let l=0;l<grp.shapes_g.length;l++){\n        if(grp.line.occupiedDistances.length==l){\n          grp.line.occupiedDistances.push(grp.shapes_g[l].distance_to_line_center,);\n        }else{\n          grp.line.occupiedDistances[l]=grp.shapes_g[l].distance_to_line_center;\n        }\n      } \n    } else{\n      grp.shapes_g.find((r)=>r.id==shape.id).distance_to_line_center=grp.line.occupiedDistances[res.indice];\n      grp.line.occupiedDistances.splice(res.indice,1);\n      //line.occupiedDistances.push(shape.distance_to_line_center,);\n      //line.freeDistances.splice(res.indice,1);   \n      this.updateOccDist(grp,grp.shapes_g[res.indice]);\n    }\n   },\n   isNearest(line,shape){\n    let ecart;\n    let invx=line.x+line.freeDistances[0]*Math.cos(line.rotation*(Math.PI/180));\n    let invy=line.y+line.freeDistances[0]*Math.sin(line.rotation*(Math.PI/180));\n    let ecart_min=Math.sqrt((invx-shape.x)**2+(invy-shape.y)**2);\n    let indice=0;\n    for(let i=1;i<line.freeDistances.length;i++){\n      invx=line.x+line.freeDistances[i]*Math.cos(line.rotation*(Math.PI/180));\n      invy=line.y+line.freeDistances[i]*Math.sin(line.rotation*(Math.PI/180));\n      ecart=Math.sqrt((invx-shape.x)**2+(invy-shape.y)**2);\n      if(ecart<ecart_min){\n        //res=line.freeDistances[i];\n        ecart_min=ecart;\n        indice=i;\n      }\n    }\n    return indice;\n    /*\n    let allDist=line.freeDistances.concat(line.occupiedDistances);\n    console.log(allDist);\n    \n    let ecart;\n    let invx=line.x+allDist[0]*Math.cos(line.rotation*(Math.PI/180));\n    let invy=line.y+allDist[0]*Math.sin(line.rotation*(Math.PI/180));\n    let ecart_min=Math.sqrt((invx-shape.x)**2+(invy-shape.y)**2)\n    let indice=0;\n    console.log(ecart_min);\n    for(let i=1;i<allDist.length;i++){\n      invx=line.x+allDist[i]*Math.cos(line.rotation*(Math.PI/180));\n      invy=line.y+allDist[i]*Math.sin(line.rotation*(Math.PI/180));\n      ecart=Math.sqrt((invx-shape.x)**2+(invy-shape.y)**2);\n      if(this.groups.find((r)=>r.id==line.id).shapes_g.indexOf(shape)!=-1){\n        console.log(ecart_min);\n        console.log(ecart);\n        if(ecart<ecart_min && ecart!=0){\n          //res=allDist[i];\n          ecart_min=ecart;\n          indice=i;\n        }\n      }else if(ecart<ecart_min){\n        //res=allDist[i];\n        ecart_min=ecart;\n        indice=i;\n      }\n    }\n    console.log(indice);\n    if(indice>=line.freeDistances.length){\n      return{\n        isFree: false,\n        indice: indice-line.freeDistances.length,\n      }\n    }else{\n      return{\n        isFree: true,\n        indice: indice,\n      }\n    }\n    */\n\n    /*\n    line.freeDistances.sort(this.isSmaller);\n    let ecart;\n    let invx=line.x+line.freeDistances[0]*Math.cos(line.rotation*(Math.PI/180));\n    let invy=line.y+line.freeDistances[0]*Math.sin(line.rotation*(Math.PI/180));\n    let ecart_min=Math.sqrt((invx-shape.x)**2+(invy-shape.y)**2)\n    let indice=0;\n    for(let i=0;i<line.freeDistances.length;i++){\n      invx=line.x+line.freeDistances[i]*Math.cos(line.rotation*(Math.PI/180));\n      invy=line.y+line.freeDistances[i]*Math.sin(line.rotation*(Math.PI/180));\n      ecart=Math.sqrt((invx-shape.x)**2+(invy-shape.y)**2)\n      if(ecart<ecart_min){\n        //res=freeDistances[i];\n        ecart_min=ecart;\n        indice=i;\n      }\n    }\n    return indice;\n    */\n    /*\n    if(shapeDistance>=0){\n      for(let i=0;i<freeDistances.length;i++){\n        if(freeDistances[i]>shapeDistance){\n          return i;\n        }\n      }\n      return freeDistances.length-1;\n    }else{\n      let ecart_min=Math.abs(Math.abs(freeDistances[0])-Math.abs(shapeDistance))\n      let indice=0;\n      for(let i=0;i<freeDistances.length;i++){\n        let ecart=Math.abs(Math.abs(freeDistances[i])-Math.abs(shapeDistance));\n        if(ecart<ecart_min){\n          //res=freeDistances[i];\n          ecart_min=ecart;\n          indice=i;\n        }\n      }\n      return indice;\n    }\n    */\n    /*\n    //let res=freeDistances[0];\n    let ecart_min=Math.abs(Math.abs(freeDistances[0])-Math.abs(shapeDistance))\n    let indice=0;\n    for(let i=0;i<freeDistances.length;i++){\n      let ecart=Math.abs(Math.abs(freeDistances[i])-Math.abs(shapeDistance));\n      if(ecart<ecart_min){\n        //res=freeDistances[i];\n        ecart_min=ecart;\n        indice=i;\n      }\n    }\n    return indice;\n    */\n   },\n   \n\n   sortByDistToLineCenter(grp){\n    //this.updateAllPosInGrp(grp.id)\n    //let last_distX=new Array(grp.shapes_g.length);\n    \n    //let distX;\n    //let distY;\n    //let sign;\n    //let dist=new Array(grp.shapes_g.length);\n    //let angle;\n    if(grp.line.keepDistribution){\n      for (let l=0;l<grp.shapes_g.length;l++){\n          let distX=grp.shapes_g[l].x-grp.line.x;\n          let distY=grp.shapes_g[l].y-grp.line.y;\n          //dist[l]=this.GiveSignOfDistance(grp.shapes_g[l],grp.line)*Math.sqrt((distX)**2+(distY)**2);\n          grp.shapes_g[l].distance_to_line_center=this.GiveSignOfDistance(grp.shapes_g[l],grp.line)*Math.sqrt((distX)**2+(distY)**2);\n          //last_distX[l]=distX;\n        }\n    }\n    for(let i=1;i<grp.shapes_g.length;i++){\n      \n     \n      let shape=grp.shapes_g[i];\n      //let distance=dist[i];\n      let j=i\n      while(j>0 && grp.shapes_g[j-1].distance_to_line_center>shape.distance_to_line_center){\n        grp.shapes_g[j]=grp.shapes_g[j-1];\n        //dist[j]=dist[j-1]\n        j=j-1;\n      }\n      grp.shapes_g[j]=shape;\n      //dist[j]=distance;\n    }\n   },\n   \n\n   sortAnyShapesByDistToLineCenter(shapes,line){\n    //this.updateAllPosInGrp(grp.id)\n    //let last_distX=new Array(grp.shapes_g.length);\n    \n    //let distX;\n    //let distY;\n    //let sign;\n    //let dist=new Array(grp.shapes_g.length);\n    //let angle;\n    for (let l=0;l<shapes.length;l++){\n        let distX=shapes[l].x-line.x;\n        let distY=shapes[l].y-line.y;\n        /*\n        angle=grp.shapes_g[l].rotation*(Math.PI/180);\n\n      \n      if(angle<=-Math.PI/4 || angle>=-Math.PI/2){\n        sign=-Math.sign(distY);\n      }\n      else if(angle<=-Math.PI/2 || angle>=-3*Math.PI/4){\n        sign=Math.sign(distY);\n      }\n      else if(angle<=-3*Math.PI/4 || angle>=-Math.PI){\n        sign=-Math.sign(distX);\n      }else if(angle>=3*Math.PI/4 || angle<=Math.PI){\n        sign=Math.sign(distX);\n      }else if(angle>=Math.PI/2 || angle<3*Math.PI/4){\n        sign=-Math.sign(distY);\n      } else if(angle<=Math.PI/2 || angle>Math.PI/4){\n        sign=-Math.sign(distY);\n      } else if(angle<=Math.PI/4 || angle>=0){\n        sign=Math.sign(distX);\n      }\n       console.log(sign);\n        */\n       \n        /*\n        if(Math.sin(grp.line.rotation*(Math.PI/180))==0){\n            grp.shapes_g[l].distance_to_line_center=grp.shapes_g[l].x-grp.line.x;\n        }else{\n            grp.shapes_g[l].distance_to_line_center=Math.sign(distX)*Math.sqrt((distX)**2+(distY)**2);\n          \n            if(grp.line.rotation*(Math.PI/180)<=-Math.PI/2 || grp.line.rotation*(Math.PI/180)<=Math.PI/2 &&grp.line.rotation*(Math.PI/180)>=0){\n              grp.shapes_g[l].distance_to_line_center=-grp.shapes_g[l].distance_to_line_center\n            }\n        }\n        */\n        //dist[l]=this.GiveSignOfDistance(grp.shapes_g[l],grp.line)*Math.sqrt((distX)**2+(distY)**2);\n        shapes.distance_to_line_center=this.GiveSignOfDistance(shapes,line)*Math.sqrt((distX)**2+(distY)**2);\n        /*\n        if((grp.line.rotation*(Math.PI/180)<=-Math.PI/2 || (grp.line.rotation*(Math.PI/180)<=Math.PI/2 && grp.line.rotation*(Math.PI/180)>=0)) && (Math.sign(last_distX[l])!=Math.sign(distX))){\n          grp.shapes_g[l].distance_to_line_center=-grp.shapes_g[l].distance_to_line_center\n        }\n        */\n        //last_distX[l]=distX;\n      }\n    for(let i=1;i<shapes.length;i++){\n      \n     \n      let shape=shapes[i];\n      //let distance=dist[i];\n      let j=i\n      while(j>0 && shapes[j-1].distance_to_line_center>shape.distance_to_line_center){\n        shapes[j]=shapes[j-1];\n        //dist[j]=dist[j-1]\n        j=j-1;\n      }\n      shapes[j]=shape;\n      //dist[j]=distance;\n    }\n   },\n\n  \n\n   /*\n   update the drag function of a shape which is on a line. \n   */\n   updateDragFunc(shape,line){\n          let angle=line.rotation*(Math.PI/180);\n          if (angle<=0 && angle>=-Math.PI/4){\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x +(pos.x-line.x)*Math.cos(angle),\n                y: line.y+(pos.x-line.x)*Math.sin(angle),\n              };\n            }\n          } else if (angle<-Math.PI/4 && angle>=-Math.PI/2){\n            // We prefer, in this case, moving the shape of the line regarding the y of the mouse position instead of the x.\n            // So that the user can move the shape more intuitively\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x-(pos.y-line.y)*Math.cos(angle),\n                y: line.y-(pos.y-line.y)*Math.sin(angle),\n              };\n            }\n          }\n          else if (angle<-Math.PI/2 && angle>=-3*Math.PI/4){\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x-(pos.y-line.y)*Math.cos(angle),\n                y: line.y-(pos.y-line.y)*Math.sin(angle),\n              };\n            }\n          } else if (angle<-3*Math.PI/4 && angle>=-Math.PI){\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x-(pos.x-line.x)*Math.cos(angle),\n                y: line.y-(pos.x-line.x)*Math.sin(angle),\n              };\n            }\n          }else if (angle<=Math.PI && angle>=3*Math.PI/4){\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x-(pos.x-line.x)*Math.cos(angle),\n                y: line.y-(pos.x-line.x)*Math.sin(angle),\n              };\n            }\n          } else if (angle<3*Math.PI/4 && angle>=Math.PI/2){\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x+(pos.y-line.y)*Math.cos(angle),\n                y: line.y+(pos.y-line.y)*Math.sin(angle),\n              };\n            }\n          } else if (angle<Math.PI/2 && angle>=Math.PI/4){\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x+(pos.y-line.y)*Math.cos(angle),\n                y: line.y+(pos.y-line.y)*Math.sin(angle),\n              };\n            }\n          }else if (angle<Math.PI/4 && angle>=0){\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x+(pos.x-line.x)*Math.cos(angle),\n                y: line.y+(pos.x-line.x)*Math.sin(angle),\n              };\n            }\n          }\n   },\n\n   /*\n   Update the position of a free shape when it is dragging.\n   */\n    updatePos(e){\n      const shape = this.shapes.find(i => i.id === e.target.id());\n      shape.x=e.target.x();\n      shape.y=e.target.y();\n      this.center.x=e.target.x();\n      this.center.y=e.target.y();\n\n      let pos = { x: shape.x, y: shape.y };\n      e.target.position(pos);\n      e.target.getLayer().batchDraw();\n      \n    },\n\n    /*\n    Update the positio  of shape attached to a line (from the group with id=id_grp) when it is dragging.\n     */\n    updatePosInGrp(e,id_grp){\n      let distX;\n      let distY;\n      let distance_to_line_center;\n      const grp=this.groups.find((r)=> r.id===id_grp);\n      \n      if(grp.aShapeHasBeenDetach==1){\n        grp.aShapeHasBeenDetach=0;\n        return;\n      }\n      const line=grp.line;\n      const shape = grp.shapes_g.find(i => i.id === e.target.id());\n      const shapes_g = grp.shapes_g; \n      //const lengthToDetach=10;\n      if(shape.needToBeDetach==1){\n        shape.needToBeDetach=0;\n        this.DetachShape(shape);\n        this.updateAllPosInGrp(e.target.getParent().attrs.id);\n      }\n      if(line.keepDistribution){\n        if(this.isCoordinateOnLine(e.target.x(),e.target.y(),line.id)){\n          distX=shape.x-e.target.x();\n          distY=shape.y -e.target.y();\n          let L=grp.line.points[4];\n          let nb_shapes=grp.shapes_g.length;\n          let d=(L/(nb_shapes-1))*grp.line.scaleX;\n          let dist=Math.sqrt(distX**2 +distY**2);\n          if(dist>=d){\n            shape.x=e.target.x();\n            shape.y=e.target.y();\n            this.updateOccupiedDistance(line.id)\n            shape.x=line.x+line.occupiedDistances[shapes_g.indexOf(shape)]*Math.cos(line.rotation*(Math.PI/180));\n            shape.y=line.y+line.occupiedDistances[shapes_g.indexOf(shape)]*Math.sin(line.rotation*(Math.PI/180));\n            shape.distance_to_line_center=line.occupiedDistances[shapes_g.indexOf(shape)];\n            shape.rotation=line.rotation;\n            this.updateAllPosInGrp(line.id);\n          }else{\n            shape.x=line.x+line.occupiedDistances[shapes_g.indexOf(shape)]*Math.cos(line.rotation*(Math.PI/180));\n            shape.y=line.y+line.occupiedDistances[shapes_g.indexOf(shape)]*Math.sin(line.rotation*(Math.PI/180));\n            shape.distance_to_line_center=line.occupiedDistances[shapes_g.indexOf(shape)];\n            shape.rotation=line.rotation; \n          }   \n        }else{\n          shape.x=e.target.x();\n          shape.y=e.target.y();\n        }\n        line.positionPoints[grp.shapes_g.indexOf(shape)].x=shape.x;\n        line.positionPoints[grp.shapes_g.indexOf(shape)].y=shape.y;\n        line.positionPoints[grp.shapes_g.indexOf(shape)].distance_to_line_center=shape.distance_to_line_center; \n      } else{\n        \n          line.positionPoints[grp.shapes_g.indexOf(shape)].x=shape.x;\n          line.positionPoints[grp.shapes_g.indexOf(shape)].y=shape.y;\n          shape.x=e.target.x();\n          shape.y=e.target.y();\n          \n          if(Math.sin(line.rotation*(Math.PI/180))==0){\n            distance_to_line_center=shape.x-line.x;\n          }else{\n            if(Math.sign(shape.x-line.x)!=0){\n              distance_to_line_center=Math.sign(-shape.rotation)*Math.sign(shape.x-line.x)*Math.sqrt((shape.x-line.x)**2+(shape.y-line.y)**2);\n            } else{\n             distance_to_line_center=Math.sign(-shape.rotation)*Math.sign(shape.y-line.y)*Math.sqrt((shape.x-line.x)**2+(shape.y-line.y)**2); \n            }\n          \n            if(shape.rotation*(Math.PI/180)<=-Math.PI/2 || (shape.rotation*(Math.PI/180)<=Math.PI/2 && shape.rotation*(Math.PI/180)>=0)){\n              distance_to_line_center=-distance_to_line_center\n            }\n          }\n          //shape.distance_to_line_center=distance_to_line_center;\n          //grp.line.occupiedDistances[shapes_g.indexOf(shape)]=shape.distance_to_line_center;\n        line.positionPoints[grp.shapes_g.indexOf(shape)].distance_to_line_center=shape.distance_to_line_center;\n          \n      }\n      let pos = { x: shape.x, y: shape.y };\n      this.center.x=shape.x;\n      this.center.y=shape.y;\n      e.target.position(pos);\n      e.target.getLayer().batchDraw();\n      if(!this.isCoordinateOnLine(shape.x,shape.y,line.id)){\n        shape.dragBoundFunc= dragFunc;\n        shape.isGrouped=0;\n        this.shapes.push(shape,)\n        for (let i=0;i<shapes_g.length;i++){\n          if(shapes_g[i].id==shape.id){\n            line.freeDistances.push(line.occupiedDistances[i]);\n            line.occupiedDistances.splice(i,1);\n            line.positionPoints.splice(i,1);\n            shapes_g.splice(i,1);\n            \n            console.log(\"a shape has been removed from the line\");\n          }\n        } \n      }else{\n        if(!line.keepDistribution){\n          grp.line.occupiedDistances[shapes_g.indexOf(shape)]=distance_to_line_center;\n        }else{\n        grp.line.occupiedDistances[shapes_g.indexOf(shape)]=shape.distance_to_line_center;\n        }\n        \n      line.positionPoints[grp.shapes_g.indexOf(shape)].x=shape.x;\n      line.positionPoints[grp.shapes_g.indexOf(shape)].y=shape.y;\n      line.positionPoints[grp.shapes_g.indexOf(shape)].distance_to_line_center=shape.distance_to_line_center;\n       \n      }\n      /*\n      let coord_y1=line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x1=line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let coord_y2= line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x2=line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let a=(coord_y1-coord_y2)/(coord_x2-coord_x1);\n      let b=line.y-a*line.x;\n      let is_on_straight_line=false;\n      if(Math.abs(coord_x1-coord_x2)>=1){\n        is_on_straight_line=(Math.abs(a*shape.x+b-shape.y)<1);\n      }else{\n        is_on_straight_line=(Math.abs(shape.x-line.x)<1);\n      }\n      if(\n        !(is_on_straight_line)\n      ||((line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n        ||line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      && ((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>-Math.PI)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>-Math.PI)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>=0)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>=0)))\n      )\n      {\n        shape.dragBoundFunc= dragFunc;\n        this.shapes.push(shape,)\n        for (let i=0;i<shapes_g.length;i++){\n          if(shapes_g[i].id==shape.id){\n            line.freeDistances.push(line.occupiedDistances[i]);\n            line.occupiedDistances.splice(i,1);\n            shapes_g.splice(i,1);\n            console.log(\"a shape has been removed from the line\");\n          }\n        } \n      }else{\n        if(!line.keepDistribution){\n          grp.line.occupiedDistances[shapes_g.indexOf(shape)]=distance_to_line_center;\n        }else{\n        grp.line.occupiedDistances[shapes_g.indexOf(shape)]=shape.distance_to_line_center;\n        }\n      }\n      */\n      //this.updateOccupiedDistance(line.id);\n      \n          if(line.keepDistribution){\n            this.updateOccupiedDistance(line.id);\n          }\n          \n          this.updateAllPosInGrp(line.id);\n    },\n    /*\n    Function called when the transformation of a shape with a transfomer is finished.\n    */\n    updateTransformedShape(e) {\n      /*\n      let shape = this.shapes.find(\n        (r) => r.id === this.selectedShapeId\n      );\n      */\n      let res;\n      let shape;\n      if(e.target.className==\"Line\"){\n        shape=this.groups.find(\n        (r) => r.id === this.selectedShapeId\n      ).line;\n      }else{\n        res=this.findShape(this.selectedShapeId)\n        shape=res.shape_data;\n        if(shape== undefined){\n          return;\n        }\n      }\n\n      \n      let last_shapex= shape.x;\n      let last_shapey= shape.y;\n      //let last_shaperotation= shape.rotation;\n\n      //update data of the transformed object.\n      shape.x = e.target.x();\n      shape.y = e.target.y();\n      shape.rotation = e.target.rotation();\n      let last_scaleX= shape.scaleX;\n      shape.scaleX = e.target.scaleX();\n      shape.scaleY = e.target.scaleY();\n\n      if(e.target.className==\"Line\"){\n        const grp=this.groups.find((r)=> r.id===shape.id);\n        if(shape.keepDistribution){\n          for (let i=0;i<shape.occupiedDistances.length;i++){\n            shape.occupiedDistances[i]=(shape.occupiedDistances[i]/last_scaleX)*shape.scaleX;\n          }\n          /*\n          for (let i=0;i<shape.freeDistances.length;i++){\n            shape.freeDistances[i]=(shape.freeDistances[i]/last_scaleX)*shape.scaleX;\n          }\n          */\n          \n          //this.updateOccupiedDistance(shape.id)\n          this.update();\n          this.updateGrp(e, this.selectedShapeId);\n          this.checkIfShapesOnLine(this.selectedShapeId);        \n        }else{\n          \n          \n          \n         if(last_scaleX!=shape.scaleX){\n          for(let i=0;i<grp.shapes_g.length;i++){\n          \n          //If the width of the line has been changed, we update the distance from the shape to the center of the line\n            \n              let distX=grp.shapes_g[i].x-shape.x;\n              let distY=grp.shapes_g[i].y-shape.y;\n              \n             if(Math.sign(grp.line.occupiedDistances[i])==0){\n                //if(grp.line.rotation!=-90 && grp.line.rotation!=90){\n                  //grp.line.occupiedDistances[i]=-this.GiveSignOfDistance(grp.shapes_g[i],shape)*Math.sqrt((distX)**2 +(distY)**2);\n                //}else{\n                  grp.line.occupiedDistances[i]=this.GiveSignOfDistance(grp.shapes_g[i],shape)*Math.sqrt((distX)**2 +(distY)**2);\n                  \n                //}\n              \n              }else{\n                grp.line.occupiedDistances[i]=Math.sign(grp.line.occupiedDistances[i])*Math.sqrt((distX)**2 +(distY)**2);\n              }\n\n              \n              if(Math.sign((grp.shapes_g[i].x-last_shapex))!=Math.sign(distX) && Math.sign((grp.shapes_g[i].x-last_shapex))!=0 && grp.line.rotation!=90 && grp.line.rotation!=-90){\n                \n                grp.line.occupiedDistances[i]=-grp.line.occupiedDistances[i];\n              }\n              if(Math.sign((grp.shapes_g[i].y-last_shapey))!=Math.sign(distY) && Math.sign((grp.shapes_g[i].y-last_shapey))!=0 && (grp.line.rotation==90 || grp.line.rotation==-90)){\n                grp.line.occupiedDistances[i]=-grp.line.occupiedDistances[i];\n              }\n              //this.checkIfShapesOnLine(this.selectedShapeId);  \n            \n            //this.checkIfShapesOnLine(this.selectedShapeId);\n            //grp.line.occupiedDistances[i]=grp.shapes_g[i].distance_to_line_center;\n            \n          }\n          for (let i=0;i<shape.freeDistances.length;i++){\n            let distX=last_shapex-shape.x;\n            let distY=last_shapey-shape.y; \n            let dist=Math.sqrt(distX**2+distY**2);\n            if(shape.rotation<-90 ||shape.rotation>90){\n              shape.freeDistances[i]=shape.freeDistances[i]-Math.sign(last_shapex-shape.x)*dist;\n            } else if(shape.rotation==90 || shape.rotation==-90){\n              shape.freeDistances[i]=shape.freeDistances[i]-distY\n            } else{\n              shape.freeDistances[i]=shape.freeDistances[i]+Math.sign(last_shapex-shape.x)*dist;\n            \n            }\n          }\n         }\n          this.update();\n          this.updateGrp(e, this.selectedShapeId);\n          this.checkIfShapesOnLine(this.selectedShapeId);\n\n          // We now see if freeDistances need to be delete(so if they are bigger than the half of the stickyline);\n          \n        }\n        for(let i=0;i<grp.shapes_g.length;i++){\n            \n          this.updateDragFunc(grp.shapes_g[i],shape);\n\n        }\n      }else if(res.grp_id!='-1'){\n        this.updateAllPosInGrp(res.grp_id);\n        this.updateOccupiedDistance(res.grp_id);\n        e.target.x(e.target.getParent().attrs.shapes_g.find((r)=>r.id===e.target.id()).x);\n        e.target.y(e.target.getParent().attrs.shapes_g.find((r)=>r.id===e.target.id()).y);\n        this.groups.find((r)=>r.id===res.grp_id).shapes_g.find((r)=>r.id===e.target.id()).personalRotation=e.target.rotation()-e.target.getParent().attrs.line.rotation;\n        \n        \n        this.updateAllPosInGrp(res.grp_id);\n        this.checkIfShapesOnLine(res.grp_id);\n        this.updateDragFuncOfCenter();\n      \n      }\n      else{\n        this.update();\n        \n        this.updateDragFuncOfCenter();\n      }\n      this.center.x=e.target.attrs.x;\n      this.center.y=e.target.attrs.y;\n      this.updateNaration(this.groups.find(\n        (r) => r.id === this.selectedShapeId\n      ));\n    },\n    \n    handleTransformation(e) {\n      document.getElementById(\"input\").style.display=\"none\"; //if the input for modifying the text is here\n      if (e.evt==undefined) {\n        return;\n      }\n      if(this.eraseMode==1){\n        this.eraserAction(e);\n        return;\n      }\n      \n      //If we click on the stage, we have to remove the transformer from the node where it was.\n      if (e.target === e.target.getStage()) {\n        this.selectedShapeId = 'NoId';\n        this.eraseNodefromTransformer(\"lineTransformer\");\n        this.eraseNodefromTransformer(\"shapeTransformer\");\n        this.center.opacity=0;\n        return;\n      }\n\n      //If we click on a transformer, nothing happen\n      const clickedOnTransformer = e.target.getParent().className === 'Transformer';\n      if (clickedOnTransformer) {\n        return;\n      }\n      \n      const id = e.target.id();\n      let transformer_id;\n      let shape=this.findShape(id).shape_data;\n      /*\n      let isFunded=true;\n      if(shape==undefined){\n        isFunded=false;\n      }\n      let i=0;\n      while(!isFunded){\n        if(i<this.groups.length){\n          shape=this.groups[i].shapes_g.find(i => i.id === id);\n        if(shape==undefined){\n          isFunded=false;\n        }else{\n          isFunded=true;\n        }\n        i++;\n        }else{        \n          isFunded=true;\n        }\n      }\n      */\n\n      //if it is a line, we need the transformer dedicated to the line (ie transformer with id=\"lineTransformer\")\n      //if it is a classic shape, we need the transformer dedicated to the shape (ie transformer with id=\"shapeTransformer\")\n      if(e.target.attrs.id==\"center\"){\n        return;\n      }\n\n      if(e.target.className==\"Line\"){\n        transformer_id=\"lineTransformer\"\n        shape = this.groups.find((r) => r.id === id).line;\n        this.center.draggable=false;\n        this.selectedShapeAlignment=shape.defaultAlignment;\n        this.eraseNodefromTransformer(\"shapeTransformer\");\n      }else{\n        transformer_id=\"shapeTransformer\"\n        this.center.draggable=true;\n        this.selectedShapeAlignment=shape.centerPosition;\n        this.eraseNodefromTransformer(\"lineTransformer\");\n      }\n      \n      if (shape!=undefined) {\n        this.selectedShapeId = id;\n        this.center.opacity=1;\n        this.updateTransformer(transformer_id);\n      } else{\n        /*Only if the center is not selected.\n        When the center is dragged, this function is called.\n        But a shape is actualy selected (the one of the center).\n        */\n        this.selectedShapeId = 'NoId';\n      }\n      //this.updateTransformer(transformer_id);\n      \n      this.updateDragFuncOfCenter()\n    },\n\n    //remove node from transformer with id=transformer_id\n    eraseNodefromTransformer(transformer_id) {\n      let stage= this.$refs.stage.getStage();      \n      const transformerNode = stage.find(\"#\"+transformer_id)[0]; \n      transformerNode.nodes([]);\n    },\n\n    //Update transformer with id=transformer_id\n    //It places the transformer regarding what node is selected\n    updateTransformer(transformer_id) {\n      \n      let stage= this.$refs.stage.getStage();\n      const transformerNode = stage.find(\"#\"+transformer_id)[0];\n      let selectedNode;\n      if (transformer_id==\"lineTransformer\"){\n        selectedNode = stage.children[0].getChildren().filter((r)=> r.attrs.className==\"Group\" && r.attrs.id==this.selectedShapeId)[0]\n        .getChildren().filter(r=>r.attrs.className==\"Line\" && r.attrs.id==this.selectedShapeId)[0];\n      }else{\n      selectedNode = stage.children[0].getChildren().filter((r)=>r.attrs.className!=\"Group\" && r.attrs.id==this.selectedShapeId)[0];\n\n      let isFunded=true;\n      if(selectedNode==undefined){\n        isFunded=false;\n      }\n      let i=0;\n      while(!isFunded){\n        if(i<this.groups.length){\n          selectedNode=stage.children[0].getChildren().filter((r)=>r.attrs.className==\"Group\")[i].getChildren().find((r)=>r.attrs.id==this.selectedShapeId && r.attrs.className!=\"Line\");\n        if(selectedNode==undefined){\n          isFunded=false;\n        }else{\n          isFunded=true;\n        }\n        i++;\n        }else{        \n          isFunded=true;\n        }\n      }\n      }\n      /*\n      if (transformer_id==\"lineTransformer\"){\n        selectedNode = stage.children[0].getChildren().filter((r)=> r.attrs.className==\"Group\" && r.attrs.id==this.selectedShapeId)[0]\n        .getChildren().filter(r=>r.attrs.className==\"Line\" && r.attrs.id==this.selectedShapeId)[0];\n      }\n      */\n     \n      //If the selected node has already the transformer on it, nothing happen\n      if (selectedNode === transformerNode.node()) {\n        return;\n      }\n\n      if (selectedNode!=undefined) {\n        transformerNode.nodes([selectedNode]);\n      } else {\n        transformerNode.nodes([]);\n      }\n      this.center.x=selectedNode.attrs.x;\n      this.center.y=selectedNode.attrs.y;\n      \n    },\n/*\n  DisplayCenterMenu(e){\n    CenterMenu.props.ConcernedShape=e.target;\n   document.getElementById(\"center_menu\").style.display=\"initial\";\n   document.getElementById(\"center_menu\").style.top=e.target.getStage().getPointerPosition().y+8+\"px\";\n  document.getElementById(\"center_menu\").style.left=e.target.getStage().getPointerPosition().x+8+\"px\";\n  },\n  */\n\n  //display context menu according to the target\n  /*\n  DisplayContextMenu(e){\n    e.evt.preventDefault()\n    if (e.target.className!=undefined && e.target.attrs.id!=\"center\"){\n      this.isStageOnlySelected=false;\n      ContextMenu.data().dM='initial';\n      this.$emit('needmenu');\n      this.needMenu=true;\n      ContextMenu.props.ConcernedShape=e.target;\n      if (e.target.attrs.className==\"Line\"){\n        this.isALineSelected=true;\n        this.isAGroupedShapeSelected=true;\n        //We precise the text which depends on the line where we clicked.\n        this.keepDistanceButtonText=e.target.attrs.keepDistanceButtonText;\n      } else if(e.target.getParent().attrs.className==\"Group\"){\n        this.isAGroupedShapeSelected=true;\n      }\n      else{\n        this.isALineSelected=false;\n        this.isAGroupedShapeSelected=false;\n      }\n      document.getElementById(\"active\").style.display=\"initial\";\n      document.getElementById(\"active\").style.top=e.target.getStage().getPointerPosition().y+8+\"px\";\n      document.getElementById(\"active\").style.left=e.target.getStage().getPointerPosition().x +8+\"px\";\n    }\n    if (e.target === e.target.getStage()) {\n      this.needMenu=true;\n      this.isALineSelected=false;\n      this.isAGroupedShapeSelected=false;\n      this.isStageOnlySelected=true;\n      document.getElementById(\"active\").style.display=\"initial\";\n      document.getElementById(\"active\").style.top=e.target.getStage().getPointerPosition().y+8+\"px\";\n      document.getElementById(\"active\").style.left=e.target.getStage().getPointerPosition().x +8+\"px\";\n    \n    }\n  },\n\n  //hide context menu\n  HideContextMenu(){\n    this.needMenu=false;\n    document.getElementById(\"active\").style.display=\"none\";\n    document.getElementById(\"center_menu\").style.display=\"none\";\n  },\n*/\n\n  \n ChangeCenter(e){\n  let res=this.findShape(this.selectedShapeId);\n  let shape=res.shape_data;\n  let threshold1;\n  let threshold2;\n  let dist=this.GiveSignOfDistanceBtwCenterAndShape(e.target.attrs,shape)*Math.sqrt((e.target.y()-(shape.y))**2+(e.target.x()-shape.x)**2)+shape.offsetY*shape.scaleY;\n  \n  //let last_offsetX=shape.offsetX;\n  let last_offsetY=shape.offsetY;\n  if(shape==undefined){\n    shape=this.groups.find((r)=>r.id==this.selectedShapeId).line;\n\n  }else{\n    \n      if(shape.className==\"Rect\") {\n        threshold1=shape.height*shape.scaleY/3;\n        threshold2=shape.height*shape.scaleY*2/3;\n        if(dist>=threshold1 && dist<=threshold2){\n          shape.offsetX=shape.width/2;\n          shape.offsetY=shape.height/2;\n          shape.centerPosition=\"Middle\";\n        }else if(dist>threshold2){\n          shape.offsetX=shape.width/2;\n          shape.offsetY=shape.height;\n          shape.centerPosition=\"Bottom\";\n        }\n        else{\n          shape.offsetX=shape.width/2;\n          shape.offsetY=0;\n          shape.centerPosition=\"Top\";\n        }\n      }\n      else if(shape.className==\"Circle\") {\n        dist=dist+shape.radius*shape.scaleY;\n        threshold1=shape.radius*shape.scaleY*2/3;\n        threshold2=shape.radius*shape.scaleY*4/3;\n        if(dist>=threshold1 && dist<=threshold2){\n          shape.offsetX=0;\n          shape.offsetY=0;\n          shape.centerPosition=\"Middle\";\n        }else if(dist>threshold2){\n          shape.offsetX=0;\n          shape.offsetY=shape.radius;\n          shape.centerPosition=\"Bottom\";\n        }else{\n          shape.offsetX=0;\n          shape.offsetY=-shape.radius;\n          shape.centerPosition=\"Top\";\n        } \n      }\n      else if(shape.className==\"Image\") {\n        threshold1=shape.image.height*shape.scaleY/3;\n        threshold2=shape.image.height*shape.scaleY*2/3;\n        if(dist>=threshold1 && dist<=threshold2){\n          shape.offsetX=shape.image.width/2;\n          shape.offsetY=shape.image.height/2;\n          shape.centerPosition=\"Middle\";\n        }else if(dist>threshold2){\n          shape.offsetX=shape.image.width/2;\n          shape.offsetY=shape.image.height;\n          shape.centerPosition=\"Bottom\";\n        }\n        else {\n          shape.offsetX=shape.image.width/2;\n          shape.offsetY=0;\n          shape.centerPosition=\"Top\";\n        }\n      }\n      else if(shape.className==\"Text\") {\n        threshold1=shape.length_y*shape.scaleY/3;\n        threshold2=shape.length_y*shape.scaleY*2/3;\n        if(dist>=threshold1 && dist<=threshold2){\n          shape.offsetX=shape.length_x/2;\n          shape.offsetY=shape.length_y/2;\n          shape.centerPosition=\"Middle\";\n        }else if(dist>threshold2){\n          shape.offsetX=shape.length_x/2;\n          shape.offsetY=shape.length_y;\n          shape.centerPosition=\"Bottom\";\n        }\n        else{\n          shape.offsetX=shape.length_x/2;\n          shape.offsetY=0;\n          shape.centerPosition=\"Top\";\n        }\n      }\n      else if(shape.className==\"Triangle\") {\n        dist=dist+shape.radius*shape.scaleY;\n        threshold1=shape.radius*shape.scaleY/2;\n        threshold2=shape.radius*shape.scaleY*5/4;\n        if(dist>=threshold1 && dist<=threshold2){\n          shape.offsetX=0;\n          shape.offsetY=0;\n        }else if(dist>threshold2){\n          shape.offsetX=0;\n          shape.offsetY=shape.radius/2\n          shape.centerPosition=\"Bottom\";\n        }\n        else{\n          shape.offsetX=0;\n          shape.offsetY=-shape.radius;\n          shape.centerPosition=\"Top\";\n        }\n      }\n      shape.y=shape.y-(last_offsetY-shape.offsetY)*shape.scaleY*Math.cos(shape.rotation*(Math.PI/180));\n      shape.x=shape.x+(last_offsetY-shape.offsetY)*shape.scaleY*Math.sin(shape.rotation*(Math.PI/180));\n      this.selectedShapeAlignment=shape.centerPosition;\n\n      if (res.grp_id!='-1'){\n        this.updateAllPosInGrp(res.grp_id);\n      }\n        \n      e.target.x(shape.x);\n      e.target.y(shape.y);\n\n     \n\n      \n  }\n  },\n  /*\n  ChangeAlignCenter(align_choice){\n    let center=CenterMenu.props.ConcernedShape;\n    let grp=this.groups.find((r)=>r.id===this.selectedShapeId);\n    let shape;\n    if(grp!=undefined){\n      for(let i=0;i<grp.shapes_g.length;i++){\n        this.ChangeCenterRegardingCommand(grp.shapes_g[i].id,align_choice)\n      }\n      center.x(grp.line.x);\n      center.y(grp.line.y);\n      if(grp.line.defaultAlignment==align_choice){\n        grp.line.defaultAlignment='' //If we select again the same alogn_choice, we deselect it, no alignement center is fixed.\n      }else{\n        grp.line.defaultAlignment=align_choice;\n      }\n      this.selectedShapeAlignment=grp.line.defaultAlignment;\n    }else{\n      shape=this.findShape(this.selectedShapeId).shape_data;\n      this.ChangeCenterRegardingCommand(shape.id,align_choice)\n      this.selectedShapeAlignment=shape.centerPosition;\n      center.x(shape.x);\n      center.y(shape.y);\n    }\n  },\n  */\n  //Allow to change the center regarding a text command (Top,Middle or Bottom)\n  ChangeCenterRegardingCommand(shape_id,command){\n    let res=this.findShape(shape_id);\n    let shape=res.shape_data;\n    let last_offsetY=shape.offsetY;\n    if(shape.className==\"Rect\" ){\n      if(command==\"Top\"){\n        shape.offsetY=0;\n        shape.offsetX=shape.width/2;\n      }\n      else if(command==\"Middle\"){\n          shape.offsetX=shape.width/2;\n          shape.offsetY=shape.height/2;\n      }else if(command==\"Bottom\"){\n            shape.offsetX=shape.width/2;\n            shape.offsetY=shape.height;\n      }\n    }\n      else if(shape.className==\"Circle\") {\n        if(command==\"Top\"){\n          shape.offsetX=0;\n          shape.offsetY=-shape.radius;\n        }else if(command==\"Middle\"){\n          shape.offsetX=0;\n          shape.offsetY=0\n        }else if(command==\"Bottom\"){\n          shape.offsetX=0;\n          shape.offsetY=shape.radius;\n        } \n      }\n      else if(shape.className==\"Image\") {\n        if(command==\"Middle\"){\n          shape.offsetX=shape.image.width/2;\n          shape.offsetY=shape.image.height/2;\n        }else if(command==\"Bottom\"){\n          shape.offsetX=shape.image.width/2;\n          shape.offsetY=shape.image.height;\n        }\n        else if (command==\"Top\"){\n          shape.offsetX=shape.image.width/2;\n          shape.offsetY=0;\n        }\n      }\n      else if(shape.className==\"Text\") {\n        if(command==\"Middle\"){\n          shape.offsetX=shape.length_x/2;\n          shape.offsetY=shape.length_y/2;\n        }else if(command==\"Bottom\"){\n          shape.offsetX=shape.length_x/2;\n          shape.offsetY=shape.length_y;\n        }\n        else if(command==\"Top\"){\n          shape.offsetX=shape.length_x/2;\n          shape.offsetY=0;\n        }\n      }\n      else if(shape.className==\"Triangle\") {\n        if(command==\"Middle\"){\n          shape.offsetX=0;\n          shape.offsetY=0;\n        }else if(command==\"Bottom\"){\n          shape.offsetX=0;\n          shape.offsetY=shape.radius/2;\n        }\n        else if(command==\"Top\"){\n          shape.offsetX=0;\n          shape.offsetY=-shape.radius;\n        }\n      }\n      shape.centerPosition=command;\n      shape.y=shape.y-(last_offsetY-shape.offsetY)*shape.scaleY*Math.cos(shape.rotation*(Math.PI/180));\n      shape.x=shape.x+(last_offsetY-shape.offsetY)*shape.scaleY*Math.sin(shape.rotation*(Math.PI/180));\n\n      if (res.grp_id!='-1'){\n        this.updateAllPosInGrp(res.grp_id);\n      }\n        \n      //center.x(shape.x);\n      //center.y(shape.y);\n  },\n  updateDragFuncOfCenter(){\n    let shape=this.findShape(this.selectedShapeId).shape_data\n    if(shape==undefined){\n      return;\n    }\n    let center=this.center;\n    let angle=shape.rotation*(Math.PI/180);\n    if(angle>=-Math.PI/2 && angle<=0){\n      angle-=90*(Math.PI/180);\n    }else if(angle<-Math.PI/2){\n      angle+=(Math.PI/2);\n      angle=Math.PI+angle;\n    } else if(angle<=Math.PI && angle>0){\n      angle-=90*(Math.PI/180);\n    } \n    if (angle<=0 && angle>=-Math.PI/4){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x +(pos.x-shape.x)*Math.cos(angle),\n          y: shape.y+(pos.x-shape.x)*Math.sin(angle),\n        };\n      }\n    } else if (angle<-Math.PI/4 && angle>=-Math.PI/2){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x-(pos.y-shape.y)*Math.cos(angle),\n          y: shape.y-(pos.y-shape.y)*Math.sin(angle),\n        };\n      }\n    }\n    else if (angle<-Math.PI/2 && angle>=-3*Math.PI/4){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x-(pos.y-shape.y)*Math.cos(angle),\n          y: shape.y-(pos.y-shape.y)*Math.sin(angle),\n        };\n      }\n    } else if (angle<-3*Math.PI/4 && angle>=-Math.PI){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x-(pos.x-shape.x)*Math.cos(angle),\n          y: shape.y-(pos.x-shape.x)*Math.sin(angle),\n        };\n      }\n    }else if (angle<=Math.PI && angle>=3*Math.PI/4){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x-(pos.x-shape.x)*Math.cos(angle),\n          y: shape.y-(pos.x-shape.x)*Math.sin(angle),\n        };\n      }\n    } else if (angle<3*Math.PI/4 && angle>=Math.PI/2){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x+(pos.y-shape.y)*Math.cos(angle),\n          y: shape.y+(pos.y-shape.y)*Math.sin(angle),\n        };\n      }\n    } else if (angle<Math.PI/2 && angle>=Math.PI/4){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x+(pos.y-shape.y)*Math.cos(angle),\n          y: shape.y+(pos.y-shape.y)*Math.sin(angle),\n        };\n      }\n    }else if (angle<Math.PI/4 && angle>=0){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x+(pos.x-shape.x)*Math.cos(angle),\n          y: shape.y+(pos.x-shape.x)*Math.sin(angle),\n        };\n      }\n    }\n  },\n  MovingCenter(){\n    //let shape=this.findShape(this.selectedShapeId)\n    //console.log(e.target)\n  },\n  /*\n  //called when the \"Change Center\" button is clicked\n  ChangeCenterButtonAction(){\n      let shape= ContextMenu.props.ConcernedShape;\n      if(shape.attrs.className==\"Line\"){\n        let shapes_g=shape.getParent().attrs.shapes_g //the list of the shapes which are on the line is in the corresponding group.\n        for (let j=0;j<shapes_g.length;j++){\n          this.ChangeCenter(shapes_g[j]);\n        }\n      }else{\n        let shape_data=this.shapes.find(i => i.id ===shape.attrs.id);\n        let isFunded=true;\n        if(shape_data==undefined){\n          isFunded=false;\n        }\n        let i=0;\n        while(!isFunded){\n          if(i<this.groups.length){\n            shape_data=this.groups[i].shapes_g.find(i => i.id === shape.attrs.id);\n          if(shape_data==undefined){\n            isFunded=false;\n          }else{\n            isFunded=true;\n          }\n          i++;\n          }else{        \n            isFunded=true;\n          }\n        }\n        this.ChangeCenter(shape_data)\n      }\n    },\n    */\n    \n    //allow to copy a target\n    /*\n    Copy(){\n      ContextMenu.props.CopiedShape=ContextMenu.props.ConcernedShape;\n      ContextMenu.props.pastOneObject=true;\n    },\n    CopyAll(){\n      ContextMenu.props.CopiedShape=ContextMenu.props.ConcernedShape;\n      ContextMenu.props.pastOneObject=false;\n    },\n    Past(){   \n      //Prevent error when no shape is copied\n      if(ContextMenu.props.CopiedShape.attrs==undefined){\n        return;\n      }\n      let clone=ContextMenu.props.CopiedShape.clone({\n        id: ''+this.max_id_figures,\n      })\n      //let layer=ContextMenu.props.CopiedShape.getLayer();\n      let i= this.groups.length\n      //let new_id=i+1;\n      if(ContextMenu.props.CopiedShape.attrs.className==\"Line\"){\n        this.max_id_figures=this.max_id_figures+1;\n        if(!ContextMenu.props.pastOneObject){\n          //let i= this.groups.length;\n          //let new_id=i+1;\n        \n          clone=ContextMenu.props.CopiedShape.getParent().clone({\n            id: ''+ this.max_id_figures,\n            name: \"group\"+this.max_id_figures,\n            shapes_g:[],\n          })\n          clone.attrs.line.id=''+this.max_id_figures;\n          clone.attrs.line.x=ContextMenu.props.ConcernedShape.getStage().getPointerPosition().x;\n          clone.attrs.line.y=ContextMenu.props.ConcernedShape.getStage().getPointerPosition().y;\n          let positionPoints=Object.assign([],clone.attrs.line.positionPoints);\n            let length=positionPoints.length;\n            clone.attrs.line.positionPoints=[];\n            for(let i=0;i<length.valueOf();i++){\n              let clone_positionPoint=ContextMenu.props.CopiedShape.getParent().getChildren().find((r)=>r.attrs.id===positionPoints[i].id).clone({\n              id:'positionPoint'+clone.attrs.line.id+i,\n              });\n              clone.attrs.line.positionPoints.push(clone_positionPoint.attrs,);\n            }\n          \n          //layer= ContextMenu.props.CopiedShape.getParent().getLayer();\n          this.groups.push(clone.attrs,);\n          let shapesg=this.groups[this.groups.indexOf(this.groups.find((r)=> r.id==ContextMenu.props.CopiedShape.getParent().attrs.id))].shapes_g;\n          let shapesg_length=shapesg.length;\n          for (let j=0; j<shapesg_length;j++){\n            this.max_id_figures=this.max_id_figures + 1;\n            let clone_shape=ContextMenu.props.CopiedShape.getParent().getChildren().find((r)=>r.attrs.id===shapesg[j].id).clone({\n              id:''+this.max_id_figures,\n            });\n           // this.updateDragFunc(clone_shape,clone_line);\n            this.groups[i].shapes_g.push(clone_shape.attrs,);\n            this.updateDragFunc(this.groups[i].shapes_g[this.groups[i].shapes_g.length-1],this.groups[i].line);\n          }\n          this.updateAllPosInGrp(clone.attrs.id);\n        }else{\n          //let i= this.groups.length;\n          //let new_id=i+1;\n        \n          clone=ContextMenu.props.CopiedShape.getParent().clone({\n            id: ''+this.max_id_figures,\n            name: \"group\"+this.max_id_figures,\n            shapes_g:[],\n          })\n          clone.attrs.line.id=''+this.max_id_figures;\n          clone.attrs.line.x=ContextMenu.props.ConcernedShape.getStage().getPointerPosition().x;\n          clone.attrs.line.y=ContextMenu.props.ConcernedShape.getStage().getPointerPosition().y;\n          for(let j=0;j<clone.attrs.line.occupiedDistances.length;j++){\n            clone.attrs.line.freeDistances.push(clone.attrs.line.occupiedDistances[j],);\n          }\n          clone.attrs.line.occupiedDistances=[];\n          if(clone.attrs.line.keepDistribution!=1){\n            let positionPoints=Object.assign([],clone.attrs.line.positionPoints);\n            let length=positionPoints.length;\n            clone.attrs.line.positionPoints=[];\n            for(let i=0;i<length.valueOf();i++){\n              let clone_positionPoint=ContextMenu.props.CopiedShape.getParent().getChildren().find((r)=>r.attrs.id===positionPoints[i].id).clone({\n              id:'positionPoint'+clone.attrs.line.id+i,\n              });\n              clone.attrs.line.positionPoints.push(clone_positionPoint.attrs,);\n            }\n          }\n          //layer= ContextMenu.props.CopiedShape.getParent().getLayer();\n          this.groups.push(clone.attrs,)\n        }\n        //In order to actualize the new line (in particular to show the positionPoints):\n        this.updateAllPosInGrp(clone.attrs.id)\n      } \n      else{\n        this.max_id_figures=this.max_id_figures + 1;\n        clone=ContextMenu.props.CopiedShape.clone({\n          id: ''+this.max_id_figures,  \n          x:ContextMenu.props.ConcernedShape.getStage().getPointerPosition().x,\n          y:ContextMenu.props.ConcernedShape.getStage().getPointerPosition().y,\n        });\n        clone.attrs.dragBoundFunc=function (pos) {\n          return {\n            x: pos.x,\n            y: pos.y,\n          };\n        };\n        clone.attrs.isGrouped=0;\n        this.shapes.push(clone.attrs,); \n         \n      }\n      //layer.batchDraw(); \n      \n    },\n    //RemoveShape(shape)\n    Remove(shape){\n      //let shape=ContextMenu.props.ConcernedShape;\n      if(shape.attrs.className==\"Line\"){\n        let grp=this.groups.find((r)=>r.id===shape.attrs.id);\n        const length=grp.shapes_g.length;\n        for(let i=0;i<length;i++){\n          grp.shapes_g[i].dragBoundFunc= dragFunc;\n          grp.shapes_g[i].isGrouped=0;\n          this.shapes.push(grp.shapes_g[i],);\n        }\n        this.eraseNodefromTransformer(\"lineTransformer\");\n        this.groups.splice(this.groups.indexOf(grp),1);\n        shape.getParent().destroy();\n\n        //We give to the circle (representing center of shapes) a default position\n        if(this.groups[0]!=undefined){\n          this.center.x=this.groups[0].line.x;\n          this.center.y=this.groups[0].line.y;\n        } else if(this.shapes[0]!=undefined){\n          this.center.x=this.shapes[0].x;\n          this.center.y=this.shapes[0].y;\n        }\n        this.center.opacity=0;\n        \n      }else if(shape.attrs.className==\"positionPoint\"){\n        let line=shape.getParent().attrs.line;\n        let target_positionPoint=line.positionPoints.find((r)=>r.id===shape.attrs.id);\n        let index=line.freeDistances.indexOf(shape.attrs.distance_to_line_center);\n        console.log(line.positionPoints);\n        if(line.keepDistribution!=1 && index!=-1){\n          line.freeDistances.splice(index,1);\n          line.positionPoints.splice(line.positionPoints.indexOf(target_positionPoint),1)\n        }\n      }\n      else{\n        let res=this.findShape(shape.attrs.id)\n        let shape_data=res.shape_data;\n        let grp_id=res.grp_id;\n        if(shape_data!=undefined){\n        if(grp_id!='-1'){\n        //let shape_data=this.shapes.find(i => i.id ===shape.attrs.id);\n        let grp=this.groups.find((r)=>r.id===grp_id);\n          grp.line.freeDistances.push(grp.line.occupiedDistances[grp.shapes_g.indexOf(shape_data)],)\n          grp.line.occupiedDistances.splice(grp.shapes_g.indexOf(shape_data),1)\n          \n          grp.shapes_g.splice(grp.shapes_g.indexOf(shape_data),1);\n          this.updateOccupiedDistance(grp.id);\n          \n          this.updateAllPosInGrp(grp.id);\n          \n         console.log(grp.line.positionPoints)\n      \n        } else{\n          this.eraseNodefromTransformer(\"shapeTransformer\");\n          this.shapes.splice(this.shapes.indexOf(shape_data),1);\n          //We give to the circle (representing center of shapes) a default position\n          if(this.groups[0]!=undefined){\n            this.center.x=this.groups[0].line.x;\n            this.center.y=this.groups[0].line.y;\n          } else if(this.shapes[0]!=undefined){\n            this.center.x=this.shapes[0].x;\n            this.center.y=this.shapes[0].y;\n          }\n          this.center.opacity=0;\n        }\n        shape.destroy();\n        }\n      }\n    },\n\n    RemoveAll(){\n      let shape=ContextMenu.props.ConcernedShape;\n      if(shape.className==\"Line\"){\n        let grp=this.groups.find((r)=>r.id===shape.attrs.id);\n        while(grp.shapes_g.length!=0){\n          grp.shapes_g[0].dragBoundFunc= dragFunc;\n          grp.shapes_g.splice(0,1);\n        }\n        this.eraseNodefromTransformer(\"lineTransformer\");\n        this.groups.splice(this.groups.indexOf(grp),1);\n        shape.getParent().destroy();\n\n        //We give to the circle (representing center of shapes) a default position\n        if(this.groups[0]!=undefined){\n          this.center.x=this.groups[0].line.x;\n          this.center.y=this.groups[0].line.y;\n        } else if(this.shapes[0]!=undefined){\n          this.center.x=this.shapes[0].x;\n          this.center.y=this.shapes[0].y;\n        }\n        \n      }else{\n        return;\n      }\n    },\n    */\n\n    findShape(id){\n      let shape_data=this.shapes.find(i => i.id ===id);\n      let grp_id='-1'; // return grp_id=-1 if the shape doesn't belong to attached group.\n      let isFunded=true;\n      if(shape_data==undefined){\n        isFunded=false;\n      }\n      let i=0;\n      while(!isFunded){\n        if(i<this.groups.length){\n          shape_data=this.groups[i].shapes_g.find(i => i.id === id);\n        if(shape_data==undefined){\n          isFunded=false;\n        }else{\n          grp_id=this.groups[i].id; \n          isFunded=true;\n        }\n        i++;\n        }else{        \n          isFunded=true;\n        }\n      }\n      return {shape_data, grp_id}\n    },\n\n    //detach a shape from its line.\n    /*\n    DetachShape(shape){\n      \n      \n      const added_distance=this.lengthToCapture+5;\n      let grp=this.groups.find((r)=>r.shapes_g.indexOf(shape)!=-1);\n      let i=grp.shapes_g.indexOf(shape);\n      \n      shape.dragBoundFunc= dragFunc;\n\n      let coord_y1=grp.line.y-grp.line.points[4]*(1/2)*grp.line.scaleX*Math.sin(grp.line.rotation*(Math.PI/180));\n      let coord_x2=grp.line.x+grp.line.points[4]*(1/2)*grp.line.scaleX*Math.cos(grp.line.rotation*(Math.PI/180));\n      let coord_y2= grp.line.y+grp.line.points[4]*(1/2)*grp.line.scaleX*Math.sin(grp.line.rotation*(Math.PI/180));\n      let coord_x1=grp.line.x-grp.line.points[4]*(1/2)*grp.line.scaleX*Math.cos(grp.line.rotation*(Math.PI/180));\n      let a=(coord_y2-coord_y1)/(coord_x2-coord_x1);\n      //let b=grp.line.y-a*grp.line.x;\n      let b=shape.x*(1/a)+shape.y;\n      if (grp.line.rotation<0 && grp.line.rotation>-90){\n        \n        shape.x=shape.x-added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } else if(grp.line.rotation<-90){\n        shape.x=shape.x+added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } else if( grp.line.rotation>0 && grp.line.rotation<180){\n        \n        shape.x=shape.x+added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } \n      else if(grp.line.rotation==-90){\n        shape.x=shape.x+added_distance\n      } else if(grp.line.rotation==90){\n        shape.x=shape.x-added_distance\n      } else if(grp.line.rotation==180 || grp.line.rotation==-180){\n        shape.y=shape.y-added_distance\n      } else if(grp.line.rotation==0){\n        shape.y=shape.y+added_distance\n      } \n      //shape.rotation=shape.rotation+shape.personalRotation;\n      shape.isGrouped=0;\n      this.shapes.push(shape,)\n      this.center.x=shape.x;\n      this.center.y=shape.y;\n      grp.line.freeDistances.push(grp.line.occupiedDistances[i]);\n      grp.line.occupiedDistances.splice(i,1);\n      grp.shapes_g.splice(i,1);\n      grp.line.positionPoints.splice(i,1)\n      \n      this.updateOccupiedDistance(grp.id)\n      this.updateAllPosInGrp(grp.id)\n      this.updateNaration(grp)\n    \n    },\n    */\n\n    DetachShape(shape,target_x,target_y){\n      \n      \n      const added_distance=this.lengthToCapture+5;\n      let grp=this.groups.find((r)=>r.shapes_g.indexOf(shape)!=-1);\n      let i=grp.shapes_g.indexOf(shape);\n      \n      shape.dragBoundFunc= dragFunc;\n\n      let coord_y1=grp.line.y-grp.line.points[4]*(1/2)*grp.line.scaleX*Math.sin(grp.line.rotation*(Math.PI/180));\n      let coord_x2=grp.line.x+grp.line.points[4]*(1/2)*grp.line.scaleX*Math.cos(grp.line.rotation*(Math.PI/180));\n      let coord_y2= grp.line.y+grp.line.points[4]*(1/2)*grp.line.scaleX*Math.sin(grp.line.rotation*(Math.PI/180));\n      let coord_x1=grp.line.x-grp.line.points[4]*(1/2)*grp.line.scaleX*Math.cos(grp.line.rotation*(Math.PI/180));\n      let a=(coord_y2-coord_y1)/(coord_x2-coord_x1);\n      //let b=grp.line.y-a*grp.line.x;\n      let b=shape.x*(1/a)+shape.y;\n      if (grp.line.rotation<0 && grp.line.rotation>-45){\n        \n        shape.x=shape.x+Math.sign(shape.y-target_y)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } else if (grp.line.rotation<=-45 && grp.line.rotation>-90){\n        \n        shape.x=shape.x+Math.sign(shape.x-target_x)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      }\n      \n      else if(grp.line.rotation<-90 && grp.line.rotation>-135){\n        shape.x=shape.x+Math.sign(shape.x-target_x)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } \n      else if(grp.line.rotation<=-135 && grp.line.rotation>-180){\n        shape.x=shape.x-Math.sign(shape.y-target_y)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } \n      \n      else if( grp.line.rotation>135 && grp.line.rotation<180){\n        \n        shape.x=shape.x-Math.sign(shape.y-target_y)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } else if( grp.line.rotation>90 && grp.line.rotation<=135){\n        \n        shape.x=shape.x-Math.sign(shape.x-target_x)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } else if( grp.line.rotation>45 && grp.line.rotation<=90){\n        \n        shape.x=shape.x-Math.sign(shape.x-target_x)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } else if( grp.line.rotation>0 && grp.line.rotation<=45){\n        \n        shape.x=shape.x+Math.sign(shape.y-target_y)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } \n      else if(grp.line.rotation==-90){\n        shape.x=shape.x-Math.sign(shape.x-target_x)*added_distance\n      } else if(grp.line.rotation==90){\n        shape.x=shape.x+Math.sign(shape.x-target_x)*added_distance\n      } else if(grp.line.rotation==180 || grp.line.rotation==-180){\n        shape.y=shape.y-Math.sign(shape.y-target_y)*added_distance\n      } else if(grp.line.rotation==0){\n        shape.y=shape.y-Math.sign(shape.y-target_y)*added_distance\n      } \n      //shape.rotation=shape.rotation+shape.personalRotation;\n      shape.isGrouped=0;\n      this.shapes.push(shape,)\n      this.center.x=shape.x;\n      this.center.y=shape.y;\n      grp.line.freeDistances.push(grp.line.occupiedDistances[i]);\n      grp.line.occupiedDistances.splice(i,1);\n      grp.shapes_g.splice(i,1);\n      grp.line.positionPoints.splice(i,1)\n      \n      this.updateOccupiedDistance(grp.id)\n      this.updateAllPosInGrp(grp.id)\n      this.updateNaration(grp)\n      this.eraseNodefromTransformer(\"shapeTransformer\");\n    \n    },\n    /*\n\n    //called when the button \"Detach Shape\" is clicked\n    DetachShapeButtonAction(){\n      let shape= ContextMenu.props.ConcernedShape;\n      if(shape.attrs.className==\"Line\"){\n        let shapes_g=shape.getParent().attrs.shapes_g;\n        while(shapes_g.length!=0){\n          this.DetachShape(shapes_g[0]);\n        }\n      }else{\n        let shape_data=this.shapes.find(i => i.id ===shape.attrs.id);\n        let isFunded=true;\n        if(shape_data==undefined){\n          isFunded=false;\n        }\n        let i=0;\n        while(!isFunded){\n          if(i<this.groups.length){\n            shape_data=this.groups[i].shapes_g.find(i => i.id === shape.attrs.id);\n          if(shape_data==undefined){\n            isFunded=false;\n          }else{\n            isFunded=true;\n          }\n          i++;\n          }else{        \n            isFunded=true;\n          }\n        }\n        this.DetachShape(shape_data)\n      }\n    },\n\n    //called when the button \"keep/liberate distribution\" is clicked.\n    KeepDistribution(){\n      let grp=this.groups.find(i => i.id === ContextMenu.props.ConcernedShape.attrs.id);\n      let line=grp.line;\n      if(line==undefined){\n        return;\n      }else{\n        if(line.keepDistribution){\n          line.keepDistribution=false;\n          for (let i=0;i<grp.shapes_g.length;i++){\n            grp.shapes_g[i].distance_to_line_center=line.occupiedDistances[i]\n          }\n          line.freeDistances=[];\n\n          line.stroke='blue'\n          grp.line.keepDistanceButtonText=\"Keep Distribution\";\n          //ContextMenu.props.ConcernedShape.attrs.keepDistanceButtonText=\"Keep Distribution\";\n        }else{\n          line.keepDistribution=true;\n          for (let i=0;i<grp.shapes_g.length;i++){\n            line.occupiedDistances[i]=grp.shapes_g[i].distance_to_line_center;\n          }\n          line.stroke='black'\n          grp.line.keepDistanceButtonText=\"Liberate Distribution\";\n          //ContextMenu.props.ConcernedShape.attrs.keepDistanceButtonText=\"Liberate Distribution\";\n          this.updateOccupiedDistance(line.id);\n          this.updateAllPosInGrp(line.id);\n        }\n      }\n    },\n    */\n    createNewShape(shape){\n      if(shape.attrs.className==\"Line\"){\n        \n        this.max_id_figures=this.max_id_figures+1;\n\n          let clone=shape.getParent().clone({\n            id: ''+this.max_id_figures,\n            name: \"group\"+this.max_id_figures,\n            shapes_g:[],\n          })\n          clone.attrs.line.id=''+this.max_id_figures;\n          clone.attrs.line.x=shape.getStage().getPointerPosition().x;\n          clone.attrs.line.y=shape.getStage().getPointerPosition().y;\n          clone.attrs.line.draggable=true;\n          this.groups.push(clone.attrs,)\n          \n        \n      }else{\n        \n        this.max_id_figures=this.max_id_figures+1\n        let clone=shape.clone({\n          id: ''+this.max_id_figures,\n          draggable: true,\n        })\n        clone.attrs.isGrouped=0;\n        this.shapes.push(clone.attrs,);\n      }\n      \n\n    },\n    \n  \n  eraserAction(e){\n    this.Remove(e.target);\n    \n  },\n  unshowSelectedShape(e){\n    if(e.target.attrs.className==\"Line\" && this.eraseMode==0){\n      e.target.opacity(0.5)\n    }\n    else if(e.target.attrs.className==\"Line\" && this.eraseMode==1){\n      if(e.target.attrs.keepDistribution==1){\n        e.target.stroke(\"black\")\n      }else{\n        e.target.stroke(\"blue\")\n      }\n    }\n    else if(e.target.attrs.className==\"positionPoint\" && this.eraseMode==1){\n      if(e.target.getParent().attrs.line.keepDistribution!=1){\n        e.target.strokeWidth(0)\n      }\n    }\n    else if(this.eraseMode==1){\n      e.target.strokeWidth(0)\n    }\n  },\n  showSelectedShape(e){\n    if(e.target.attrs.className==\"Line\" && this.eraseMode==0){\n      e.target.opacity(1)\n    }\n    else if(e.target.attrs.className==\"Line\" && this.eraseMode==1){\n      e.target.stroke('rgb(200, 59, 218)')\n    }\n    else if(e.target.attrs.className==\"positionPoint\" && this.eraseMode==1){\n      let line=e.target.getParent().attrs.line;\n      if(line.freeDistances.indexOf(e.target.attrs.distance_to_line_center)!=-1){\n        if(line.keepDistribution!=1){\n          e.target.stroke('rgb(200, 59, 218)')\n          e.target.strokeWidth(3)\n        }\n      }\n    }\n    else if(this.eraseMode==1){\n      e.target.stroke('rgb(200, 59, 218)')\n      e.target.strokeWidth(3)\n    }\n  },\n  editText(e){\n    //let valuey=document.getElementById(\"stage\").style.top+e.target.y()\n    //let valuex=document.getElementById(\"stage\").style.left+e.target.x()\n    let stageBox=e.target.getStage().attrs.container.getBoundingClientRect();\n    document.getElementById(\"input\").style.top=stageBox.y+e.target.getAbsolutePosition().y+'px';\n    document.getElementById(\"input\").style.left=stageBox.x+e.target.getAbsolutePosition().x-document.getElementById(\"input\").size*5+'px';\n    document.getElementById(\"input\").style.display=\"initial\"\n    this.editedText=e.target\n  },\n  updateText(e){\n    let shape=this.shapes.find(i => i.id ===this.editedText.attrs.id);\n    let isFunded=true;\n    if(shape==undefined){\n      isFunded=false;\n    }\n    let i=0;\n    while(!isFunded){\n      if(i<this.groups.length){\n        shape=this.groups[i].shapes_g.find(i => i.id === this.editedText.attrs.id);\n      if(shape==undefined){\n        isFunded=false;\n      }else{\n        isFunded=true;\n      }\n      i++;\n      }else{        \n        isFunded=true;\n      }\n    }\n    if(shape!=undefined){\n    let last_width;\n    let last_height;\n    let diff_width;\n    let diff_height;\n\n    last_width=this.editedText.width();\n    last_height=this.editedText.height();\n\n    shape.text=e.target.value;\n\n    this.editedText.text(e.target.value);\n    diff_width=this.editedText.width()-last_width;\n    diff_height=this.editedText.height()-last_height;\n\n    \n    shape.offsetX=shape.offsetX+diff_width/2\n    shape.offsetY=shape.offsetY+diff_height/2\n    shape.length_x=this.editedText.width()\n    shape.length_y=this.editedText.height()\n    document.getElementById(\"input\").style.display=\"none\"\n    }\n\n  },\n  updateNaration(grp){\n      let text=\"<strong>Substrate:</strong><br>\"\n      text=text+\"- <mark class='red'> StickyLine </mark> with size=\"+grp.line.points[4]*grp.line.scaleX.toFixed(2)\n      +\"<br> and rotation=\"+grp.line.rotation.toFixed(1)+\"<br>\";\n      text=text+\"Relation: <i>alignement with</i>:\";\n      for(let j=0;j<grp.shapes_g.length;j++){\n        text=text+\"<br>\"+\"- \"+grp.shapes_g[j].className\n      }\n      this.$emit('explain',{origin:\"Instrument - Appropriability<br><mark class='red'> The Stickyline supports user customization to be better adapted to the task. </mark>\",text:text});\n  }\n},\n};\n\n</script>\n<style>\n#playground{\n  cursor: default\n}\n#active{\n  position: absolute;\n  display: none;\n  top: 0px;\n  left: 0px;\n  width: 60px;\n  background-color: white;\n  box-shadow: 0 0 5px grey;\n  border-radius: 3px;\n}\n#center_menu{\n  position: absolute;\n  display: none;\n  top: 0px;\n  left: 0px;\n  width: 60px;\n  background-color: white;\n  box-shadow: 0 0 5px grey;\n  border-radius: 3px;\n}\ninput{\n  position:absolute;\n  display: none;\n  top:0px;\n  left:0px; \n}\n</style> ","import { render } from \"./AppropriabilityDemo.vue?vue&type=template&id=aa31d50a\"\nimport script from \"./AppropriabilityDemo.vue?vue&type=script&lang=js\"\nexport * from \"./AppropriabilityDemo.vue?vue&type=script&lang=js\"\n\nimport \"./AppropriabilityDemo.vue?vue&type=style&index=0&id=aa31d50a&lang=css\"\n\nimport exportComponent from \"/Users/junhangyu/Desktop/PE code/github/teachingApp/node_modules/vue-loader/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render]])\n\nexport default __exports__","<template>\n\n  <div @click=\"HideContextMenu\" id=\"AppropriabilitySubstrateDemo\" @mousedown=\"updateNaration(this.groups[0])\">\n    <!--\n  <ToolBar :height=\"100\" :width=\"400\"\n  @need_new_shape=\"createNewShape\" @eraser_is_selected=\"switchEraseMode\"></ToolBar>\n  -->\n    <v-stage ref=\"stage\" id=\"stage\" :config=\"stageSize\" @dragmove=\"update\" @mousedown=\"handleTransformation\"\n      @touchstart=\"handleTransformation\" @fusion=\"makeGroup\" @contextMenu=\"DisplayContextMenu\">\n      <v-layer ref=\"layer\">\n        <!--\n        see if a group should contain more than one line\n      -->\n        <!--\n      <v-circle :key=\"center.id\" :config=\"center\"/>\n      -->\n        <v-group ref=\"groups\" v-for=\"step in groups\" :key=\"step.id\" :config=\"step\">\n\n\n\n          <v-rect v-for=\"item in step.shapes_g.filter(i => i.className == 'Rect')\" :key=\"item.id\" :config=\"item\"\n            @transformend=\"updateTransformedShape\" @dragend=\"updatePosInGrp($event, step.id)\"\n            @dragmove=\"CheckIfNeedToDetach\" @mouseenter=\"showSelectedShape\" @mouseout=\"unshowSelectedShape\" />\n          <v-circle v-for=\"item in step.shapes_g.filter(i => i.className == 'Circle')\" :key=\"item.id\" :config=\"item\"\n            @transformend=\"updateTransformedShape\" @dragend=\"updatePosInGrp($event, step.id)\"\n            @dragmove=\"CheckIfNeedToDetach\" @mouseenter=\"showSelectedShape\" @mouseout=\"unshowSelectedShape\" />\n\n          <v-image v-for=\"item in step.shapes_g.filter(i => i.className == 'Image')\" :key=\"item.id\" :config=\"item\"\n            @transformend=\"updateTransformedShape\" @dragend=\"updatePosInGrp($event, step.id)\"\n            @dragmove=\"CheckIfNeedToDetach\" @mouseenter=\"showSelectedShape\" @mouseout=\"unshowSelectedShape\" />\n          <v-text v-for=\"item in step.shapes_g.filter(i => i.className == 'Text')\" :key=\"item.id\" :config=\"item\"\n            @transformend=\"updateTransformedShape\" @dragend=\"updatePosInGrp($event, step.id)\"\n            @dragmove=\"CheckIfNeedToDetach\" @mouseenter=\"showSelectedShape\" @mouseout=\"unshowSelectedShape\"\n            @dblclick=\"editText\" />\n          <v-regular-polygon v-for=\"item in step.shapes_g.filter(i => i.className == 'Triangle')\" :key=\"item.id\"\n            :config=\"item\" @transformend=\"updateTransformedShape\" @dragend=\"updatePosInGrp($event, step.id)\"\n            @dragmove=\"CheckIfNeedToDetach\" @mouseenter=\"showSelectedShape\" @mouseout=\"unshowSelectedShape\" />\n          <v-line :key=\"step.line.id\" :config=\"step.line\" @transformend=\"updateTransformedShape\"\n            @dragmove=\"updateGrp($event)\" @mouseout=\"unshowSelectedShape\" @mouseenter=\"showSelectedShape\" />\n          <v-circle v-for=\"item in step.line.positionPoints\" :key=\"item.id\" :config=\"item\"\n            @mouseenter=\"showSelectedShape\" @mouseout=\"unshowSelectedShape\" />\n        </v-group>\n        <v-rect v-for=\"item in shapes.filter(i => i.className == 'Rect')\" :key=\"item.id\" :config=\"item\"\n          @transformend=\"updateTransformedShape\" @dragmove=\"updatePos\" @mouseenter=\"showSelectedShape\"\n          @mouseout=\"unshowSelectedShape\" />\n\n        <v-circle v-for=\"item in shapes.filter(i => i.className == 'Circle')\" :key=\"item.id\" :config=\"item\"\n          @transformend=\"updateTransformedShape\" @dragmove=\"updatePos\" @mouseenter=\"showSelectedShape\"\n          @mouseout=\"unshowSelectedShape\" />\n        <!--\n      <v-image\n        v-for=\"item in shapes.filter(i=>i.className=='Image')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragmove=\"updatePos\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n        />\n     \n      <v-text\n        v-for=\"item in shapes.filter(i=>i.className=='Text')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragmove=\"updatePos\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n        \n        @dblclick=\"editText\"\n        /> \n      -->\n        <v-regular-polygon v-for=\"item in shapes.filter(i => i.className == 'Triangle')\" :key=\"item.id\" :config=\"item\"\n          @transformend=\"updateTransformedShape\" @dragmove=\"updatePos\" @mouseenter=\"showSelectedShape\"\n          @mouseout=\"unshowSelectedShape\" />\n\n\n        <v-transformer v-for=\"item in transformers\" :key=\"item.id\" :config=\"item\" />\n        <v-circle :key=\"center.id\" :config=\"center\" @dragend=\"ChangeCenter\" @click=\"DisplayCenterMenu\" />\n        <!--\n      <v-transformer id=\"shapeTransformer\"/>\n      <v-transformer id=\"lineTransformer\" :config=\"{enabledAnchors: ['middle-left', 'middle-right'],}\" />\n      -->\n      </v-layer>\n\n    </v-stage>\n\n\n    <div id=\"activeReuseSubstrate\">\n      <ContextMenu :menu-of-stage=\"isStageOnlySelected\" :menu-of-line=isALineSelected\n        :menu-of-grouped-shape=isAGroupedShapeSelected :keep-distance-button-text=\"this.keepDistanceButtonText\"\n        :need-copy-button=\"false\" :need-switch-distribution-mode-button=\"true\" :need-copy-all-button=\"false\"\n        @changecenter-button=\"ChangeCenterButtonAction\" @detachshape-button=\"DetachShapeButtonAction\"\n        @keepdistance-button=\"KeepDistribution\" @copy-button=\"Copy\" @copy-all-button=\"CopyAll\" @past-button=\"Past\"\n        @remove-button=\"Remove\" @remove-all-button=\"RemoveAll\" :need-past-button=\"false\"></ContextMenu>\n    </div>\n\n\n    <div id=\"center_menu\">\n      <CenterMenu :defaultAlignment=\"this.selectedShapeAlignment\" @center-button=\"ChangeAlignCenter\"></CenterMenu>\n    </div>\n\n\n    <input type=\"text\" id=\"input\" size=\"10\" value=\"a text\" @keyup.enter=\"updateText\">\n  </div>\n</template>\n\n<script>\n\nimport ContextMenu from \"@/components/interactive-components-for-canvas/ContextMenu.vue\"\nimport CenterMenu from \"@/components/interactive-components-for-canvas/CenterMenu.vue\"\n//import ToolBar from \"./ToolBar.vue\";\n\nconst dragFunc = function (pos) {\n  let width = this.getStage().width();\n  let height = this.getStage().height();\n  let strokeSize = 10\n  if (pos.x > width - strokeSize && pos.y > height - strokeSize) {\n    return {\n      x: width - strokeSize,\n      y: height - strokeSize,\n    }\n  } else if (pos.x > width - strokeSize && pos.y < strokeSize) {\n    return {\n      x: width - strokeSize,\n      y: strokeSize,\n    }\n  } else if (pos.y > height - strokeSize && pos.x < strokeSize) {\n    return {\n      x: strokeSize,\n      y: height - strokeSize,\n    }\n  } else if (pos.x < strokeSize && pos.y < strokeSize) {\n    return {\n      x: strokeSize,\n      y: strokeSize,\n    }\n  } else if (pos.x < strokeSize) {\n    return {\n      x: strokeSize,\n      y: pos.y,\n    }\n  } else if (pos.y < strokeSize) {\n    return {\n      x: pos.x,\n      y: strokeSize,\n    }\n  } else if (pos.x > width - strokeSize) {\n    return {\n      x: width - strokeSize,\n      y: pos.y,\n    }\n  } else if (pos.y > height - strokeSize) {\n    return {\n      x: pos.x,\n      y: height - strokeSize,\n    }\n  } else {\n    return {\n      x: pos.x,\n      y: pos.y,\n    };\n  }\n};\n\n\nexport default {\n  props: {\n    width: {\n      type: Number,\n      default: window.innerWidth,\n    },\n    height: {\n      type: Number,\n      default: window.innerHeight,\n    }\n  },\n  components: {\n    ContextMenu,\n    CenterMenu,\n    //ToolBar,\n  },\n  data() {\n    return {\n      stageSize: {\n        width: this.width,\n        height: this.height,\n      },\n      lengthToCapture: 10,\n      lengthToDetach: 15,\n      editedText: null,\n\n      eraseMode: 0,\n\n      selectedShapeAlignment: '',\n\n      needMenu: 'initial', //say if the context menu has to be \"active\" or not.\n      isALineSelected: false,\n      isAGroupedShapeSelected: false,\n      isStageOnlySelected: false,\n      //dragItemId: null, //id of the item which is dragging.\n      //text which will appear on the button corresponding to the management of the distribution\n      keepDistanceButtonText: \"Keep Distribution\",\n      max_id_figures: 6, //max among id of shapes and line since the canvas exist (line excluded) \n      //max_id_lines: 2, //max among id of lines since the canvas exist (line excluded) \n      //groups of shapes (ie a line with shapes on it)\n\n\n      groups: [{\n        //rotation: 20,\n        name: \"group\",\n        className: \"Group\",\n        id: '1',\n        x: 0,\n        y: 0,\n        offsetX: 0,\n        offsetY: 0,\n        rotation: 0,\n        draggable: false,\n        shapes_g: [{\n          rotation: 0,\n          x: 30,\n          y: 220,\n          scaleX: 1,\n          scaleY: 1,\n          offsetX: 0,\n          offsetY: 40,\n          radius: 40,\n          fill: 'orange',\n          strokeWidth: 0,\n          stroke: 'black',\n          draggable: true,\n          isGrouped: 1,\n          className: \"Circle\",\n          /*When it is on a line, a shape can be rotate by the user independently from the line.\n            To keep the independant rotation of the attached shape, we add the parameter \"personalRotation\".\n            So, when the shape is attached, is final rotation is the sum of this parameter with the rotation of the line.\n            */\n          personalRotation: 0,\n          id: '6',\n          dragBoundFunc: dragFunc,\n          centerPosition: 'Bottom',\n        }, {\n          rotation: 0,\n          id: '8',\n          x: 150,\n          y: 220,\n          width: 70,\n          height: 70,\n          scaleX: 1,\n          scaleY: 1,\n          strokeWidth: 0,\n          stroke: 'black',\n          fill: 'green',\n          name: 'rect2',\n          draggable: true,\n          className: \"Rect\",\n          isGrouped: 0,\n          dragBoundFunc: dragFunc,\n          offsetX: 70 / 2,\n          offsetY: 70,\n          /*When it is on a line, a shape can be rotate by the user independently from the line.\n          To keep the independant rotation of the attached shape, we add the parameter \"personalRotation\".\n          So, when the shape is attached, is final rotation is the sum of this parameter with the rotation of the line.\n          */\n          personalRotation: 0,\n          centerPosition: 'Bottom',\n        }, {\n          rotation: 0,\n          id: '7',\n          x: 250,\n          y: 220,\n          sides: 3,\n          radius: 45,\n          width: 90,\n          height: 90,\n          scaleX: 1,\n          scaleY: 1,\n          strokeWidth: 0,\n          stroke: 'black',\n          fill: 'purple',\n          name: 'triangle1',\n          draggable: true,\n          className: \"Triangle\",\n          isGrouped: 0,\n          dragBoundFunc: dragFunc,\n          offsetX: 0,\n          offsetY: 22.5,\n          personalRotation: 0,\n          centerPosition: 'Bottom',\n        },], //list of shapes that are on the line\n        //the line of the group:\n        aShapeHasBeenDetach: 0,\n        line: {\n          x: 150,\n          y: 220,\n          points: [0, 0, 0, 0, 250, 0],\n          positionPoints: [{\n            x: 300,\n            y: 500,\n            scaleX: 1,\n            scaleY: 1,\n            offsetX: 0,\n            offsetY: 0,\n            radius: 3,\n            fill: 'yellow',\n            opacity: 1,\n            draggable: false,\n            isGrouped: 0,\n            className: \"positionPoint\",\n            id: 'positionPoint1',\n            distance_to_line_center: undefined,\n          }, {\n            x: 300,\n            y: 500,\n            scaleX: 1,\n            scaleY: 1,\n            offsetX: 0,\n            offsetY: 0,\n            radius: 3,\n            fill: 'yellow',\n            opacity: 1,\n            draggable: false,\n            isGrouped: 0,\n            className: \"positionPoint\",\n            id: 'positionPoint2',\n            distance_to_line_center: undefined,\n          }, {\n            x: 300,\n            y: 500,\n            scaleX: 1,\n            scaleY: 1,\n            offsetX: 0,\n            offsetY: 0,\n            radius: 3,\n            fill: 'yellow',\n            opacity: 1,\n            draggable: false,\n            isGrouped: 0,\n            className: \"positionPoint\",\n            id: 'positionPoint3',\n            distance_to_line_center: undefined,\n          },],\n          strokeWidth: 10,\n          rotation: 0,\n          tension: 0,\n          closed: true,\n          draggable: true,\n          scaleX: 1,\n          scaleY: 1,\n          opacity: 0.5,\n          offset: {\n            x: 125,\n            y: 0,\n          },\n          name: \"ligne\",\n          className: \"Line\",\n          stroke: 'blue',\n          id: '1',\n          //distShapesToCenter:[],\n          keepDistribution: false, //say of we keep the distribution on the line or not\n          freeDistances: [], // distance that can be taken by other shapes (if we keep distribution on the line).\n          occupiedDistances: [-95, -15, 100], //distance already \"taken\" by shapes on the line.       \n          //text which will appear on the button corresponding to the management of the distribution:\n          keepDistanceButtonText: \"Keep Distribution\",\n          //function which determine how the line can be dragged:\n          defaultAlignment: \"Bottom\",\n          dragBoundFunc: dragFunc,\n        },\n      },\n        /*{\n          name: \"group2\",\n          className: \"Group\",\n          id: '7',\n          x:0,\n          y:0,\n          offsetX:0,\n          offsetY:0,\n          rotation: 0,\n          draggable: false,\n          shapes_g:[],\n          line:{\n          x:500,\n          y:300,\n          points: [0, 0, 0, 0, 300, 0],\n          positionPoints:[],\n          strokeWidth: 10,\n          rotation: 0,\n          tension:0,\n          closed: true,\n          draggable: true,\n          scaleX:1,\n          scaleY:1,\n          opacity:0.5,\n          offset:{\n            x:150,\n            y:0,\n          },\n          //draggable:true,\n          name: \"ligne\",\n          className: \"Line\",\n          stroke: 'black',\n          id:'7',\n          distShapesToCenter:[],\n          keepDistribution: true,\n          freeDistances:[],\n          occupiedDistances:[],\n          keepDistanceButtonText:\"Liberate Distribution\",\n          defaultAlignment:\"Middle\",\n          dragBoundFunc: dragFunc,\n        },\n        \n        }*/\n      ],\n      transformers: [\n        {\n          id: 'lineTransformer',\n          enabledAnchors: ['middle-left', 'middle-right'],\n          flipEnabled: false, // in order to not have a rotation of the transformer which lead to problem related to shapes position on a line\n          nodes: [],\n\n        },\n        {\n          id: 'shapeTransformer',\n          nodes: [],\n        }\n      ],\n      shapes: [],\n      center: {\n        x: 300,\n        y: 500,\n        scaleX: 1,\n        scaleY: 1,\n        offsetX: 0,\n        offsetY: 0,\n        radius: 4,\n        fill: 'black',\n        opacity: 1,\n        draggable: true,\n        isGrouped: 0,\n        className: \"Circle\",\n        id: 'center',\n        dragBoundFunc: dragFunc,\n      },\n      positionPoint: {\n        x: 300,\n        y: 500,\n        scaleX: 1,\n        scaleY: 1,\n        offsetX: 0,\n        offsetY: 0,\n        radius: 3,\n        fill: 'yellow',\n        opacity: 1,\n        draggable: false,\n        isGrouped: 0,\n        className: \"positionPoint\",\n        id: 'positionPoint',\n        distance_to_line_center: undefined,\n      },\n      selectedShapeId: '',\n    };\n  },\n  mounted() {\n    let texts = this.$refs.stage.getStage().getChildren()[0].getChildren().filter((r) => r.attrs.className == 'Text');\n\n\n    for (let i = 0; i < texts.length; i++) {\n      texts[i].attrs.length_x = texts[i].width();\n      texts[i].attrs.length_y = texts[i].height();\n      texts[i].offsetX(texts[i].attrs.length_x / 2);\n    }\n    let grp = this.groups[0];\n    let line = grp.line;\n    let shapes_g = grp.shapes_g;\n    for (let i = 0; i < shapes_g.length; i++) {\n      this.updateDragFunc(shapes_g[i], line);\n\n      this.updateAllPosInGrp(grp.id);\n    }\n  },\n  created() {\n    //nb of shapes on the canvas (line excluded), we consider that there is no shape on line:\n    this.max_id_figures = this.shapes.length + this.groups.length;\n    //this.max_id_lines=this.groups.length;\n    /*\n    const image = new window.Image();\n    image.src = require(\"@/assets/exsitu.png\");\n    // set image only when it is loaded\n    image.height=150;\n    image.width=150;\n    image.onload = () => {\n      this.shapes.find((r)=>r.className===\"Image\").image= image;\n      this.shapes.find((r)=>r.className===\"Image\").offsetX=image.width/2;\n      this.shapes.find((r)=>r.className===\"Image\").offsetY=0; \n    };\n    */\n\n\n  },\n  methods: {\n\n    switchEraseMode() {\n      if (this.eraseMode == 0) {\n        this.eraseMode = 1;\n        document.getElementById(\"playground\").style.cursor = 'url(' + require('@/assets/ugly_eraser.png') + '),default';\n\n        this.eraseNodefromTransformer(\"shapeTransformer\");\n        this.eraseNodefromTransformer(\"lineTransformer\");\n      } else {\n        this.eraseMode = 0;\n        document.getElementById(\"playground\").style.cursor = \"default\";\n      }\n    },\n    /*\n    Check if all shapes that are supposed to be on a line still in this line.\n    id_grp is the id of the group which contains the line.\n    */\n    checkIfShapesOnLine(id_grp) {\n      const grp = this.groups.find((r) => r.id === id_grp);\n      const line = grp.line;\n      const groupedShapes = grp.shapes_g;\n      //const lengthToDetach=10;\n\n      /*\n      To determine if a shape is on a line, we see if the point is not on the corresponding\n      straight line y=a*x+b regarding certains intervals for x and y.Those intervals depends of the rotation of\n      the line. \n      */\n      /*\n       let coord_y1=line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n       let coord_x1=line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n       let coord_y2= line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n       let coord_x2=line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n       let a=(coord_y1-coord_y2)/(coord_x2-coord_x1);\n       let b=line.y-a*line.x;\n       let is_on_straight_line=false;\n       */\n\n      let i = 0;\n      while (i < groupedShapes.length) {\n        /*\n        if(Math.abs(coord_x1-coord_x2)>1){\n        is_on_straight_line=(Math.abs(a*groupedShapes[i].x+b-groupedShapes[i].y)<this.lengthToDetach);\n      }else{\n        is_on_straight_line=(Math.abs(groupedShapes[i].x-line.x)<this.lengthToDetach);\n      }\n        if (\n          !(is_on_straight_line)\n        ||((line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].y\n        ||line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].y)\n        && ((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n        ||((line.x+line.points[4]*line.scaleX*(1/2)*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].x\n        ||line.x-line.points[4]*line.scaleX*(1/2)*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].x)\n        &&((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n        ||((line.y+line.points[4]*line.scaleX*(1/2)*Math.sin(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].y\n        ||line.y-line.points[4]*line.scaleX*(1/2)*Math.sin(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].y)\n        &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>=-Math.PI)))\n\n        ||((line.x+line.points[4]*line.scaleX*(1/2)*Math.cos(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].x\n        ||line.x-line.points[4]*line.scaleX*(1/2)*Math.cos(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].x)\n        &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>=-Math.PI)))\n\n        ||((line.y+line.points[4]*line.scaleX*(1/2)*Math.sin(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].y\n        ||line.y-line.points[4]*line.scaleX*(1/2)*Math.sin(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].y)\n        &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n        ||((line.x+line.points[4]*line.scaleX*(1/2)*Math.cos(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].x\n        ||line.x-line.points[4]*line.scaleX*(1/2)*Math.cos(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].x)\n        &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n        ||((line.y+line.points[4]*line.scaleX*(1/2)*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].y\n        ||line.y-line.points[4]*line.scaleX*(1/2)*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].y)\n        &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>0)))\n\n        ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].x\n        ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].x)\n        &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>0)))\n        )\n        */\n        if (!this.isCoordinateOnLine(groupedShapes[i].x, groupedShapes[i].y, line.id)) {\n          console.log(\"a shape is not on a line\");\n          groupedShapes[i].dragBoundFunc = dragFunc;\n          groupedShapes[i].isGrouped = 0;\n\n          this.shapes.push(groupedShapes[i],)\n          line.freeDistances.push(line.occupiedDistances[i]);\n          line.occupiedDistances.splice(i, 1);\n          groupedShapes.splice(i, 1);\n\n          this.updateNaration(grp)\n        } else {\n          i = i + 1;\n        }\n      }\n    },\n\n    //say of {x,y} is a point from the line\n    isCoordinateOnLine(x, y, id_grp) {\n      const grp = this.groups.find((r) => r.id === id_grp);\n      const line = grp.line;\n      let is_not_on_straight_line = true;\n      let coord_y1 = line.y - line.points[4] * (1 / 2) * line.scaleX * Math.sin(line.rotation * (Math.PI / 180));\n      let coord_x1 = line.x + line.points[4] * (1 / 2) * line.scaleX * Math.cos(line.rotation * (Math.PI / 180));\n      let coord_y2 = line.y + line.points[4] * (1 / 2) * line.scaleX * Math.sin(line.rotation * (Math.PI / 180));\n      let coord_x2 = line.x - line.points[4] * (1 / 2) * line.scaleX * Math.cos(line.rotation * (Math.PI / 180));\n      let a = (coord_y1 - coord_y2) / (coord_x2 - coord_x1);\n      let b = line.y - a * line.x;\n      if (Math.abs(coord_x1 - coord_x2) > 1) {\n        is_not_on_straight_line = (Math.abs(a * x + b - y) > 1);\n      } else {\n        is_not_on_straight_line = (Math.abs(x - line.x) > 1)\n      }\n      if (\n        (is_not_on_straight_line)\n\n        || ((line.y - line.points[4] * (1 / 2) * line.scaleX * Math.sin(line.rotation * (Math.PI / 180)) + this.lengthToDetach < y\n          || line.y + line.points[4] * (1 / 2) * line.scaleX * Math.sin(line.rotation * (Math.PI / 180)) - this.lengthToDetach > y)\n          && ((line.rotation * (Math.PI / 180) <= 0 && line.rotation * (Math.PI / 180) > -Math.PI / 2)))\n\n        || ((line.x + line.points[4] * (1 / 2) * line.scaleX * Math.cos(line.rotation * (Math.PI / 180)) + this.lengthToDetach < x\n          || line.x - line.points[4] * (1 / 2) * line.scaleX * Math.cos(line.rotation * (Math.PI / 180)) - this.lengthToDetach > x)\n          && ((line.rotation * (Math.PI / 180) <= 0 && line.rotation * (Math.PI / 180) > -Math.PI / 2)))\n\n        || ((line.y + line.points[4] * (1 / 2) * line.scaleX * Math.sin(Math.PI + line.rotation * (Math.PI / 180)) + this.lengthToDetach < y\n          || line.y - line.points[4] * (1 / 2) * line.scaleX * Math.sin(Math.PI + line.rotation * (Math.PI / 180)) - this.lengthToDetach > y)\n          && ((line.rotation * (Math.PI / 180) <= -Math.PI / 2 && line.rotation * (Math.PI / 180) > -Math.PI)))\n\n        || ((line.x + line.points[4] * (1 / 2) * line.scaleX * Math.cos(Math.PI + line.rotation * (Math.PI / 180)) + this.lengthToDetach < x\n          || line.x - line.points[4] * (1 / 2) * line.scaleX * Math.cos(Math.PI + line.rotation * (Math.PI / 180)) - this.lengthToDetach > x)\n          && ((line.rotation * (Math.PI / 180) <= -Math.PI / 2 && line.rotation * (Math.PI / 180) > -Math.PI)))\n\n        || ((line.y + line.points[4] * (1 / 2) * line.scaleX * Math.sin(Math.PI - line.rotation * (Math.PI / 180)) + this.lengthToDetach < y\n          || line.y - line.points[4] * (1 / 2) * line.scaleX * Math.sin(Math.PI - line.rotation * (Math.PI / 180)) - this.lengthToDetach > y)\n          && ((line.rotation * (Math.PI / 180) <= Math.PI && line.rotation * (Math.PI / 180) > Math.PI / 2)))\n\n        || ((line.x + line.points[4] * (1 / 2) * line.scaleX * Math.cos(Math.PI - line.rotation * (Math.PI / 180)) + this.lengthToDetach < x\n          || line.x - line.points[4] * (1 / 2) * line.scaleX * Math.cos(Math.PI - line.rotation * (Math.PI / 180)) - this.lengthToDetach > x)\n          && ((line.rotation * (Math.PI / 180) <= Math.PI && line.rotation * (Math.PI / 180) > Math.PI / 2)))\n\n        || ((line.y + line.points[4] * (1 / 2) * line.scaleX * Math.sin(line.rotation * (Math.PI / 180)) + this.lengthToDetach < y\n          || line.y - line.points[4] * (1 / 2) * line.scaleX * Math.sin(line.rotation * (Math.PI / 180)) - this.lengthToDetach > y)\n          && ((line.rotation * (Math.PI / 180) <= Math.PI / 2 && line.rotation * (Math.PI / 180) >= 0)))\n\n        || ((line.x + line.points[4] * (1 / 2) * line.scaleX * Math.cos(line.rotation * (Math.PI / 180)) + this.lengthToDetach < x\n          || line.x - line.points[4] * (1 / 2) * line.scaleX * Math.cos(line.rotation * (Math.PI / 180)) - this.lengthToDetach > x)\n          && ((line.rotation * (Math.PI / 180) <= Math.PI / 2 && line.rotation * (Math.PI / 180) >= 0)))\n\n        || (!is_not_on_straight_line && Math.sqrt((line.x - x) ** 2 + (line.y - y) ** 2) > line.points[4] * line.scaleX / 2)\n\n\n\n\n      ) {\n        return false;\n      } else {\n        return true;\n      }\n    },\n\n    //update a group with the id id_grp\n    updateGrp(e) {\n      let id_grp = e.target.attrs.id\n      const grep = this.groups.find((r) => r.id === id_grp);\n      const line = grep.line;\n      grep.offsetX = line.offsetX;\n      grep.offsetY = line.offsetY;\n\n      line.x = e.target.x();\n      line.y = e.target.y();\n      this.center.x = line.x;\n      this.center.y = line.y;\n      /*\n      if(line.keepDistribution){\n        this.updateOccupiedDistance(line.id);\n      }\n      */\n      this.updateAllPosInGrp(line.id);\n      this.checkIfShapesOnLine(line.id);\n    },\n\n\n    //update the position of all shapes that are on the line of the group with the id id_grp.\n    updateAllPosInGrp(id_grp) {\n      const grp = this.groups.find((r) => r.id === id_grp);\n      const line = grp.line;\n      const shapes_g = grp.shapes_g;\n      for (let i = 0; i < shapes_g.length; i++) {\n        if (line.keepDistribution) {\n          shapes_g[i].x = line.x + line.occupiedDistances[i] * Math.cos(line.rotation * (Math.PI / 180));\n          shapes_g[i].y = line.y + line.occupiedDistances[i] * Math.sin(line.rotation * (Math.PI / 180));\n          shapes_g[i].distance_to_line_center = line.occupiedDistances[i];\n          shapes_g[i].rotation = shapes_g[i].personalRotation + line.rotation;\n\n        } else {\n          shapes_g[i].x = line.x + line.occupiedDistances[i] * Math.cos(line.rotation * (Math.PI / 180));\n          shapes_g[i].y = line.y + line.occupiedDistances[i] * Math.sin(line.rotation * (Math.PI / 180));\n          shapes_g[i].distance_to_line_center = line.occupiedDistances[i];\n          shapes_g[i].rotation = shapes_g[i].personalRotation + line.rotation;\n        }\n        line.positionPoints[i].x = shapes_g[i].x;\n        line.positionPoints[i].y = shapes_g[i].y;\n        line.positionPoints[i].distance_to_line_center = shapes_g[i].distance_to_line_center;\n      }\n      let i = shapes_g.length;\n      while (i < line.positionPoints.length) {\n        if (line.keepDistribution) {\n          line.positionPoints.splice(i, 1);\n        } else {\n          line.positionPoints[i].x = line.x + line.freeDistances[i - shapes_g.length] * Math.cos(line.rotation * (Math.PI / 180));\n          line.positionPoints[i].y = line.y + line.freeDistances[i - shapes_g.length] * Math.sin(line.rotation * (Math.PI / 180));\n          line.positionPoints[i].distance_to_line_center = line.freeDistances[i - shapes_g.length];\n          i++;\n        }\n\n      }\n\n    },\n    isOutsideTheLine(shape, line) {\n      let coord_y1 = line.y - line.points[4] * (1 / 2) * line.scaleX * Math.sin(line.rotation * (Math.PI / 180));\n      let coord_x1 = line.x + line.points[4] * (1 / 2) * line.scaleX * Math.cos(line.rotation * (Math.PI / 180));\n      let coord_y2 = line.y + line.points[4] * (1 / 2) * line.scaleX * Math.sin(line.rotation * (Math.PI / 180));\n      let coord_x2 = line.x - line.points[4] * (1 / 2) * line.scaleX * Math.cos(line.rotation * (Math.PI / 180));\n      let a = (coord_y1 - coord_y2) / (coord_x2 - coord_x1);\n      let b = line.y - a * line.x;\n      let is_on_straight_line = false;\n      if (Math.abs(coord_x1 - coord_x2) >= 1) {\n        is_on_straight_line = (Math.abs(a * shape.x + b - shape.y) < 1);\n      } else {\n        is_on_straight_line = (Math.abs(shape.x - line.x) < 1);\n      }\n      if (\n        !(is_on_straight_line)\n        || ((line.y - line.points[4] * (1 / 2) * line.scaleX * Math.sin(line.rotation * (Math.PI / 180)) + this.lengthToDetach < shape.y\n          || line.y + line.points[4] * (1 / 2) * line.scaleX * Math.sin(line.rotation * (Math.PI / 180)) - this.lengthToDetach > shape.y)\n          && ((line.rotation * (Math.PI / 180) <= 0 && line.rotation * (Math.PI / 180) > -Math.PI / 2)))\n\n        || ((line.x + line.points[4] * (1 / 2) * line.scaleX * Math.cos(line.rotation * (Math.PI / 180)) + this.lengthToDetach < shape.x\n          || line.x - line.points[4] * (1 / 2) * line.scaleX * Math.cos(line.rotation * (Math.PI / 180)) - this.lengthToDetach > shape.x)\n          && ((line.rotation * (Math.PI / 180) <= 0 && line.rotation * (Math.PI / 180) > -Math.PI / 2)))\n\n        || ((line.y + line.points[4] * (1 / 2) * line.scaleX * Math.sin(Math.PI + line.rotation * (Math.PI / 180)) + this.lengthToDetach < shape.y\n          || line.y - line.points[4] * (1 / 2) * line.scaleX * Math.sin(Math.PI + line.rotation * (Math.PI / 180)) - this.lengthToDetach > shape.y)\n          && ((line.rotation * (Math.PI / 180) <= -Math.PI / 2 && line.rotation * (Math.PI / 180) > -Math.PI)))\n\n        || ((line.x + line.points[4] * (1 / 2) * line.scaleX * Math.cos(Math.PI + line.rotation * (Math.PI / 180)) + this.lengthToDetach < shape.x\n          || line.x - line.points[4] * (1 / 2) * line.scaleX * Math.cos(Math.PI + line.rotation * (Math.PI / 180)) - this.lengthToDetach > shape.x)\n          && ((line.rotation * (Math.PI / 180) <= -Math.PI / 2 && line.rotation * (Math.PI / 180) > -Math.PI)))\n\n        || ((line.y + line.points[4] * (1 / 2) * line.scaleX * Math.sin(Math.PI - line.rotation * (Math.PI / 180)) + this.lengthToDetach < shape.y\n          || line.y - line.points[4] * (1 / 2) * line.scaleX * Math.sin(Math.PI - line.rotation * (Math.PI / 180)) - this.lengthToDetach > shape.y)\n          && ((line.rotation * (Math.PI / 180) <= Math.PI && line.rotation * (Math.PI / 180) > Math.PI / 2)))\n\n        || ((line.x + line.points[4] * (1 / 2) * line.scaleX * Math.cos(Math.PI - line.rotation * (Math.PI / 180)) + this.lengthToDetach < shape.x\n          || line.x - line.points[4] * (1 / 2) * line.scaleX * Math.cos(Math.PI - line.rotation * (Math.PI / 180)) - this.lengthToDetach > shape.x)\n          && ((line.rotation * (Math.PI / 180) <= Math.PI && line.rotation * (Math.PI / 180) > Math.PI / 2)))\n\n        || ((line.y + line.points[4] * (1 / 2) * line.scaleX * Math.sin(line.rotation * (Math.PI / 180)) + this.lengthToDetach < shape.y\n          || line.y - line.points[4] * (1 / 2) * line.scaleX * Math.sin(line.rotation * (Math.PI / 180)) - this.lengthToDetach > shape.y)\n          && ((line.rotation * (Math.PI / 180) <= Math.PI / 2 && line.rotation * (Math.PI / 180) >= 0)))\n\n        || ((line.x + line.points[4] * (1 / 2) * line.scaleX * Math.cos(line.rotation * (Math.PI / 180)) + this.lengthToDetach < shape.x\n          || line.x - line.points[4] * (1 / 2) * line.scaleX * Math.cos(line.rotation * (Math.PI / 180)) - this.lengthToDetach > shape.x)\n          && ((line.rotation * (Math.PI / 180) <= Math.PI / 2 && line.rotation * (Math.PI / 180) >= 0)))\n      ) {\n        return true;\n      } else { return false }\n    },\n\n    //update the canvas\n    update() {\n      const shapes = this.shapes\n\n      //const lengthToCapture=10; //bigger is the number, bigger is the intervals of x and y where a shape can be added to a line.\n      let is_on_straight_line = false;\n      for (let i = 0; i < shapes.length; i++) {\n        let x = shapes[i].x;\n        let y = shapes[i].y;\n        for (let j = 0; j < this.groups.length; j++) {\n\n          let line = this.groups[j].line;\n\n\n          let coord_y1 = line.y - line.points[4] * (1 / 2) * line.scaleX * Math.sin(line.rotation * (Math.PI / 180));\n          let coord_x1 = line.x + line.points[4] * (1 / 2) * line.scaleX * Math.cos(line.rotation * (Math.PI / 180));\n          let coord_y2 = line.y + line.points[4] * (1 / 2) * line.scaleX * Math.sin(line.rotation * (Math.PI / 180));\n          let coord_x2 = line.x - line.points[4] * (1 / 2) * line.scaleX * Math.cos(line.rotation * (Math.PI / 180));\n          let a = (coord_y1 - coord_y2) / (coord_x2 - coord_x1);\n          let b = line.y - a * line.x;\n          if (Math.abs(coord_x1 - coord_x2) > 1) {\n            is_on_straight_line = (Math.abs(a * x + b - y) <= this.lengthToCapture);\n          } else {\n            is_on_straight_line = (Math.abs(x - line.x) <= this.lengthToCapture);\n            //is_on_straight_line=true;\n          }\n          if (\n            (\n              is_on_straight_line\n              && (line.y - line.points[4] * (1 / 2) * line.scaleX * Math.sin(line.rotation * (Math.PI / 180)) + this.lengthToCapture >= y\n                && line.y + line.points[4] * (1 / 2) * line.scaleX * Math.sin(line.rotation * (Math.PI / 180)) - this.lengthToCapture <= y)\n              && (line.x + line.points[4] * (1 / 2) * line.scaleX * Math.cos(line.rotation * (Math.PI / 180)) + this.lengthToCapture >= x\n                && line.x - line.points[4] * (1 / 2) * line.scaleX * Math.cos(line.rotation * (Math.PI / 180)) - this.lengthToCapture <= x)\n              && (line.rotation * (Math.PI / 180) <= 0\n                && line.rotation * (Math.PI / 180) > -Math.PI / 2))\n\n            || (\n              is_on_straight_line\n              && (line.y + line.points[4] * (1 / 2) * line.scaleX * Math.sin(Math.PI + line.rotation * (Math.PI / 180)) + this.lengthToCapture >= y\n                && line.y - line.points[4] * (1 / 2) * line.scaleX * Math.sin(Math.PI + line.rotation * (Math.PI / 180)) - this.lengthToCapture <= y)\n              && (line.x + line.points[4] * (1 / 2) * line.scaleX * Math.cos(Math.PI + line.rotation * (Math.PI / 180)) + this.lengthToCapture >= x\n                && line.x - line.points[4] * (1 / 2) * line.scaleX * Math.cos(Math.PI + line.rotation * (Math.PI / 180)) - this.lengthToCapture <= x)\n              && (line.rotation * (Math.PI / 180) <= -Math.PI / 2\n                && line.rotation * (Math.PI / 180) >= -Math.PI))\n\n            || (\n              is_on_straight_line\n              && (line.y + line.points[4] * (1 / 2) * line.scaleX * Math.sin(Math.PI - line.rotation * (Math.PI / 180)) + this.lengthToCapture >= y\n                && line.y - line.points[4] * (1 / 2) * line.scaleX * Math.sin(Math.PI - line.rotation * (Math.PI / 180)) - this.lengthToCapture <= y)\n              && (line.x + line.points[4] * (1 / 2) * line.scaleX * Math.cos(Math.PI - line.rotation * (Math.PI / 180)) + this.lengthToCapture >= x\n                && line.x - line.points[4] * (1 / 2) * line.scaleX * Math.cos(Math.PI - line.rotation * (Math.PI / 180)) - this.lengthToCapture <= x)\n              && (line.rotation * (Math.PI / 180) <= Math.PI\n                && line.rotation * (Math.PI / 180) > Math.PI / 2))\n\n            || (\n              is_on_straight_line\n              && (line.y + line.points[4] * (1 / 2) * line.scaleX * Math.sin(line.rotation * (Math.PI / 180)) + this.lengthToCapture >= y\n                && line.y - line.points[4] * (1 / 2) * line.scaleX * Math.sin(line.rotation * (Math.PI / 180)) - this.lengthToCapture <= y)\n              && (line.x + line.points[4] * (1 / 2) * line.scaleX * Math.cos(line.rotation * (Math.PI / 180)) + this.lengthToCapture >= x\n                && line.x - line.points[4] * (1 / 2) * line.scaleX * Math.cos(line.rotation * (Math.PI / 180)) - this.lengthToCapture <= x)\n              && (line.rotation * (Math.PI / 180) <= Math.PI / 2\n                && line.rotation * (Math.PI / 180) >= 0))\n          ) {\n            shapes[i].isGrouped = 1;\n            this.makeGroup(line.id);\n          }\n        }\n      }\n    },\n\n    CheckIfNeedToDetach(e) {\n      let grp = this.groups.find((r) => r.id === e.target.getParent().attrs.id);\n      let shape = grp.shapes_g.find((r) => r.id == e.target.id());\n      let dist = Math.sqrt((e.target.getStage().getPointerPosition().y - e.target.y()) ** 2 + (e.target.getStage().getPointerPosition().x - e.target.x()) ** 2);\n      if (e.target.className == \"Rect\") {\n        dist -= e.target.attrs.height * e.target.attrs.scaleY;\n      } else if (e.target.className == \"Circle\") {\n        dist -= (2 * e.target.attrs.radius) * e.target.attrs.scaleY;\n      } else if (e.target.className == \"Text\") {\n        dist -= e.target.attrs.length_y * e.target.attrs.scaleY;\n      } else if (e.target.className == \"Image\") {\n        dist -= e.target.height() * e.target.scaleY();\n      } else if (e.target.attrs.className == \"Triangle\") {\n        dist -= e.target.height() * e.target.scaleY();\n      }\n\n      if (dist > 50) {\n        //let shape= this.groups.find((r)=>r.id===e.target.getParent().attrs.id).shapes_g.find((r)=>r.id==e.target.id());\n        //this.groups.find((r)=>r.id===e.target.getParent().attrs.id).shapes_g.find((r)=>r.id==e.target.id()).needToBeDetach=1;\n        /*\n        shape.dragBoundFunc= function (pos) {\n              return {\n                x: pos.x,\n                y: pos.y,\n              };\n        }\n        */\n        //shape.x=e.target.getStage().getPointerPosition().x;\n        //shape.y=e.target.getStage().getPointerPosition().y;\n        //if (Math.abs(e.target.getStage().getPointerPosition().y-e.target.y())>220){\n\n        //shape.x=e.target.getStage().getPointerPosition().x;\n        //shape.y=e.target.getStage().getPointerPosition().y;\n        this.groups.find((r) => r.id === e.target.getParent().attrs.id).aShapeHasBeenDetach = 1;\n        this.DetachShape(shape, e.target.getStage().getPointerPosition().x, e.target.getStage().getPointerPosition().y);\n\n\n\n\n      }\n    },\n\n    //Give the sign of the distance of shape from the center of a line.\n    GiveSignOfDistance(shape, line) {\n      let result;\n      let angle = line.rotation * (Math.PI / 180);\n      let distX = shape.x - line.x;\n      let distY = shape.y - line.y;\n      /*\n      \n      if(angle<=-Math.PI/4 || angle>=-Math.PI/2){\n        result=-Math.sign(distY);\n      }\n      else if(angle<=-Math.PI/2 || angle>=-3*Math.PI/4){\n        result=Math.sign(distY);\n      }\n      else if(angle<=-3*Math.PI/4 || angle>=-Math.PI){\n        result=-Math.sign(distX);\n      }else if(angle>=3*Math.PI/4 || angle<=Math.PI){\n        result=Math.sign(distX);\n      }else if(angle>=Math.PI/2 || angle<3*Math.PI/4){\n        result=-Math.sign(distY);\n      } else if(angle<=Math.PI/2 || angle>Math.PI/4){\n        result=-Math.sign(distY);\n      } else if(angle<=Math.PI/4 || angle>=0){\n        result=Math.sign(distX);\n      }\n      */\n\n\n      if (Math.abs(distX) <= this.lengthToCapture && line.rotation == -90) {\n\n        result = -Math.sign(distY);\n      } else if (Math.abs(distX) <= this.lengthToCapture && line.rotation == 90) {\n        result = Math.sign(distY);\n      }\n      else {\n        result = Math.sign(distX);\n      }\n      if (angle < -Math.PI / 2 || angle > Math.PI / 2) {\n        result = -result;\n      }\n\n      return result;\n    },\n\n    //Different from the previous function bcs the straight line of the center is perdendicular to the line\n    GiveSignOfDistanceBtwCenterAndShape(center, shape) {\n      let result;\n      let angle = shape.rotation * (Math.PI / 180);\n      let distX = center.x - shape.x;\n      let distY = center.y - shape.y;\n      /*\n      \n      if(angle<=-Math.PI/4 || angle>=-Math.PI/2){\n        result=-Math.sign(distY);\n      }\n      else if(angle<=-Math.PI/2 || angle>=-3*Math.PI/4){\n        result=Math.sign(distY);\n      }\n      else if(angle<=-3*Math.PI/4 || angle>=-Math.PI){\n        result=-Math.sign(distX);\n      }else if(angle>=3*Math.PI/4 || angle<=Math.PI){\n        result=Math.sign(distX);\n      }else if(angle>=Math.PI/2 || angle<3*Math.PI/4){\n        result=-Math.sign(distY);\n      } else if(angle<=Math.PI/2 || angle>Math.PI/4){\n        result=-Math.sign(distY);\n      } else if(angle<=Math.PI/4 || angle>=0){\n        result=Math.sign(distX);\n      }\n      */\n\n\n      if (Math.abs(distY) <= this.lengthToCapture && shape.rotation == -90) {\n\n        result = Math.sign(distX);\n      } else if (Math.abs(distY) <= this.lengthToCapture && shape.rotation == 90) {\n        result = -Math.sign(distX);\n      }\n      else {\n        result = Math.sign(distY);\n      }\n      if (angle < -Math.PI / 2 || angle > Math.PI / 2) {\n        result = -result;\n      }\n\n      return result;\n    },\n\n    /*add shapes with isGrouped==1 to the group with the id id_grp.\n    */\n    makeGroup(id_grp) {\n      this.eraseNodefromTransformer(\"shapeTransformer\");\n      this.eraseNodefromTransformer(\"lineTransformer\");\n      const grp = this.groups.find((r) => r.id === id_grp);\n      const line = grp.line;\n      const shapes = this.shapes;\n      line.freeDistances.sort(this.isSmaller); //we will give the shortest available distance to the added shape\n      shapes.sort(this.isBeforeRegardingX);\n      for (let i = 0; i < shapes.length; i++) {\n        if (shapes[i].isGrouped == 1) {\n          const positionPoint = Object.assign({}, this.positionPoint);\n          let distX = shapes[i].x - line.x;\n          let distY = shapes[i].y - line.y;\n          shapes[i].personalRotation = 0;\n          //let pot_dist=this.GiveSignOfDistance(shapes[i],line)*Math.sqrt((distX)**2+(distY)**2);\n          /*\n          if(line.keepDistribution && line.freeDistances.length>0){\n          let distances=line.freeDistances+line.occupiedDistances;\n          console.log(distances);\n           let freeDistance=this.isNearest(line.freeDistances,pot_dist);\n           //shapes[i].distance_to_line_center=freeDistance.res; \n           shapes[i].distance_to_line_center=this.GiveSignOfDistance(shapes[i],line)*Math.sqrt((distX)**2+(distY)**2);\n            \n           line.occupiedDistances.push(shapes[i].distance_to_line_center,);\n           line.freeDistances.splice(freeDistance.indice,1);\n\n          } else{\n            */\n          //let distX=shapes[i].x-line.x;\n          //let distY=shapes[i].y-line.y;\n          shapes[i].distance_to_line_center = this.GiveSignOfDistance(shapes[i], line) * Math.sqrt((distX) ** 2 + (distY) ** 2);\n          /*If the distance is a little bit to far from the center \n          we adjust it so that the shape can be at one of the border of the stickyline*/\n          if (Math.abs(shapes[i].distance_to_line_center) >= line.points[4] * line.scaleX / 2) {\n            shapes[i].distance_to_line_center = Math.sign(shapes[i].distance_to_line_center) * line.points[4] * line.scaleX / 2\n          }\n\n          this.ChangeCenterRegardingCommand(shapes[i].id, grp.line.defaultAlignment);\n          if (!line.keepDistribution && line.freeDistances.length > 0) {\n            let indice = this.isNearest(line, shapes[i]);\n            //console.log(indice);\n            //shapes[i].distance_to_line_center=line.freeDistances[indice];\n            //line.freeDistances.splice(indice,1);\n            //shapes[i].isGrouped=0;\n            this.updateDragFunc(shapes[i], line);\n            grp.shapes_g.push(shapes[i],);\n            grp.line.occupiedDistances.push(grp.line.freeDistances[indice]);\n            grp.line.freeDistances.splice(indice, 1);\n            //this.updateOccupiedDistance(grp.line.id);\n\n          } else {\n            //shapes[i].isGrouped=0;\n            this.updateDragFunc(shapes[i], line);\n            grp.shapes_g.push(shapes[i],);\n            console.log(\"no 'free distance' anymore\")\n            grp.line.occupiedDistances.push(shapes[i].distance_to_line_center,);\n            positionPoint.id = \"positionPoint\" + grp.id + grp.line.positionPoints.length;\n            grp.line.positionPoints.push(positionPoint,);\n\n            //shapes[i].distance_to_line_center=this.GiveSignOfDistance(shapes[i],line)*Math.sqrt((distX)**2+(distY)**2);\n          }\n          //line.occupiedDistances.push(shapes[i].distance_to_line_center,);\n          //}\n          console.log(\"A new shape has been added with a distance\" + shapes[i].distance_to_line_center);\n          //shapes[i].isGrouped=0;\n          //this.updateDragFunc(shapes[i],line);\n          //grp.shapes_g.push(shapes[i],);\n          this.updateOccupiedDistance(line.id);\n\n          this.updateAllPosInGrp(id_grp);\n          shapes.splice(i, 1);\n        }\n      }\n      this.center.x = line.x;\n      this.center.y = line.y;\n    },\n\n    updateOccupiedDistance(id_grp) {\n\n      const grp = this.groups.find((r) => r.id === id_grp);\n      //this.updateAllPosInGrp(id_grp);\n      this.sortByDistToLineCenter(grp);\n\n      //let l=grp.line.points[4]/2;\n      if (grp.line.keepDistribution) {\n        let L = grp.line.points[4];\n        let nb_shapes = grp.shapes_g.length;\n        let d = (L / (nb_shapes - 1)) * grp.line.scaleX;\n        if (nb_shapes % 2 == 0) {\n\n          for (let i = 1; i <= nb_shapes / 2 - 1; i++) {\n            //grp.line.occupiedDistances[i-1]=-(l/i);\n            grp.line.occupiedDistances[i - 1] = -((nb_shapes / 2 - 1) - i + 1) * d - d / 2\n          }\n          for (let i = 1; i <= nb_shapes / 2 - 1; i++) {\n            grp.line.occupiedDistances[nb_shapes / 2 + i] = i * d + d / 2;\n          }\n          grp.line.occupiedDistances[nb_shapes / 2 - 1] = -d / 2\n          grp.line.occupiedDistances[nb_shapes / 2] = d / 2\n        } else {\n          for (let i = 1; i <= (nb_shapes - 1) / 2; i++) {\n            grp.line.occupiedDistances[i - 1] = -d * (((nb_shapes - 1) / 2) - i + 1);\n          }\n          for (let i = 1; i <= (nb_shapes - 1) / 2; i++) {\n            grp.line.occupiedDistances[((nb_shapes - 1) / 2) + i] = d * i;\n          }\n          grp.line.occupiedDistances[(nb_shapes - 1) / 2] = 0;\n        }\n\n        for (let i = 0; i < grp.shapes_g.length; i++) {\n          grp.shapes_g[i].distance_to_line_center = grp.line.occupiedDistances[i];\n        }\n      }\n      else {\n        grp.line.occupiedDistances.sort(this.isSmaller);\n      }\n\n\n\n\n\n    },\n\n    isSmaller(a, b) {\n      if (a < b) {\n        return -1;\n      } else {\n        return 1\n      }\n    },\n\n    isBeforeRegardingX(a, b) {\n      if (a.x < b.x) {\n        return -1;\n      } else {\n        return 1;\n      }\n    },\n\n\n    updateOccDist(grp, shape) {\n      let res = this.isNearest(grp.line, shape);\n      //let grp=this.groups.find((r)=>r.id===line.id);\n      if (res.isFree) {\n        shape.distance_to_line_center = grp.line.freeDistances[res.indice];\n        grp.line.freeDistances.splice(res.indice, 1);\n        this.sortByDistToLineCenter(grp);\n        for (let l = 0; l < grp.shapes_g.length; l++) {\n          if (grp.line.occupiedDistances.length == l) {\n            grp.line.occupiedDistances.push(grp.shapes_g[l].distance_to_line_center,);\n          } else {\n            grp.line.occupiedDistances[l] = grp.shapes_g[l].distance_to_line_center;\n          }\n        }\n      } else {\n        grp.shapes_g.find((r) => r.id == shape.id).distance_to_line_center = grp.line.occupiedDistances[res.indice];\n        grp.line.occupiedDistances.splice(res.indice, 1);\n        //line.occupiedDistances.push(shape.distance_to_line_center,);\n        //line.freeDistances.splice(res.indice,1);   \n        this.updateOccDist(grp, grp.shapes_g[res.indice]);\n      }\n    },\n    isNearest(line, shape) {\n      let ecart;\n      let invx = line.x + line.freeDistances[0] * Math.cos(line.rotation * (Math.PI / 180));\n      let invy = line.y + line.freeDistances[0] * Math.sin(line.rotation * (Math.PI / 180));\n      let ecart_min = Math.sqrt((invx - shape.x) ** 2 + (invy - shape.y) ** 2);\n      let indice = 0;\n      for (let i = 1; i < line.freeDistances.length; i++) {\n        invx = line.x + line.freeDistances[i] * Math.cos(line.rotation * (Math.PI / 180));\n        invy = line.y + line.freeDistances[i] * Math.sin(line.rotation * (Math.PI / 180));\n        ecart = Math.sqrt((invx - shape.x) ** 2 + (invy - shape.y) ** 2);\n        if (ecart < ecart_min) {\n          //res=line.freeDistances[i];\n          ecart_min = ecart;\n          indice = i;\n        }\n      }\n      return indice;\n      /*\n      let allDist=line.freeDistances.concat(line.occupiedDistances);\n      console.log(allDist);\n      \n      let ecart;\n      let invx=line.x+allDist[0]*Math.cos(line.rotation*(Math.PI/180));\n      let invy=line.y+allDist[0]*Math.sin(line.rotation*(Math.PI/180));\n      let ecart_min=Math.sqrt((invx-shape.x)**2+(invy-shape.y)**2)\n      let indice=0;\n      console.log(ecart_min);\n      for(let i=1;i<allDist.length;i++){\n        invx=line.x+allDist[i]*Math.cos(line.rotation*(Math.PI/180));\n        invy=line.y+allDist[i]*Math.sin(line.rotation*(Math.PI/180));\n        ecart=Math.sqrt((invx-shape.x)**2+(invy-shape.y)**2);\n        if(this.groups.find((r)=>r.id==line.id).shapes_g.indexOf(shape)!=-1){\n          console.log(ecart_min);\n          console.log(ecart);\n          if(ecart<ecart_min && ecart!=0){\n            //res=allDist[i];\n            ecart_min=ecart;\n            indice=i;\n          }\n        }else if(ecart<ecart_min){\n          //res=allDist[i];\n          ecart_min=ecart;\n          indice=i;\n        }\n      }\n      console.log(indice);\n      if(indice>=line.freeDistances.length){\n        return{\n          isFree: false,\n          indice: indice-line.freeDistances.length,\n        }\n      }else{\n        return{\n          isFree: true,\n          indice: indice,\n        }\n      }\n      */\n\n      /*\n      line.freeDistances.sort(this.isSmaller);\n      let ecart;\n      let invx=line.x+line.freeDistances[0]*Math.cos(line.rotation*(Math.PI/180));\n      let invy=line.y+line.freeDistances[0]*Math.sin(line.rotation*(Math.PI/180));\n      let ecart_min=Math.sqrt((invx-shape.x)**2+(invy-shape.y)**2)\n      let indice=0;\n      for(let i=0;i<line.freeDistances.length;i++){\n        invx=line.x+line.freeDistances[i]*Math.cos(line.rotation*(Math.PI/180));\n        invy=line.y+line.freeDistances[i]*Math.sin(line.rotation*(Math.PI/180));\n        ecart=Math.sqrt((invx-shape.x)**2+(invy-shape.y)**2)\n        if(ecart<ecart_min){\n          //res=freeDistances[i];\n          ecart_min=ecart;\n          indice=i;\n        }\n      }\n      return indice;\n      */\n      /*\n      if(shapeDistance>=0){\n        for(let i=0;i<freeDistances.length;i++){\n          if(freeDistances[i]>shapeDistance){\n            return i;\n          }\n        }\n        return freeDistances.length-1;\n      }else{\n        let ecart_min=Math.abs(Math.abs(freeDistances[0])-Math.abs(shapeDistance))\n        let indice=0;\n        for(let i=0;i<freeDistances.length;i++){\n          let ecart=Math.abs(Math.abs(freeDistances[i])-Math.abs(shapeDistance));\n          if(ecart<ecart_min){\n            //res=freeDistances[i];\n            ecart_min=ecart;\n            indice=i;\n          }\n        }\n        return indice;\n      }\n      */\n      /*\n      //let res=freeDistances[0];\n      let ecart_min=Math.abs(Math.abs(freeDistances[0])-Math.abs(shapeDistance))\n      let indice=0;\n      for(let i=0;i<freeDistances.length;i++){\n        let ecart=Math.abs(Math.abs(freeDistances[i])-Math.abs(shapeDistance));\n        if(ecart<ecart_min){\n          //res=freeDistances[i];\n          ecart_min=ecart;\n          indice=i;\n        }\n      }\n      return indice;\n      */\n    },\n\n\n    sortByDistToLineCenter(grp) {\n      //this.updateAllPosInGrp(grp.id)\n      //let last_distX=new Array(grp.shapes_g.length);\n\n      //let distX;\n      //let distY;\n      //let sign;\n      //let dist=new Array(grp.shapes_g.length);\n      //let angle;\n      if (grp.line.keepDistribution) {\n        for (let l = 0; l < grp.shapes_g.length; l++) {\n          let distX = grp.shapes_g[l].x - grp.line.x;\n          let distY = grp.shapes_g[l].y - grp.line.y;\n          //dist[l]=this.GiveSignOfDistance(grp.shapes_g[l],grp.line)*Math.sqrt((distX)**2+(distY)**2);\n          grp.shapes_g[l].distance_to_line_center = this.GiveSignOfDistance(grp.shapes_g[l], grp.line) * Math.sqrt((distX) ** 2 + (distY) ** 2);\n          //last_distX[l]=distX;\n        }\n      }\n      for (let i = 1; i < grp.shapes_g.length; i++) {\n\n\n        let shape = grp.shapes_g[i];\n        //let distance=dist[i];\n        let j = i\n        while (j > 0 && grp.shapes_g[j - 1].distance_to_line_center > shape.distance_to_line_center) {\n          grp.shapes_g[j] = grp.shapes_g[j - 1];\n          //dist[j]=dist[j-1]\n          j = j - 1;\n        }\n        grp.shapes_g[j] = shape;\n        //dist[j]=distance;\n      }\n    },\n\n\n    sortAnyShapesByDistToLineCenter(shapes, line) {\n      //this.updateAllPosInGrp(grp.id)\n      //let last_distX=new Array(grp.shapes_g.length);\n\n      //let distX;\n      //let distY;\n      //let sign;\n      //let dist=new Array(grp.shapes_g.length);\n      //let angle;\n      for (let l = 0; l < shapes.length; l++) {\n        let distX = shapes[l].x - line.x;\n        let distY = shapes[l].y - line.y;\n        /*\n        angle=grp.shapes_g[l].rotation*(Math.PI/180);\n\n      \n      if(angle<=-Math.PI/4 || angle>=-Math.PI/2){\n        sign=-Math.sign(distY);\n      }\n      else if(angle<=-Math.PI/2 || angle>=-3*Math.PI/4){\n        sign=Math.sign(distY);\n      }\n      else if(angle<=-3*Math.PI/4 || angle>=-Math.PI){\n        sign=-Math.sign(distX);\n      }else if(angle>=3*Math.PI/4 || angle<=Math.PI){\n        sign=Math.sign(distX);\n      }else if(angle>=Math.PI/2 || angle<3*Math.PI/4){\n        sign=-Math.sign(distY);\n      } else if(angle<=Math.PI/2 || angle>Math.PI/4){\n        sign=-Math.sign(distY);\n      } else if(angle<=Math.PI/4 || angle>=0){\n        sign=Math.sign(distX);\n      }\n       console.log(sign);\n        */\n\n        /*\n        if(Math.sin(grp.line.rotation*(Math.PI/180))==0){\n            grp.shapes_g[l].distance_to_line_center=grp.shapes_g[l].x-grp.line.x;\n        }else{\n            grp.shapes_g[l].distance_to_line_center=Math.sign(distX)*Math.sqrt((distX)**2+(distY)**2);\n          \n            if(grp.line.rotation*(Math.PI/180)<=-Math.PI/2 || grp.line.rotation*(Math.PI/180)<=Math.PI/2 &&grp.line.rotation*(Math.PI/180)>=0){\n              grp.shapes_g[l].distance_to_line_center=-grp.shapes_g[l].distance_to_line_center\n            }\n        }\n        */\n        //dist[l]=this.GiveSignOfDistance(grp.shapes_g[l],grp.line)*Math.sqrt((distX)**2+(distY)**2);\n        shapes.distance_to_line_center = this.GiveSignOfDistance(shapes, line) * Math.sqrt((distX) ** 2 + (distY) ** 2);\n        /*\n        if((grp.line.rotation*(Math.PI/180)<=-Math.PI/2 || (grp.line.rotation*(Math.PI/180)<=Math.PI/2 && grp.line.rotation*(Math.PI/180)>=0)) && (Math.sign(last_distX[l])!=Math.sign(distX))){\n          grp.shapes_g[l].distance_to_line_center=-grp.shapes_g[l].distance_to_line_center\n        }\n        */\n        //last_distX[l]=distX;\n      }\n      for (let i = 1; i < shapes.length; i++) {\n\n\n        let shape = shapes[i];\n        //let distance=dist[i];\n        let j = i\n        while (j > 0 && shapes[j - 1].distance_to_line_center > shape.distance_to_line_center) {\n          shapes[j] = shapes[j - 1];\n          //dist[j]=dist[j-1]\n          j = j - 1;\n        }\n        shapes[j] = shape;\n        //dist[j]=distance;\n      }\n    },\n\n\n\n    /*\n    update the drag function of a shape which is on a line. \n    */\n    updateDragFunc(shape, line) {\n      let angle = line.rotation * (Math.PI / 180);\n      if (angle <= 0 && angle >= -Math.PI / 4) {\n        shape.dragBoundFunc = function (pos) {\n          return {\n            x: line.x + (pos.x - line.x) * Math.cos(angle),\n            y: line.y + (pos.x - line.x) * Math.sin(angle),\n          };\n        }\n      } else if (angle < -Math.PI / 4 && angle >= -Math.PI / 2) {\n        // We prefer, in this case, moving the shape of the line regarding the y of the mouse position instead of the x.\n        // So that the user can move the shape more intuitively\n        shape.dragBoundFunc = function (pos) {\n          return {\n            x: line.x - (pos.y - line.y) * Math.cos(angle),\n            y: line.y - (pos.y - line.y) * Math.sin(angle),\n          };\n        }\n      }\n      else if (angle < -Math.PI / 2 && angle >= -3 * Math.PI / 4) {\n        shape.dragBoundFunc = function (pos) {\n          return {\n            x: line.x - (pos.y - line.y) * Math.cos(angle),\n            y: line.y - (pos.y - line.y) * Math.sin(angle),\n          };\n        }\n      } else if (angle < -3 * Math.PI / 4 && angle >= -Math.PI) {\n        shape.dragBoundFunc = function (pos) {\n          return {\n            x: line.x - (pos.x - line.x) * Math.cos(angle),\n            y: line.y - (pos.x - line.x) * Math.sin(angle),\n          };\n        }\n      } else if (angle <= Math.PI && angle >= 3 * Math.PI / 4) {\n        shape.dragBoundFunc = function (pos) {\n          return {\n            x: line.x - (pos.x - line.x) * Math.cos(angle),\n            y: line.y - (pos.x - line.x) * Math.sin(angle),\n          };\n        }\n      } else if (angle < 3 * Math.PI / 4 && angle >= Math.PI / 2) {\n        shape.dragBoundFunc = function (pos) {\n          return {\n            x: line.x + (pos.y - line.y) * Math.cos(angle),\n            y: line.y + (pos.y - line.y) * Math.sin(angle),\n          };\n        }\n      } else if (angle < Math.PI / 2 && angle >= Math.PI / 4) {\n        shape.dragBoundFunc = function (pos) {\n          return {\n            x: line.x + (pos.y - line.y) * Math.cos(angle),\n            y: line.y + (pos.y - line.y) * Math.sin(angle),\n          };\n        }\n      } else if (angle < Math.PI / 4 && angle >= 0) {\n        shape.dragBoundFunc = function (pos) {\n          return {\n            x: line.x + (pos.x - line.x) * Math.cos(angle),\n            y: line.y + (pos.x - line.x) * Math.sin(angle),\n          };\n        }\n      }\n    },\n\n    /*\n    Update the position of a free shape when it is dragging.\n    */\n    updatePos(e) {\n      const shape = this.shapes.find(i => i.id === e.target.id());\n      shape.x = e.target.x();\n      shape.y = e.target.y();\n      this.center.x = e.target.x();\n      this.center.y = e.target.y();\n\n      let pos = { x: shape.x, y: shape.y };\n      e.target.position(pos);\n      e.target.getLayer().batchDraw();\n\n    },\n\n    /*\n    Update the positio  of shape attached to a line (from the group with id=id_grp) when it is dragging.\n     */\n    updatePosInGrp(e, id_grp) {\n      let distX;\n      let distY;\n      let distance_to_line_center;\n      const grp = this.groups.find((r) => r.id === id_grp);\n\n      if (grp.aShapeHasBeenDetach == 1) {\n        grp.aShapeHasBeenDetach = 0;\n        return;\n      }\n      const line = grp.line;\n      const shape = grp.shapes_g.find(i => i.id === e.target.id());\n      const shapes_g = grp.shapes_g;\n      //const lengthToDetach=10;\n      if (shape.needToBeDetach == 1) {\n        shape.needToBeDetach = 0;\n        this.DetachShape(shape);\n        this.updateAllPosInGrp(e.target.getParent().attrs.id);\n      }\n      if (line.keepDistribution) {\n        if (this.isCoordinateOnLine(e.target.x(), e.target.y(), line.id)) {\n          distX = shape.x - e.target.x();\n          distY = shape.y - e.target.y();\n          let L = grp.line.points[4];\n          let nb_shapes = grp.shapes_g.length;\n          let d = (L / (nb_shapes - 1)) * grp.line.scaleX;\n          let dist = Math.sqrt(distX ** 2 + distY ** 2);\n          if (dist >= d) {\n            shape.x = e.target.x();\n            shape.y = e.target.y();\n            this.updateOccupiedDistance(line.id)\n            shape.x = line.x + line.occupiedDistances[shapes_g.indexOf(shape)] * Math.cos(line.rotation * (Math.PI / 180));\n            shape.y = line.y + line.occupiedDistances[shapes_g.indexOf(shape)] * Math.sin(line.rotation * (Math.PI / 180));\n            shape.distance_to_line_center = line.occupiedDistances[shapes_g.indexOf(shape)];\n            shape.rotation = line.rotation;\n            this.updateAllPosInGrp(line.id);\n          } else {\n            shape.x = line.x + line.occupiedDistances[shapes_g.indexOf(shape)] * Math.cos(line.rotation * (Math.PI / 180));\n            shape.y = line.y + line.occupiedDistances[shapes_g.indexOf(shape)] * Math.sin(line.rotation * (Math.PI / 180));\n            shape.distance_to_line_center = line.occupiedDistances[shapes_g.indexOf(shape)];\n            shape.rotation = line.rotation;\n          }\n        } else {\n          shape.x = e.target.x();\n          shape.y = e.target.y();\n        }\n        line.positionPoints[grp.shapes_g.indexOf(shape)].x = shape.x;\n        line.positionPoints[grp.shapes_g.indexOf(shape)].y = shape.y;\n        line.positionPoints[grp.shapes_g.indexOf(shape)].distance_to_line_center = shape.distance_to_line_center;\n      } else {\n\n        line.positionPoints[grp.shapes_g.indexOf(shape)].x = shape.x;\n        line.positionPoints[grp.shapes_g.indexOf(shape)].y = shape.y;\n        shape.x = e.target.x();\n        shape.y = e.target.y();\n\n        if (Math.sin(line.rotation * (Math.PI / 180)) == 0) {\n          distance_to_line_center = shape.x - line.x;\n        } else {\n          if (Math.sign(shape.x - line.x) != 0) {\n            distance_to_line_center = Math.sign(-shape.rotation) * Math.sign(shape.x - line.x) * Math.sqrt((shape.x - line.x) ** 2 + (shape.y - line.y) ** 2);\n          } else {\n            distance_to_line_center = Math.sign(-shape.rotation) * Math.sign(shape.y - line.y) * Math.sqrt((shape.x - line.x) ** 2 + (shape.y - line.y) ** 2);\n          }\n\n          if (shape.rotation * (Math.PI / 180) <= -Math.PI / 2 || (shape.rotation * (Math.PI / 180) <= Math.PI / 2 && shape.rotation * (Math.PI / 180) >= 0)) {\n            distance_to_line_center = -distance_to_line_center\n          }\n        }\n        //shape.distance_to_line_center=distance_to_line_center;\n        //grp.line.occupiedDistances[shapes_g.indexOf(shape)]=shape.distance_to_line_center;\n        line.positionPoints[grp.shapes_g.indexOf(shape)].distance_to_line_center = shape.distance_to_line_center;\n\n      }\n      let pos = { x: shape.x, y: shape.y };\n      this.center.x = shape.x;\n      this.center.y = shape.y;\n      e.target.position(pos);\n      e.target.getLayer().batchDraw();\n      if (!this.isCoordinateOnLine(shape.x, shape.y, line.id)) {\n        shape.dragBoundFunc = dragFunc;\n        shape.isGrouped = 0;\n        this.shapes.push(shape,)\n        for (let i = 0; i < shapes_g.length; i++) {\n          if (shapes_g[i].id == shape.id) {\n            line.freeDistances.push(line.occupiedDistances[i]);\n            line.occupiedDistances.splice(i, 1);\n            shapes_g.splice(i, 1);\n            console.log(\"a shape has been removed from the line\");\n          }\n        }\n      } else {\n        if (!line.keepDistribution) {\n          grp.line.occupiedDistances[shapes_g.indexOf(shape)] = distance_to_line_center;\n        } else {\n          grp.line.occupiedDistances[shapes_g.indexOf(shape)] = shape.distance_to_line_center;\n        }\n\n        line.positionPoints[grp.shapes_g.indexOf(shape)].x = shape.x;\n        line.positionPoints[grp.shapes_g.indexOf(shape)].y = shape.y;\n        line.positionPoints[grp.shapes_g.indexOf(shape)].distance_to_line_center = shape.distance_to_line_center;\n\n      }\n      /*\n      let coord_y1=line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x1=line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let coord_y2= line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x2=line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let a=(coord_y1-coord_y2)/(coord_x2-coord_x1);\n      let b=line.y-a*line.x;\n      let is_on_straight_line=false;\n      if(Math.abs(coord_x1-coord_x2)>=1){\n        is_on_straight_line=(Math.abs(a*shape.x+b-shape.y)<1);\n      }else{\n        is_on_straight_line=(Math.abs(shape.x-line.x)<1);\n      }\n      if(\n        !(is_on_straight_line)\n      ||((line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n        ||line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      && ((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>-Math.PI)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>-Math.PI)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>=0)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>=0)))\n      )\n      {\n        shape.dragBoundFunc= dragFunc;\n        this.shapes.push(shape,)\n        for (let i=0;i<shapes_g.length;i++){\n          if(shapes_g[i].id==shape.id){\n            line.freeDistances.push(line.occupiedDistances[i]);\n            line.occupiedDistances.splice(i,1);\n            shapes_g.splice(i,1);\n            console.log(\"a shape has been removed from the line\");\n          }\n        } \n      }else{\n        if(!line.keepDistribution){\n          grp.line.occupiedDistances[shapes_g.indexOf(shape)]=distance_to_line_center;\n        }else{\n        grp.line.occupiedDistances[shapes_g.indexOf(shape)]=shape.distance_to_line_center;\n        }\n      }\n      */\n      //this.updateOccupiedDistance(line.id);\n\n      if (line.keepDistribution) {\n        this.updateOccupiedDistance(line.id);\n      }\n\n      this.updateAllPosInGrp(line.id);\n    },\n    /*\n    Function called when the transformation of a shape with a transfomer is finished.\n    */\n    updateTransformedShape(e) {\n      /*\n      let shape = this.shapes.find(\n        (r) => r.id === this.selectedShapeId\n      );\n      */\n      let res;\n      let shape;\n      if (e.target.className == \"Line\") {\n        shape = this.groups.find(\n          (r) => r.id === this.selectedShapeId\n        ).line;\n      } else {\n        res = this.findShape(this.selectedShapeId)\n        shape = res.shape_data;\n        if (shape == undefined) {\n          return;\n        }\n      }\n\n\n      let last_shapex = shape.x;\n      let last_shapey = shape.y;\n      //let last_shaperotation= shape.rotation;\n\n      shape.x = e.target.x();\n      shape.y = e.target.y();\n      shape.rotation = e.target.rotation();\n      let last_scaleX = shape.scaleX;\n      shape.scaleX = e.target.scaleX();\n      shape.scaleY = e.target.scaleY();\n\n      if (e.target.className == \"Line\") {\n        const grp = this.groups.find((r) => r.id === shape.id);\n        if (shape.keepDistribution) {\n          for (let i = 0; i < shape.occupiedDistances.length; i++) {\n            shape.occupiedDistances[i] = (shape.occupiedDistances[i] / last_scaleX) * shape.scaleX;\n          }\n          /*\n          for (let i=0;i<shape.freeDistances.length;i++){\n            shape.freeDistances[i]=(shape.freeDistances[i]/last_scaleX)*shape.scaleX;\n          }\n          */\n\n          //this.updateOccupiedDistance(shape.id)\n          this.update();\n          //this.updateGrp(e, this.selectedShapeId);\n          this.updateGrp(e);\n          this.checkIfShapesOnLine(this.selectedShapeId);\n        } else {\n\n\n\n          if (last_scaleX != shape.scaleX) {\n            for (let i = 0; i < grp.shapes_g.length; i++) {\n\n              //If the width of the line has been changed, we update the distance from the shape to the center of the line\n\n              let distX = grp.shapes_g[i].x - shape.x;\n              let distY = grp.shapes_g[i].y - shape.y;\n              /*\n              if(Math.sign(grp.shapes_g[i].distance_to_line_center)==0){\n                grp.shapes_g[i].distance_to_line_center=-this.GiveSignOfDistance(grp.shapes_g[i],shape)*Math.sqrt((distX)**2 +(distY)**2);\n              \n              }else{\n                grp.shapes_g[i].distance_to_line_center=Math.sign(grp.shapes_g[i].distance_to_line_center)*Math.sqrt((distX)**2 +(distY)**2);\n              }\n              if(Math.sign((grp.shapes_g[i].x-last_shapex))!=Math.sign(distX)){\n                grp.shapes_g[i].distance_to_line_center=-grp.shapes_g[i].distance_to_line_center;\n              }\n              */\n              if (Math.sign(grp.line.occupiedDistances[i]) == 0) {\n                //if(grp.line.rotation!=-90 && grp.line.rotation!=90){\n                //grp.line.occupiedDistances[i]=-this.GiveSignOfDistance(grp.shapes_g[i],shape)*Math.sqrt((distX)**2 +(distY)**2);\n                //}else{\n                grp.line.occupiedDistances[i] = this.GiveSignOfDistance(grp.shapes_g[i], shape) * Math.sqrt((distX) ** 2 + (distY) ** 2);\n\n                //}\n\n              } else {\n                grp.line.occupiedDistances[i] = Math.sign(grp.line.occupiedDistances[i]) * Math.sqrt((distX) ** 2 + (distY) ** 2);\n              }\n\n\n              if (Math.sign((grp.shapes_g[i].x - last_shapex)) != Math.sign(distX) && Math.sign((grp.shapes_g[i].x - last_shapex)) != 0 && grp.line.rotation != 90 && grp.line.rotation != -90) {\n\n                grp.line.occupiedDistances[i] = -grp.line.occupiedDistances[i];\n              }\n              if (Math.sign((grp.shapes_g[i].y - last_shapey)) != Math.sign(distY) && Math.sign((grp.shapes_g[i].y - last_shapey)) != 0 && (grp.line.rotation == 90 || grp.line.rotation == -90)) {\n                grp.line.occupiedDistances[i] = -grp.line.occupiedDistances[i];\n              }\n              //this.checkIfShapesOnLine(this.selectedShapeId);  \n\n              //this.checkIfShapesOnLine(this.selectedShapeId);\n              //grp.line.occupiedDistances[i]=grp.shapes_g[i].distance_to_line_center;\n\n            }\n            for (let i = 0; i < shape.freeDistances.length; i++) {\n              let distX = last_shapex - shape.x;\n              let distY = last_shapey - shape.y;\n              let dist = Math.sqrt(distX ** 2 + distY ** 2);\n              if (shape.rotation < -90 || shape.rotation > 90) {\n                shape.freeDistances[i] = shape.freeDistances[i] - Math.sign(last_shapex - shape.x) * dist;\n              } else if (shape.rotation == 90 || shape.rotation == -90) {\n                shape.freeDistances[i] = shape.freeDistances[i] - distY\n              } else {\n                shape.freeDistances[i] = shape.freeDistances[i] + Math.sign(last_shapex - shape.x) * dist;\n\n              }\n            }\n          }\n          this.update();\n          //this.updateGrp(e, this.selectedShapeId);\n          this.updateGrp(e);\n          this.checkIfShapesOnLine(this.selectedShapeId);\n\n          // We now see if freeDistances need to be delete(so if they are bigger than the half of the stickyline);\n          let i = 0;\n          while (i < shape.freeDistances.length) {\n            if ((1 / 2) * ((shape.points[4]) * shape.scaleX) + 10 < Math.abs(shape.freeDistances[i])) {\n              let corresponding_positionPoint = shape.positionPoints.find((r) => r.distance_to_line_center == shape.freeDistances[i])\n              let index = shape.positionPoints.indexOf(corresponding_positionPoint);\n              shape.positionPoints.splice(index, 1);\n              shape.freeDistances.splice(i, 1);\n            } else {\n              i = i + 1;\n            }\n          }\n        }\n        for (let i = 0; i < grp.shapes_g.length; i++) {\n\n          this.updateDragFunc(grp.shapes_g[i], shape);\n\n        }\n      } else if (res.grp_id != '-1') {\n        //this.update();\n        //let layer=e.target.getParent().getLayer();\n        //layer.batchDraw();\n        this.updateAllPosInGrp(res.grp_id);\n        this.updateOccupiedDistance(res.grp_id);\n        e.target.x(e.target.getParent().attrs.shapes_g.find((r) => r.id === e.target.id()).x);\n        e.target.y(e.target.getParent().attrs.shapes_g.find((r) => r.id === e.target.id()).y);\n        this.groups.find((r) => r.id === res.grp_id).shapes_g.find((r) => r.id === e.target.id()).personalRotation = e.target.rotation() - e.target.getParent().attrs.line.rotation;\n\n        this.updateAllPosInGrp(res.grp_id);\n        this.checkIfShapesOnLine(res.grp_id);\n        this.updateDragFuncOfCenter();\n\n      }\n      else {\n        this.update();\n\n        this.updateDragFuncOfCenter();\n      }\n      this.center.x = e.target.attrs.x;\n      this.center.y = e.target.attrs.y;\n      this.updateNaration(this.groups.find(\n        (r) => r.id === this.selectedShapeId\n      ));\n    },\n\n    handleTransformation(e) {\n      document.getElementById(\"input\").style.display = \"none\"; //if the input for modifying the text is here\n      if (e.evt == undefined) {\n        return;\n      }\n      if (this.eraseMode == 1) {\n        this.eraserAction(e);\n        return;\n      }\n\n      //If we click on the stage, we have to remove the transformer from the node where it was.\n      if (e.target === e.target.getStage()) {\n        this.selectedShapeId = 'NoId';\n        this.eraseNodefromTransformer(\"lineTransformer\");\n        this.eraseNodefromTransformer(\"shapeTransformer\");\n        this.center.opacity = 0;\n        return;\n      }\n\n      //If we click on a transformer, nothing happen\n      const clickedOnTransformer = e.target.getParent().className === 'Transformer';\n      if (clickedOnTransformer) {\n        return;\n      }\n\n      const id = e.target.id();\n      let transformer_id;\n      //let shape=this.shapes.find((r) => r.id === id);\n      let shape = this.findShape(id).shape_data;\n      /*\n      let isFunded=true;\n      if(shape==undefined){\n        isFunded=false;\n      }\n      let i=0;\n      while(!isFunded){\n        if(i<this.groups.length){\n          shape=this.groups[i].shapes_g.find(i => i.id === id);\n        if(shape==undefined){\n          isFunded=false;\n        }else{\n          isFunded=true;\n        }\n        i++;\n        }else{        \n          isFunded=true;\n        }\n      }\n      */\n\n      //if it is a line, we need the transformer dedicated to the line (ie transformer with id=\"lineTransformer\")\n      //if it is a classic shape, we need the transformer dedicated to the shape (ie transformer with id=\"shapeTransformer\")\n      if (e.target.attrs.id == \"center\") {\n        return;\n      }\n      if (e.target.className == \"Line\") {\n        transformer_id = \"lineTransformer\"\n        shape = this.groups.find((r) => r.id === id).line;\n        this.center.draggable = false;\n        this.selectedShapeAlignment = shape.defaultAlignment;\n        this.eraseNodefromTransformer(\"shapeTransformer\");\n      } else {\n        transformer_id = \"shapeTransformer\"\n        this.center.draggable = true;\n        this.selectedShapeAlignment = shape.centerPosition;\n        this.eraseNodefromTransformer(\"lineTransformer\");\n      }\n\n      if (shape != undefined) {\n        this.selectedShapeId = id;\n        this.center.opacity = 1;\n        this.updateTransformer(transformer_id);\n      } else {\n        /*Only if the center is not selected.\n        When the center is dragged, this function is called.\n        But a shape is actualy selected (the one of the center).\n        */\n        this.selectedShapeId = 'NoId';\n      }\n      //this.updateTransformer(transformer_id);\n\n      this.updateDragFuncOfCenter()\n    },\n\n    //remove node from transformer with id=transformer_id\n    eraseNodefromTransformer(transformer_id) {\n      let stage = this.$refs.stage.getStage();\n      const transformerNode = stage.find(\"#\" + transformer_id)[0];\n      transformerNode.nodes([]);\n    },\n\n    //Update transformer with id=transformer_id\n    //It places the transformer regarding what node is selected\n    updateTransformer(transformer_id) {\n\n      let stage = this.$refs.stage.getStage();\n      const transformerNode = stage.find(\"#\" + transformer_id)[0];\n      let selectedNode;\n      if (transformer_id == \"lineTransformer\") {\n        selectedNode = stage.children[0].getChildren().filter((r) => r.attrs.className == \"Group\" && r.attrs.id == this.selectedShapeId)[0]\n          .getChildren().filter(r => r.attrs.className == \"Line\" && r.attrs.id == this.selectedShapeId)[0];\n      } else {\n        selectedNode = stage.children[0].getChildren().filter((r) => r.attrs.className != \"Group\" && r.attrs.id == this.selectedShapeId)[0];\n\n        let isFunded = true;\n        if (selectedNode == undefined) {\n          isFunded = false;\n        }\n        let i = 0;\n        while (!isFunded) {\n          if (i < this.groups.length) {\n            selectedNode = stage.children[0].getChildren().filter((r) => r.attrs.className == \"Group\")[i].getChildren().find((r) => r.attrs.id == this.selectedShapeId && r.attrs.className != \"Line\");\n            if (selectedNode == undefined) {\n              isFunded = false;\n            } else {\n              isFunded = true;\n            }\n            i++;\n          } else {\n            isFunded = true;\n          }\n        }\n      }\n      /*\n      if (transformer_id==\"lineTransformer\"){\n        selectedNode = stage.children[0].getChildren().filter((r)=> r.attrs.className==\"Group\" && r.attrs.id==this.selectedShapeId)[0]\n        .getChildren().filter(r=>r.attrs.className==\"Line\" && r.attrs.id==this.selectedShapeId)[0];\n      }\n      */\n\n      //If the selected node has already the transformer on it, nothing happen\n      if (selectedNode === transformerNode.node()) {\n        return;\n      }\n\n      if (selectedNode != undefined) {\n        transformerNode.nodes([selectedNode]);\n      } else {\n        transformerNode.nodes([]);\n      }\n      this.center.x = selectedNode.attrs.x;\n      this.center.y = selectedNode.attrs.y;\n\n    },\n\n    DisplayCenterMenu(e) {\n      CenterMenu.props.ConcernedShape = e.target;\n      document.getElementById(\"center_menu\").style.display = \"initial\";\n      document.getElementById(\"center_menu\").style.top = document.getElementById(\"AppropriabilitySubstrateDemo\").getBoundingClientRect().top + document.documentElement.scrollTop + e.target.getStage().getPointerPosition().y + \"px\";\n      document.getElementById(\"center_menu\").style.left = document.getElementById(\"AppropriabilitySubstrateDemo\").getBoundingClientRect().left + document.documentElement.scrollLeft + e.target.getStage().getPointerPosition().x + \"px\";\n    },\n\n\n    //display context menu according to the target\n\n    DisplayContextMenu(e) {\n      e.evt.preventDefault()\n      if (e.target.className != undefined && e.target.attrs.id != \"center\") {\n        this.isStageOnlySelected = false;\n        ContextMenu.data().dM = 'initial';\n        this.$emit('needmenu');\n        this.needMenu = true;\n        ContextMenu.props.ConcernedShape = e.target;\n        if (e.target.attrs.className == \"Line\") {\n          this.isALineSelected = true;\n          this.isAGroupedShapeSelected = true;\n          //We precise the text which depends on the line where we clicked.\n          this.keepDistanceButtonText = e.target.attrs.keepDistanceButtonText;\n        } else if (e.target.getParent().attrs.className == \"Group\") {\n          this.isAGroupedShapeSelected = true;\n        }\n        else {\n          this.isALineSelected = false;\n          this.isAGroupedShapeSelected = false;\n        }\n\n        document.getElementById(\"activeReuseSubstrate\").style.display = \"initial\";\n        document.getElementById(\"activeReuseSubstrate\").style.top = document.getElementById(\"AppropriabilitySubstrateDemo\").getBoundingClientRect().top + document.documentElement.scrollTop + e.target.getStage().getPointerPosition().y + \"px\";\n        document.getElementById(\"activeReuseSubstrate\").style.left = document.getElementById(\"AppropriabilitySubstrateDemo\").getBoundingClientRect().left + document.documentElement.scrollLeft + e.target.getStage().getPointerPosition().x + \"px\";\n      }\n      if (e.target === e.target.getStage()) {\n        this.needMenu = true;\n        this.isALineSelected = false;\n        this.isAGroupedShapeSelected = false;\n        this.isStageOnlySelected = true;\n        document.getElementById(\"activeReuseSubstrate\").style.display = \"initial\";\n        document.getElementById(\"activeReuseSubstrate\").style.top = document.getElementById(\"AppropriabilitySubstrateDemo\").getBoundingClientRect().top + document.documentElement.scrollTop + e.target.getStage().getPointerPosition().y + \"px\";\n        document.getElementById(\"activeReuseSubstrate\").style.left = document.getElementById(\"AppropriabilitySubstrateDemo\").getBoundingClientRect().left + document.documentElement.scrollLeft + e.target.getStage().getPointerPosition().x + \"px\";\n\n      }\n    },\n\n    //hide context menu\n    HideContextMenu() {\n      this.needMenu = false;\n      document.getElementById(\"activeReuseSubstrate\").style.display = \"none\";\n      document.getElementById(\"center_menu\").style.display = \"none\";\n    },\n\n\n\n    ChangeCenter(e) {\n      let res = this.findShape(this.selectedShapeId);\n      let shape = res.shape_data;\n      let threshold1;\n      let threshold2;\n      let dist = this.GiveSignOfDistanceBtwCenterAndShape(e.target.attrs, shape) * Math.sqrt((e.target.y() - (shape.y)) ** 2 + (e.target.x() - shape.x) ** 2) + shape.offsetY * shape.scaleY;\n\n      //let last_offsetX=shape.offsetX;\n      let last_offsetY = shape.offsetY;\n      if (shape == undefined) {\n        shape = this.groups.find((r) => r.id == this.selectedShapeId).line;\n\n      } else {\n\n        if (shape.className == \"Rect\") {\n          threshold1 = shape.height * shape.scaleY / 3;\n          threshold2 = shape.height * shape.scaleY * 2 / 3;\n          if (dist >= threshold1 && dist <= threshold2) {\n            shape.offsetX = shape.width / 2;\n            shape.offsetY = shape.height / 2;\n            shape.centerPosition = \"Middle\";\n          } else if (dist > threshold2) {\n            shape.offsetX = shape.width / 2;\n            shape.offsetY = shape.height;\n            shape.centerPosition = \"Bottom\";\n          }\n          else {\n            shape.offsetX = shape.width / 2;\n            shape.offsetY = 0;\n            shape.centerPosition = \"Top\";\n          }\n        }\n        else if (shape.className == \"Circle\") {\n          dist = dist + shape.radius * shape.scaleY;\n          threshold1 = shape.radius * shape.scaleY * 2 / 3;\n          threshold2 = shape.radius * shape.scaleY * 4 / 3;\n          if (dist >= threshold1 && dist <= threshold2) {\n            shape.offsetX = 0;\n            shape.offsetY = 0;\n            shape.centerPosition = \"Middle\";\n          } else if (dist > threshold2) {\n            shape.offsetX = 0;\n            shape.offsetY = shape.radius;\n            shape.centerPosition = \"Bottom\";\n          } else {\n            shape.offsetX = 0;\n            shape.offsetY = -shape.radius;\n            shape.centerPosition = \"Top\";\n          }\n        }\n        else if (shape.className == \"Image\") {\n          threshold1 = shape.image.height * shape.scaleY / 3;\n          threshold2 = shape.image.height * shape.scaleY * 2 / 3;\n          if (dist >= threshold1 && dist <= threshold2) {\n            shape.offsetX = shape.image.width / 2;\n            shape.offsetY = shape.image.height / 2;\n            shape.centerPosition = \"Middle\";\n          } else if (dist > threshold2) {\n            shape.offsetX = shape.image.width / 2;\n            shape.offsetY = shape.image.height;\n            shape.centerPosition = \"Bottom\";\n          }\n          else {\n            shape.offsetX = shape.image.width / 2;\n            shape.offsetY = 0;\n            shape.centerPosition = \"Top\";\n          }\n        }\n        else if (shape.className == \"Text\") {\n          threshold1 = shape.length_y * shape.scaleY / 3;\n          threshold2 = shape.length_y * shape.scaleY * 2 / 3;\n          if (dist >= threshold1 && dist <= threshold2) {\n            shape.offsetX = shape.length_x / 2;\n            shape.offsetY = shape.length_y / 2;\n            shape.centerPosition = \"Middle\";\n          } else if (dist > threshold2) {\n            shape.offsetX = shape.length_x / 2;\n            shape.offsetY = shape.length_y;\n            shape.centerPosition = \"Bottom\";\n          }\n          else {\n            shape.offsetX = shape.length_x / 2;\n            shape.offsetY = 0;\n            shape.centerPosition = \"Top\";\n          }\n        }\n        else if (shape.className == \"Triangle\") {\n          dist = dist + shape.radius * shape.scaleY;\n          threshold1 = shape.radius * shape.scaleY / 2;\n          threshold2 = shape.radius * shape.scaleY * 5 / 4;\n          if (dist >= threshold1 && dist <= threshold2) {\n            shape.offsetX = 0;\n            shape.offsetY = 0;\n          } else if (dist > threshold2) {\n            shape.offsetX = 0;\n            shape.offsetY = shape.radius / 2\n            shape.centerPosition = \"Bottom\";\n          }\n          else {\n            shape.offsetX = 0;\n            shape.offsetY = -shape.radius;\n            shape.centerPosition = \"Top\";\n          }\n        }\n        shape.y = shape.y - (last_offsetY - shape.offsetY) * shape.scaleY * Math.cos(shape.rotation * (Math.PI / 180));\n        shape.x = shape.x + (last_offsetY - shape.offsetY) * shape.scaleY * Math.sin(shape.rotation * (Math.PI / 180));\n        this.selectedShapeAlignment = shape.centerPosition;\n\n        if (res.grp_id != '-1') {\n          this.updateAllPosInGrp(res.grp_id);\n        }\n\n        e.target.x(shape.x);\n        e.target.y(shape.y);\n\n\n\n\n      }\n    },\n\n\n    ChangeAlignCenter(align_choice) {\n      let center = CenterMenu.props.ConcernedShape;\n      let grp = this.groups.find((r) => r.id === this.selectedShapeId);\n      let shape;\n      if (grp != undefined) {\n        for (let i = 0; i < grp.shapes_g.length; i++) {\n          this.ChangeCenterRegardingCommand(grp.shapes_g[i].id, align_choice)\n        }\n        center.x(grp.line.x);\n        center.y(grp.line.y);\n        if (grp.line.defaultAlignment == align_choice) {\n          grp.line.defaultAlignment = '' //If we select again the same align_choice, we deselect it, no alignement center is fixed.\n        } else {\n          grp.line.defaultAlignment = align_choice;\n        }\n        this.selectedShapeAlignment = grp.line.defaultAlignment;\n        this.updateNaration(grp);\n      } else {\n        shape = this.findShape(this.selectedShapeId).shape_data;\n        this.ChangeCenterRegardingCommand(shape.id, align_choice)\n        this.selectedShapeAlignment = shape.centerPosition;\n        center.x(shape.x);\n        center.y(shape.y);\n      }\n    },\n\n    //Allow to change the center regarding a text command (Top,Middle or Bottom)\n    ChangeCenterRegardingCommand(shape_id, command) {\n      let res = this.findShape(shape_id);\n      let shape = res.shape_data;\n      let last_offsetY = shape.offsetY;\n      if (shape.className == \"Rect\") {\n        if (command == \"Top\") {\n          shape.offsetY = 0;\n          shape.offsetX = shape.width / 2;\n        }\n        else if (command == \"Middle\") {\n          shape.offsetX = shape.width / 2;\n          shape.offsetY = shape.height / 2;\n        } else if (command == \"Bottom\") {\n          shape.offsetX = shape.width / 2;\n          shape.offsetY = shape.height;\n        }\n      }\n      else if (shape.className == \"Circle\") {\n        if (command == \"Top\") {\n          shape.offsetX = 0;\n          shape.offsetY = -shape.radius;\n        } else if (command == \"Middle\") {\n          shape.offsetX = 0;\n          shape.offsetY = 0\n        } else if (command == \"Bottom\") {\n          shape.offsetX = 0;\n          shape.offsetY = shape.radius;\n        }\n      }\n      else if (shape.className == \"Image\") {\n        if (command == \"Middle\") {\n          shape.offsetX = shape.image.width / 2;\n          shape.offsetY = shape.image.height / 2;\n        } else if (command == \"Bottom\") {\n          shape.offsetX = shape.image.width / 2;\n          shape.offsetY = shape.image.height;\n        }\n        else if (command == \"Top\") {\n          shape.offsetX = shape.image.width / 2;\n          shape.offsetY = 0;\n        }\n      }\n      else if (shape.className == \"Text\") {\n        if (command == \"Middle\") {\n          shape.offsetX = shape.length_x / 2;\n          shape.offsetY = shape.length_y / 2;\n        } else if (command == \"Bottom\") {\n          shape.offsetX = shape.length_x / 2;\n          shape.offsetY = shape.length_y;\n        }\n        else if (command == \"Top\") {\n          shape.offsetX = shape.length_x / 2;\n          shape.offsetY = 0;\n        }\n      }\n      else if (shape.className == \"Triangle\") {\n        if (command == \"Middle\") {\n          shape.offsetX = 0;\n          shape.offsetY = 0;\n        } else if (command == \"Bottom\") {\n          shape.offsetX = 0;\n          shape.offsetY = shape.radius / 2;\n        }\n        else if (command == \"Top\") {\n          shape.offsetX = 0;\n          shape.offsetY = -shape.radius;\n        }\n      }\n      shape.centerPosition = command;\n      shape.y = shape.y - (last_offsetY - shape.offsetY) * shape.scaleY * Math.cos(shape.rotation * (Math.PI / 180));\n      shape.x = shape.x + (last_offsetY - shape.offsetY) * shape.scaleY * Math.sin(shape.rotation * (Math.PI / 180));\n\n      if (res.grp_id != '-1') {\n        this.updateAllPosInGrp(res.grp_id);\n      }\n\n      //center.x(shape.x);\n      //center.y(shape.y);\n    },\n    updateDragFuncOfCenter() {\n      let shape = this.findShape(this.selectedShapeId).shape_data\n      if (shape == undefined) {\n        return;\n      }\n      let center = this.center;\n      let angle = shape.rotation * (Math.PI / 180);\n      if (angle >= -Math.PI / 2 && angle <= 0) {\n        angle -= 90 * (Math.PI / 180);\n      } else if (angle < -Math.PI / 2) {\n        angle += (Math.PI / 2);\n        angle = Math.PI + angle;\n      } else if (angle <= Math.PI && angle > 0) {\n        angle -= 90 * (Math.PI / 180);\n      }\n      if (angle <= 0 && angle >= -Math.PI / 4) {\n        center.dragBoundFunc = function (pos) {\n          return {\n            x: shape.x + (pos.x - shape.x) * Math.cos(angle),\n            y: shape.y + (pos.x - shape.x) * Math.sin(angle),\n          };\n        }\n      } else if (angle < -Math.PI / 4 && angle >= -Math.PI / 2) {\n        center.dragBoundFunc = function (pos) {\n          return {\n            x: shape.x - (pos.y - shape.y) * Math.cos(angle),\n            y: shape.y - (pos.y - shape.y) * Math.sin(angle),\n          };\n        }\n      }\n      else if (angle < -Math.PI / 2 && angle >= -3 * Math.PI / 4) {\n        center.dragBoundFunc = function (pos) {\n          return {\n            x: shape.x - (pos.y - shape.y) * Math.cos(angle),\n            y: shape.y - (pos.y - shape.y) * Math.sin(angle),\n          };\n        }\n      } else if (angle < -3 * Math.PI / 4 && angle >= -Math.PI) {\n        center.dragBoundFunc = function (pos) {\n          return {\n            x: shape.x - (pos.x - shape.x) * Math.cos(angle),\n            y: shape.y - (pos.x - shape.x) * Math.sin(angle),\n          };\n        }\n      } else if (angle <= Math.PI && angle >= 3 * Math.PI / 4) {\n        center.dragBoundFunc = function (pos) {\n          return {\n            x: shape.x - (pos.x - shape.x) * Math.cos(angle),\n            y: shape.y - (pos.x - shape.x) * Math.sin(angle),\n          };\n        }\n      } else if (angle < 3 * Math.PI / 4 && angle >= Math.PI / 2) {\n        center.dragBoundFunc = function (pos) {\n          return {\n            x: shape.x + (pos.y - shape.y) * Math.cos(angle),\n            y: shape.y + (pos.y - shape.y) * Math.sin(angle),\n          };\n        }\n      } else if (angle < Math.PI / 2 && angle >= Math.PI / 4) {\n        center.dragBoundFunc = function (pos) {\n          return {\n            x: shape.x + (pos.y - shape.y) * Math.cos(angle),\n            y: shape.y + (pos.y - shape.y) * Math.sin(angle),\n          };\n        }\n      } else if (angle < Math.PI / 4 && angle >= 0) {\n        center.dragBoundFunc = function (pos) {\n          return {\n            x: shape.x + (pos.x - shape.x) * Math.cos(angle),\n            y: shape.y + (pos.x - shape.x) * Math.sin(angle),\n          };\n        }\n      }\n    },\n    /*\n    //called when the \"Change Center\" button is clicked\n    ChangeCenterButtonAction(){\n        let shape= ContextMenu.props.ConcernedShape;\n        if(shape.attrs.className==\"Line\"){\n          let shapes_g=shape.getParent().attrs.shapes_g //the list of the shapes which are on the line is in the corresponding group.\n          for (let j=0;j<shapes_g.length;j++){\n            this.ChangeCenter(shapes_g[j]);\n          }\n        }else{\n          let shape_data=this.shapes.find(i => i.id ===shape.attrs.id);\n          let isFunded=true;\n          if(shape_data==undefined){\n            isFunded=false;\n          }\n          let i=0;\n          while(!isFunded){\n            if(i<this.groups.length){\n              shape_data=this.groups[i].shapes_g.find(i => i.id === shape.attrs.id);\n            if(shape_data==undefined){\n              isFunded=false;\n            }else{\n              isFunded=true;\n            }\n            i++;\n            }else{        \n              isFunded=true;\n            }\n          }\n          this.ChangeCenter(shape_data)\n        }\n      },\n      */\n\n    //allow to copy a target\n\n    /*\n    Copy(){\n      ContextMenu.props.CopiedShape=ContextMenu.props.ConcernedShape;\n      ContextMenu.props.pastOneObject=true;\n    },\n    \n    CopyAll(){\n      ContextMenu.props.CopiedShape=ContextMenu.props.ConcernedShape;\n      ContextMenu.props.pastOneObject=false;\n    },\n    \n    Past(){   \n      //Prevent error when no shape is copied\n      if(ContextMenu.props.CopiedShape.attrs==undefined){\n        return;\n      }\n      let clone=ContextMenu.props.CopiedShape.clone({\n        id: ''+this.max_id_figures,\n      })\n      //let layer=ContextMenu.props.CopiedShape.getLayer();\n      let i= this.groups.length\n      //let new_id=i+1;\n      if(ContextMenu.props.CopiedShape.attrs.className==\"Line\"){\n        this.max_id_figures=this.max_id_figures+1;\n        if(!ContextMenu.props.pastOneObject){\n          //let i= this.groups.length;\n          //let new_id=i+1;\n        \n          clone=ContextMenu.props.CopiedShape.getParent().clone({\n            id: ''+ this.max_id_figures,\n            name: \"group\"+this.max_id_figures,\n            shapes_g:[],\n          })\n          clone.attrs.line.id=''+this.max_id_figures;\n          clone.attrs.line.x=ContextMenu.props.ConcernedShape.getStage().getPointerPosition().x;\n          clone.attrs.line.y=ContextMenu.props.ConcernedShape.getStage().getPointerPosition().y;\n          let positionPoints=Object.assign([],clone.attrs.line.positionPoints);\n            let length=positionPoints.length;\n            clone.attrs.line.positionPoints=[];\n            for(let i=0;i<length.valueOf();i++){\n              let clone_positionPoint=ContextMenu.props.CopiedShape.getParent().getChildren().find((r)=>r.attrs.id===positionPoints[i].id).clone({\n              id:'positionPoint'+clone.attrs.line.id+i,\n              });\n              clone.attrs.line.positionPoints.push(clone_positionPoint.attrs,);\n            }\n          \n          //layer= ContextMenu.props.CopiedShape.getParent().getLayer();\n          this.groups.push(clone.attrs,);\n          let shapesg=this.groups[this.groups.indexOf(this.groups.find((r)=> r.id==ContextMenu.props.CopiedShape.getParent().attrs.id))].shapes_g;\n          let shapesg_length=shapesg.length;\n          for (let j=0; j<shapesg_length;j++){\n            this.max_id_figures=this.max_id_figures + 1;\n            let clone_shape=ContextMenu.props.CopiedShape.getParent().getChildren().find((r)=>r.attrs.id===shapesg[j].id).clone({\n              id:''+this.max_id_figures,\n            });\n           // this.updateDragFunc(clone_shape,clone_line);\n            this.groups[i].shapes_g.push(clone_shape.attrs,);\n            this.updateDragFunc(this.groups[i].shapes_g[this.groups[i].shapes_g.length-1],this.groups[i].line);\n          }\n          this.updateAllPosInGrp(clone.attrs.id);\n        }else{\n          //let i= this.groups.length;\n          //let new_id=i+1;\n        \n          clone=ContextMenu.props.CopiedShape.getParent().clone({\n            id: ''+this.max_id_figures,\n            name: \"group\"+this.max_id_figures,\n            shapes_g:[],\n          })\n          clone.attrs.line.id=''+this.max_id_figures;\n          clone.attrs.line.x=ContextMenu.props.ConcernedShape.getStage().getPointerPosition().x;\n          clone.attrs.line.y=ContextMenu.props.ConcernedShape.getStage().getPointerPosition().y;\n          for(let j=0;j<clone.attrs.line.occupiedDistances.length;j++){\n            clone.attrs.line.freeDistances.push(clone.attrs.line.occupiedDistances[j],);\n          }\n          clone.attrs.line.occupiedDistances=[];\n          if(clone.attrs.line.keepDistribution!=1){\n            let positionPoints=Object.assign([],clone.attrs.line.positionPoints);\n            let length=positionPoints.length;\n            clone.attrs.line.positionPoints=[];\n            for(let i=0;i<length.valueOf();i++){\n              let clone_positionPoint=ContextMenu.props.CopiedShape.getParent().getChildren().find((r)=>r.attrs.id===positionPoints[i].id).clone({\n              id:'positionPoint'+clone.attrs.line.id+i,\n              });\n              clone.attrs.line.positionPoints.push(clone_positionPoint.attrs,);\n            }\n          }\n          //layer= ContextMenu.props.CopiedShape.getParent().getLayer();\n          this.groups.push(clone.attrs,)\n        }\n        //In order to actualize the new line (in particular to show the positionPoints):\n        this.updateAllPosInGrp(clone.attrs.id)\n      } \n      else{\n        this.max_id_figures=this.max_id_figures + 1;\n        clone=ContextMenu.props.CopiedShape.clone({\n          id: ''+this.max_id_figures,  \n          x:ContextMenu.props.ConcernedShape.getStage().getPointerPosition().x,\n          y:ContextMenu.props.ConcernedShape.getStage().getPointerPosition().y,\n        });\n        clone.attrs.dragBoundFunc=function (pos) {\n          return {\n            x: pos.x,\n            y: pos.y,\n          };\n        };\n        clone.attrs.isGrouped=0;\n        this.shapes.push(clone.attrs,); \n         \n      }\n      //layer.batchDraw(); \n      \n    },\n    \n    //RemoveShape(shape)\n    Remove(shape){\n      //let shape=ContextMenu.props.ConcernedShape;\n      if(shape.attrs.className==\"Line\"){\n        let grp=this.groups.find((r)=>r.id===shape.attrs.id);\n        const length=grp.shapes_g.length;\n        for(let i=0;i<length;i++){\n          grp.shapes_g[i].dragBoundFunc= dragFunc;\n          grp.shapes_g[i].isGrouped=0;\n          this.shapes.push(grp.shapes_g[i],);\n        }\n        this.eraseNodefromTransformer(\"lineTransformer\");\n        this.groups.splice(this.groups.indexOf(grp),1);\n        shape.getParent().destroy();\n\n        //We give to the circle (representing center of shapes) a default position\n        if(this.groups[0]!=undefined){\n          this.center.x=this.groups[0].line.x;\n          this.center.y=this.groups[0].line.y;\n        } else if(this.shapes[0]!=undefined){\n          this.center.x=this.shapes[0].x;\n          this.center.y=this.shapes[0].y;\n        }\n        this.center.opacity=0;\n        \n      }else if(shape.attrs.className==\"positionPoint\"){\n        let line=shape.getParent().attrs.line;\n        let target_positionPoint=line.positionPoints.find((r)=>r.id===shape.attrs.id);\n        let index=line.freeDistances.indexOf(shape.attrs.distance_to_line_center);\n        console.log(line.positionPoints);\n        if(line.keepDistribution!=1 && index!=-1){\n          line.freeDistances.splice(index,1);\n          line.positionPoints.splice(line.positionPoints.indexOf(target_positionPoint),1)\n        }\n      }\n      else{\n        let res=this.findShape(shape.attrs.id)\n        let shape_data=res.shape_data;\n        let grp_id=res.grp_id;\n        if(shape_data!=undefined){\n        if(grp_id!='-1'){\n        //let shape_data=this.shapes.find(i => i.id ===shape.attrs.id);\n        let grp=this.groups.find((r)=>r.id===grp_id);\n          grp.line.freeDistances.push(grp.line.occupiedDistances[grp.shapes_g.indexOf(shape_data)],)\n          grp.line.occupiedDistances.splice(grp.shapes_g.indexOf(shape_data),1)\n          \n          grp.shapes_g.splice(grp.shapes_g.indexOf(shape_data),1);\n          this.updateOccupiedDistance(grp.id);\n          \n          this.updateAllPosInGrp(grp.id);\n          \n         console.log(grp.line.positionPoints)\n      \n        } else{\n          this.eraseNodefromTransformer(\"shapeTransformer\");\n          this.shapes.splice(this.shapes.indexOf(shape_data),1);\n          //We give to the circle (representing center of shapes) a default position\n          if(this.groups[0]!=undefined){\n            this.center.x=this.groups[0].line.x;\n            this.center.y=this.groups[0].line.y;\n          } else if(this.shapes[0]!=undefined){\n            this.center.x=this.shapes[0].x;\n            this.center.y=this.shapes[0].y;\n          }\n          this.center.opacity=0;\n        }\n        shape.destroy();\n        }\n      }\n    },\n\n    RemoveAll(){\n      let shape=ContextMenu.props.ConcernedShape;\n      if(shape.className==\"Line\"){\n        let grp=this.groups.find((r)=>r.id===shape.attrs.id);\n        while(grp.shapes_g.length!=0){\n          grp.shapes_g[0].dragBoundFunc= dragFunc;\n          grp.shapes_g.splice(0,1);\n        }\n        this.eraseNodefromTransformer(\"lineTransformer\");\n        this.groups.splice(this.groups.indexOf(grp),1);\n        shape.getParent().destroy();\n\n        //We give to the circle (representing center of shapes) a default position\n        if(this.groups[0]!=undefined){\n          this.center.x=this.groups[0].line.x;\n          this.center.y=this.groups[0].line.y;\n        } else if(this.shapes[0]!=undefined){\n          this.center.x=this.shapes[0].x;\n          this.center.y=this.shapes[0].y;\n        }\n        \n      }else{\n        return;\n      }\n    },\n    */\n\n    findShape(id) {\n      let shape_data = this.shapes.find(i => i.id === id);\n      let grp_id = '-1'; // return grp_id=-1 if the shape doesn't belong to attached group.\n      let isFunded = true;\n      if (shape_data == undefined) {\n        isFunded = false;\n      }\n      let i = 0;\n      while (!isFunded) {\n        if (i < this.groups.length) {\n          shape_data = this.groups[i].shapes_g.find(i => i.id === id);\n          if (shape_data == undefined) {\n            isFunded = false;\n          } else {\n            grp_id = this.groups[i].id;\n            isFunded = true;\n          }\n          i++;\n        } else {\n          isFunded = true;\n        }\n      }\n      return { shape_data, grp_id }\n    },\n\n    //detach a shape from its line.\n    DetachShape(shape, target_x, target_y) {\n\n\n      const added_distance = this.lengthToCapture + 5;\n      let grp = this.groups.find((r) => r.shapes_g.indexOf(shape) != -1);\n      let i = grp.shapes_g.indexOf(shape);\n\n      shape.dragBoundFunc = dragFunc;\n\n      let coord_y1 = grp.line.y - grp.line.points[4] * (1 / 2) * grp.line.scaleX * Math.sin(grp.line.rotation * (Math.PI / 180));\n      let coord_x2 = grp.line.x + grp.line.points[4] * (1 / 2) * grp.line.scaleX * Math.cos(grp.line.rotation * (Math.PI / 180));\n      let coord_y2 = grp.line.y + grp.line.points[4] * (1 / 2) * grp.line.scaleX * Math.sin(grp.line.rotation * (Math.PI / 180));\n      let coord_x1 = grp.line.x - grp.line.points[4] * (1 / 2) * grp.line.scaleX * Math.cos(grp.line.rotation * (Math.PI / 180));\n      let a = (coord_y2 - coord_y1) / (coord_x2 - coord_x1);\n      //let b=grp.line.y-a*grp.line.x;\n      let b = shape.x * (1 / a) + shape.y;\n      if (grp.line.rotation < 0 && grp.line.rotation > -45) {\n\n        shape.x = shape.x + Math.sign(shape.y - target_y) * added_distance * Math.sin(grp.line.rotation * (Math.PI / 180))\n        shape.y = -(1 / a) * shape.x + b\n      } else if (grp.line.rotation <= -45 && grp.line.rotation > -90) {\n\n        shape.x = shape.x + Math.sign(shape.x - target_x) * added_distance * Math.sin(grp.line.rotation * (Math.PI / 180))\n        shape.y = -(1 / a) * shape.x + b\n      }\n\n      else if (grp.line.rotation < -90 && grp.line.rotation > -135) {\n        shape.x = shape.x + Math.sign(shape.x - target_x) * added_distance * Math.sin(grp.line.rotation * (Math.PI / 180))\n        shape.y = -(1 / a) * shape.x + b\n      }\n      else if (grp.line.rotation <= -135 && grp.line.rotation > -180) {\n        shape.x = shape.x - Math.sign(shape.y - target_y) * added_distance * Math.sin(grp.line.rotation * (Math.PI / 180))\n        shape.y = -(1 / a) * shape.x + b\n      }\n\n      else if (grp.line.rotation > 135 && grp.line.rotation < 180) {\n\n        shape.x = shape.x - Math.sign(shape.y - target_y) * added_distance * Math.sin(grp.line.rotation * (Math.PI / 180))\n        shape.y = -(1 / a) * shape.x + b\n      } else if (grp.line.rotation > 90 && grp.line.rotation <= 135) {\n\n        shape.x = shape.x - Math.sign(shape.x - target_x) * added_distance * Math.sin(grp.line.rotation * (Math.PI / 180))\n        shape.y = -(1 / a) * shape.x + b\n      } else if (grp.line.rotation > 45 && grp.line.rotation <= 90) {\n\n        shape.x = shape.x - Math.sign(shape.x - target_x) * added_distance * Math.sin(grp.line.rotation * (Math.PI / 180))\n        shape.y = -(1 / a) * shape.x + b\n      } else if (grp.line.rotation > 0 && grp.line.rotation <= 45) {\n\n        shape.x = shape.x + Math.sign(shape.y - target_y) * added_distance * Math.sin(grp.line.rotation * (Math.PI / 180))\n        shape.y = -(1 / a) * shape.x + b\n      }\n      else if (grp.line.rotation == -90) {\n        shape.x = shape.x - Math.sign(shape.x - target_x) * added_distance\n      } else if (grp.line.rotation == 90) {\n        shape.x = shape.x + Math.sign(shape.x - target_x) * added_distance\n      } else if (grp.line.rotation == 180 || grp.line.rotation == -180) {\n        shape.y = shape.y - Math.sign(shape.y - target_y) * added_distance\n      } else if (grp.line.rotation == 0) {\n        shape.y = shape.y - Math.sign(shape.y - target_y) * added_distance\n      }\n      //shape.rotation=shape.rotation+shape.personalRotation;\n      shape.isGrouped = 0;\n      this.shapes.push(shape,)\n      this.center.x = shape.x;\n      this.center.y = shape.y;\n      grp.line.freeDistances.push(grp.line.occupiedDistances[i]);\n      grp.line.occupiedDistances.splice(i, 1);\n      grp.shapes_g.splice(i, 1);\n      if (grp.line.keepDistribution) {\n        grp.line.positionPoints.splice(i, 1)\n      }\n      this.updateOccupiedDistance(grp.id)\n      this.updateAllPosInGrp(grp.id)\n      this.updateNaration(grp)\n\n      this.eraseNodefromTransformer(\"shapeTransformer\");\n\n    },\n    /*\n    DetachShape(shape){\n      \n      \n      const added_distance=this.lengthToCapture+5;\n      let grp=this.groups.find((r)=>r.shapes_g.indexOf(shape)!=-1);\n      let i=grp.shapes_g.indexOf(shape);\n      \n      shape.dragBoundFunc= dragFunc;\n\n      let coord_y1=grp.line.y-grp.line.points[4]*(1/2)*grp.line.scaleX*Math.sin(grp.line.rotation*(Math.PI/180));\n      let coord_x2=grp.line.x+grp.line.points[4]*(1/2)*grp.line.scaleX*Math.cos(grp.line.rotation*(Math.PI/180));\n      let coord_y2= grp.line.y+grp.line.points[4]*(1/2)*grp.line.scaleX*Math.sin(grp.line.rotation*(Math.PI/180));\n      let coord_x1=grp.line.x-grp.line.points[4]*(1/2)*grp.line.scaleX*Math.cos(grp.line.rotation*(Math.PI/180));\n      let a=(coord_y2-coord_y1)/(coord_x2-coord_x1);\n      //let b=grp.line.y-a*grp.line.x;\n      let b=shape.x*(1/a)+shape.y;\n      if (grp.line.rotation<0 && grp.line.rotation>-90){\n        \n        shape.x=shape.x-added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } else if(grp.line.rotation<-90){\n        shape.x=shape.x-added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } else if( grp.line.rotation>0 && grp.line.rotation<180){\n        \n        shape.x=shape.x+added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } \n      else if(grp.line.rotation==-90){\n        shape.x=shape.x+added_distance\n      } else if(grp.line.rotation==90){\n        shape.x=shape.x-added_distance\n      } else if(grp.line.rotation==180 || grp.line.rotation==-180){\n        shape.y=shape.y-added_distance\n      } else if(grp.line.rotation==0){\n        shape.y=shape.y+added_distance\n      } \n      //shape.rotation=shape.rotation+shape.personalRotation;\n      shape.isGrouped=0;\n      this.shapes.push(shape,)\n      this.center.x=shape.x;\n      this.center.y=shape.y;\n      grp.line.freeDistances.push(grp.line.occupiedDistances[i]);\n      grp.line.occupiedDistances.splice(i,1);\n      grp.shapes_g.splice(i,1);\n      grp.line.positionPoints.splice(i,1)\n      \n      this.updateOccupiedDistance(grp.id)\n      this.updateAllPosInGrp(grp.id)\n    \n    },\n    */\n\n\n    //called when the button \"Detach Shape\" is clicked\n    DetachShapeButtonAction() {\n      let shape = ContextMenu.props.ConcernedShape;\n      if (shape.attrs.className == \"Line\") {\n        let shapes_g = shape.getParent().attrs.shapes_g;\n        while (shapes_g.length != 0) {\n          this.DetachShape(shapes_g[0]);\n        }\n      } else {\n        let shape_data = this.shapes.find(i => i.id === shape.attrs.id);\n        let isFunded = true;\n        if (shape_data == undefined) {\n          isFunded = false;\n        }\n        let i = 0;\n        while (!isFunded) {\n          if (i < this.groups.length) {\n            shape_data = this.groups[i].shapes_g.find(i => i.id === shape.attrs.id);\n            if (shape_data == undefined) {\n              isFunded = false;\n            } else {\n              isFunded = true;\n            }\n            i++;\n          } else {\n            isFunded = true;\n          }\n        }\n        this.DetachShape(shape_data)\n      }\n    },\n\n    //called when the button \"keep/liberate distribution\" is clicked.\n    KeepDistribution() {\n      let grp = this.groups.find(i => i.id === ContextMenu.props.ConcernedShape.attrs.id);\n      let line = grp.line;\n      if (line == undefined) {\n        return;\n      } else {\n        if (line.keepDistribution) {\n          line.keepDistribution = false;\n          for (let i = 0; i < grp.shapes_g.length; i++) {\n            grp.shapes_g[i].distance_to_line_center = line.occupiedDistances[i]\n          }\n          line.freeDistances = [];\n\n          line.stroke = 'blue'\n          grp.line.keepDistanceButtonText = \"Keep Distribution\";\n          //ContextMenu.props.ConcernedShape.attrs.keepDistanceButtonText=\"Keep Distribution\";\n        } else {\n          line.keepDistribution = true;\n          for (let i = 0; i < grp.shapes_g.length; i++) {\n            line.occupiedDistances[i] = grp.shapes_g[i].distance_to_line_center;\n          }\n          line.stroke = 'rgb(48,48,48)'\n          grp.line.keepDistanceButtonText = \"Liberate Distribution\";\n          //ContextMenu.props.ConcernedShape.attrs.keepDistanceButtonText=\"Liberate Distribution\";\n          this.updateOccupiedDistance(line.id);\n          this.updateAllPosInGrp(line.id);\n        }\n        this.updateNaration(grp);\n      }\n    },\n\n    createNewShape(shape) {\n      if (shape.attrs.className == \"Line\") {\n\n        this.max_id_figures = this.max_id_figures + 1;\n\n        let clone = shape.getParent().clone({\n          id: '' + this.max_id_figures,\n          name: \"group\" + this.max_id_figures,\n          shapes_g: [],\n        })\n        clone.attrs.line.id = '' + this.max_id_figures;\n        clone.attrs.line.x = shape.getStage().getPointerPosition().x;\n        clone.attrs.line.y = shape.getStage().getPointerPosition().y;\n        clone.attrs.line.draggable = true;\n        this.groups.push(clone.attrs,)\n\n\n      } else {\n\n        this.max_id_figures = this.max_id_figures + 1\n        let clone = shape.clone({\n          id: '' + this.max_id_figures,\n          draggable: true,\n        })\n        clone.attrs.isGrouped = 0;\n        this.shapes.push(clone.attrs,);\n      }\n\n\n    },\n\n\n    eraserAction(e) {\n      this.Remove(e.target);\n\n    },\n    unshowSelectedShape(e) {\n      if (e.target.attrs.className == \"Line\" && this.eraseMode == 0) {\n        e.target.opacity(0.5)\n      }\n      else if (e.target.attrs.className == \"Line\" && this.eraseMode == 1) {\n        if (e.target.attrs.keepDistribution == 1) {\n          e.target.stroke(\"rgb(48,48,48)\")\n        } else {\n          e.target.stroke(\"blue\")\n        }\n      }\n      else if (e.target.attrs.className == \"positionPoint\" && this.eraseMode == 1) {\n        if (e.target.getParent().attrs.line.keepDistribution != 1) {\n          e.target.strokeWidth(0)\n        }\n      }\n      else if (this.eraseMode == 1) {\n        e.target.strokeWidth(0)\n      }\n    },\n    showSelectedShape(e) {\n      if (e.target.attrs.className == \"Line\" && this.eraseMode == 0) {\n        e.target.opacity(1)\n      }\n      else if (e.target.attrs.className == \"Line\" && this.eraseMode == 1) {\n        e.target.stroke('rgb(200, 59, 218)')\n      }\n      else if (e.target.attrs.className == \"positionPoint\" && this.eraseMode == 1) {\n        let line = e.target.getParent().attrs.line;\n        if (line.freeDistances.indexOf(e.target.attrs.distance_to_line_center) != -1) {\n          if (line.keepDistribution != 1) {\n            e.target.stroke('rgb(200, 59, 218)')\n            e.target.strokeWidth(3)\n          }\n        }\n      }\n      else if (this.eraseMode == 1) {\n        e.target.stroke('rgb(200, 59, 218)')\n        e.target.strokeWidth(3)\n      }\n      /*\n      let shape=e.target;\n      if(this.eraseMode==1){\n      let shape_data=this.shapes.find(i => i.id ===shape.attrs.id);\n      let isFunded=true;\n      if(shape_data==undefined){\n        isFunded=false;\n        let i=0;\n        while(!isFunded){\n          if(i<this.groups.length){\n            shape_data=this.groups[i].shapes_g.find(i => i.id === shape.attrs.id);\n          if(shape_data==undefined){\n            isFunded=false;\n            i++;\n          }else{\n            isFunded=true;\n          }\n          }else{        \n            isFunded=true;\n          }\n        }\n      }\n      if (shape_data!=undefined){\n        shape_data.opacity=0.3\n      }\n      */\n\n    },\n    editText(e) {\n      //let valuey=document.getElementById(\"stage\").style.top+e.target.y()\n      //let valuex=document.getElementById(\"stage\").style.left+e.target.x()\n      let stageBox = e.target.getStage().attrs.container.getBoundingClientRect();\n      document.getElementById(\"input\").style.top = stageBox.y + e.target.getAbsolutePosition().y + 'px';\n      document.getElementById(\"input\").style.left = stageBox.x + e.target.getAbsolutePosition().x - document.getElementById(\"input\").size * 5 + 'px';\n      document.getElementById(\"input\").style.display = \"initial\"\n      this.editedText = e.target\n    },\n    updateText(e) {\n      let shape = this.shapes.find(i => i.id === this.editedText.attrs.id);\n      let isFunded = true;\n      if (shape == undefined) {\n        isFunded = false;\n      }\n      let i = 0;\n      while (!isFunded) {\n        if (i < this.groups.length) {\n          shape = this.groups[i].shapes_g.find(i => i.id === this.editedText.attrs.id);\n          if (shape == undefined) {\n            isFunded = false;\n          } else {\n            isFunded = true;\n          }\n          i++;\n        } else {\n          isFunded = true;\n        }\n      }\n      if (shape != undefined) {\n        let last_width;\n        let last_height;\n        let diff_width;\n        let diff_height;\n\n        last_width = this.editedText.width();\n        last_height = this.editedText.height();\n\n        shape.text = e.target.value;\n\n        this.editedText.text(e.target.value);\n        diff_width = this.editedText.width() - last_width;\n        diff_height = this.editedText.height() - last_height;\n\n\n        shape.offsetX = shape.offsetX + diff_width / 2\n        shape.offsetY = shape.offsetY + diff_height / 2\n        shape.length_x = this.editedText.width()\n        shape.length_y = this.editedText.height()\n        document.getElementById(\"input\").style.display = \"none\"\n      }\n\n    },\n    updateNaration(grp) {\n      let text;\n      if (grp.line.keepDistribution == true) {\n        text = \"<mark class='black'> The Stickyline preserves alignment and distribution.</mark><br>\";\n      } else {\n        text = \"<mark class='blue'> The Stickyline only preserves alignment. </mark><br>\";\n      }\n      text = text + \"<strong>Substrate :</strong><br>\"\n      text = text + \"- <mark class='blue'> StickyLine </mark> with size=\" + grp.line.points[4] * grp.line.scaleX.toFixed(2)\n        + \"<br> and rotation=\" + grp.line.rotation.toFixed(1) + \"<br>\";\n      if (grp.line.keepDistribution == true) {\n        text = text + \"Relation: \" + grp.line.defaultAlignment + \" <i>alignement and distribution with</i>:\"\n      } else {\n        text = text + \"Relation: \" + grp.line.defaultAlignment + \" <i>alignement with</i>:\";\n      }\n      for (let j = 0; j < grp.shapes_g.length; j++) {\n        text = text + \"<br>\" + \"- \" + grp.shapes_g[j].className\n      }\n      this.$emit('explain', { origin: \"Substrate - Appropriability<br><mark class='blue'> The substrate supports user customization and updates itself. </mark>\", text: text });\n    }\n  },\n};\n\n</script>\n<style>\n#playground {\n  cursor: default\n}\n\n#activeReuseSubstrate {\n  position: absolute;\n  display: none;\n  top: 0px;\n  left: 0px;\n  width: 60px;\n  background-color: white;\n  box-shadow: 0 0 5px grey;\n  border-radius: 3px;\n}\n\n#center_menu {\n  position: absolute;\n  display: none;\n  top: 0px;\n  left: 0px;\n  width: 60px;\n  background-color: white;\n  box-shadow: 0 0 5px grey;\n  border-radius: 3px;\n}\n\ninput {\n  position: absolute;\n  display: none;\n  top: 0px;\n  left: 0px;\n}\n</style> ","<template>\n\n<!--Menu that appear when right click on the center-->\n\n<div id=\"menu\">\n<button id=\"Top\" :style=\"style\" @click=\"GenerateButtonEvent\" @mouseover=\"onHover\">Top</button>\n<button id=\"Middle\" :style=\"style\" @click=\"GenerateButtonEvent\">Middle</button>\n<button id=\"Bottom\" :style=\"style\" @click=\"GenerateButtonEvent\">Bottom</button>\n</div>\n</template>\n<script>\n\n\nexport default {\n    props: {\n        displayMenu: String,\n        ConcernedShape: Object,\n        //CopiedShape: Object,\n        defaultAlignment: String, //string to tell position of the center\n        color:{\n          type: String,\n          default: 'white'\n        },\n    },\n    data(){\n        return{   \n            style: {\n              '--top_button_color':'white',\n              '--middle_button_color':'grey',\n              '--bottom_button_color':'white',\n            }\n        }\n    },\n    watch: {\n      defaultAlignment:function(newVal,oldVal){\n        if(newVal!=oldVal){\n          this.update()\n        }\n      }\n    },\n    methods:{\n\n      //update the menu so that the current position of the center is colored in gray.\n      update(){\n        if(this.defaultAlignment==\"Middle\"){\n          this.style={'--top_button_color':'white','--middle_button_color':'grey','--bottom_button_color':'white',}\n              \n        }else if(this.defaultAlignment==\"Top\"){\n          this.style={'--top_button_color':'grey','--middle_button_color':'white','--bottom_button_color':'white',} \n        }\n        else if(this.defaultAlignment==\"Bottom\"){\n          this.style={'--top_button_color':'white','--middle_button_color':'white','--bottom_button_color':'grey',}\n        }\n        else{\n          this.style= {'--top_button_color':'white','--middle_button_color':'white','--bottom_button_color':'white',}\n        }\n      },\n\n      //Wen we click on a button,we emit the corresponding event.\n      GenerateButtonEvent(e){\n        if(e.target.id==\"Top\"){\n          this.$emit('center-button', \"Top\");\n        }\n        if(e.target.id==\"Middle\"){\n          this.$emit('center-button',\"Middle\");\n        }\n        if(e.target.id==\"Bottom\"){\n          this.$emit('center-button',\"Bottom\");\n        }\n\n      },\n    },\n}\n</script>\n<style scoped>\n     body {\n        margin: 0;\n        padding: 0;\n        overflow: hidden;\n        background-color: #f0f0f0;\n      }\n\n      #menu {\n        display: initial;\n        position: absolute;\n        background-color: white;\n        box-shadow: 0 0 5px grey;\n        border-radius: 3px;\n      }\n\n      #menu #Top {\n        width: 100%;\n        border: none;\n        margin: 0;\n        background-color: var(--top_button_color);\n        padding: 10px;\n      }\n\n\n      #menu #Top:hover {\n        background-color: lightgray;\n      }\n      #menu #Middle {\n        width: 100%;\n        border: none;\n        margin: 0;\n        background-color: var(--middle_button_color);\n        padding: 10px;\n      }\n\n\n      #menu #Middle:hover {\n        background-color: lightgray;\n      }\n      \n      #menu #Bottom {\n        width: 100%;\n        border: none;\n        margin: 0;\n        background-color: var(--bottom_button_color);\n        padding: 10px;\n      }\n\n\n      #menu #Bottom:hover {\n        background-color: lightgray;\n      }\n</style>","import { render } from \"./CenterMenu.vue?vue&type=template&id=5bb90ca6&scoped=true\"\nimport script from \"./CenterMenu.vue?vue&type=script&lang=js\"\nexport * from \"./CenterMenu.vue?vue&type=script&lang=js\"\n\nimport \"./CenterMenu.vue?vue&type=style&index=0&id=5bb90ca6&scoped=true&lang=css\"\n\nimport exportComponent from \"/Users/junhangyu/Desktop/PE code/github/teachingApp/node_modules/vue-loader/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render],['__scopeId',\"data-v-5bb90ca6\"]])\n\nexport default __exports__","import { render } from \"./AppropriabilitySubstrateDemo.vue?vue&type=template&id=7d705e28\"\nimport script from \"./AppropriabilitySubstrateDemo.vue?vue&type=script&lang=js\"\nexport * from \"./AppropriabilitySubstrateDemo.vue?vue&type=script&lang=js\"\n\nimport \"./AppropriabilitySubstrateDemo.vue?vue&type=style&index=0&id=7d705e28&lang=css\"\n\nimport exportComponent from \"/Users/junhangyu/Desktop/PE code/github/teachingApp/node_modules/vue-loader/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render]])\n\nexport default __exports__","<template>\n\n<div @click=\"HideContextMenu\" id=\"DiscoverabilitySubstrateDemo\"\n@mousedown=\"updateNaration(this.groups[0])\">\n<!--\n  <ToolBar :height=\"100\" :width=\"400\"\n  @need_new_shape=\"createNewShape\" @eraser_is_selected=\"switchEraseMode\"></ToolBar>\n  -->\n  <v-stage\n    ref=\"stage\"\n    id=\"stage\"\n    :config=\"stageSize\"\n    @dragmove=\"update\"\n    @mousedown=\"handleTransformation\"\n    @touchstart=\"handleTransformation\"\n    @fusion=\"makeGroup\"\n    @contextMenu=\"DisplayContextMenu\"\n  >\n    <v-layer ref=\"layer\">\n      <!--\n        see if a group should contain more than one line\n      -->\n      <!--\n      <v-circle :key=\"center.id\" :config=\"center\"/>\n      -->\n      <v-group ref=\"groups\" v-for=\"step in groups\" :key=\"step.id\" :config=\"step\">\n      \n      \n      \n        <v-rect\n        v-for=\"item in step.shapes_g.filter(i=>i.className=='Rect')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        \n       \n        @transformend=\"updateTransformedShape\"\n        @dragend= \"updatePosInGrp($event,step.id) \"\n        @dragmove=\"onDragging\"\n        @dragstart=\" initializeDragging\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n      />\n      <v-circle\n        v-for=\"item in step.shapes_g.filter(i=>i.className=='Circle')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragend=\"updatePosInGrp($event,step.id)\"\n        @dragmove=\"onDragging\"\n        @dragstart=\" initializeDragging\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n      />\n      \n      <v-image\n        v-for=\"item in step.shapes_g.filter(i=>i.className=='Image')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragend=\"updatePosInGrp($event,step.id)\"\n        @dragmove=\"onDragging\"\n        @dragstart=\" initializeDragging\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n      />\n      <v-text\n        v-for=\"item in step.shapes_g.filter(i=>i.className=='Text')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragend=\"updatePosInGrp($event,step.id)\"\n        @dragmove=\"onDragging\"\n        @dragstart=\" initializeDragging\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n\n        @dblclick=\"editText\"\n        />\n        <v-regular-polygon\n        v-for=\"item in step.shapes_g.filter(i=>i.className=='Triangle')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragend=\"updatePosInGrp($event,step.id)\"\n        @dragmove=\"onDragging\"\n        @dragstart=\" initializeDragging\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n      />\n        <v-line \n        :key=\"step.line.id\"\n        :config=\"step.line\"\n        @transformend=\"updateTransformedShape\"\n        @dragmove=\"updateGrp($event,step.id)\"\n        @mouseout=\"unshowSelectedShape\"\n        @mouseenter=\"showSelectedShape\"\n        />\n\n        <v-rect\n        v-for=\"item in step.ghosts.filter(i=>i.className=='Rect')\"\n        :key=\"item.id\"\n        :config=\"item\"\n      />\n      <v-circle\n        v-for=\"item in step.ghosts.filter(i=>i.className=='Circle')\"\n        :key=\"item.id\"\n        :config=\"item\"\n      />\n      <v-image\n        v-for=\"item in step.ghosts.filter(i=>i.className=='Image')\"\n        :key=\"item.id\"\n        :config=\"item\"\n      />\n      <v-text\n        v-for=\"item in step.ghosts.filter(i=>i.className=='Text')\"\n        :key=\"item.id\"\n        :config=\"item\"\n      />\n      <v-regular-polygon\n        v-for=\"item in step.ghosts.filter(i=>i.className=='Triangle')\"\n        :key=\"item.id\"\n        :config=\"item\"\n      />\n\n    <v-circle\n        v-for=\"item in step.line.positionPoints\"\n        :key=\"item.id\"\n        :config=\"item\"\n        \n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n      />\n      </v-group>\n      <v-rect\n        v-for=\"item in shapes.filter(i=>i.className=='Rect')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragmove=\"updatePos\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n        \n      />\n      \n      <v-circle\n        v-for=\"item in shapes.filter(i=>i.className=='Circle')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragmove=\"updatePos\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n        \n      />\n      <!--\n      <v-image\n        v-for=\"item in shapes.filter(i=>i.className=='Image')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragmove=\"updatePos\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n        />\n     \n      <v-text\n        v-for=\"item in shapes.filter(i=>i.className=='Text')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragmove=\"updatePos\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n        \n        @dblclick=\"editText\"\n        /> \n      -->\n      <v-regular-polygon\n        v-for=\"item in shapes.filter(i=>i.className=='Triangle')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragmove=\"updatePos\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n        />\n      \n      \n      <v-transformer  v-for=\"item in transformers\" :key=\"item.id\" :config=\"item\"/>\n      <v-circle :key=\"center.id\" :config=\"center\"\n      @dragend=\"ChangeCenter\"\n      @click=\"DisplayCenterMenu\"/>\n      <!--\n      <v-transformer id=\"shapeTransformer\"/>\n      <v-transformer id=\"lineTransformer\" :config=\"{enabledAnchors: ['middle-left', 'middle-right'],}\" />\n      -->\n    </v-layer>\n    \n  </v-stage>\n  \n  <!--\n  <div id=\"activeReuseSubstrate\">\n  <ContextMenu :menu-of-stage=\"isStageOnlySelected\" :menu-of-line=isALineSelected \n  :menu-of-grouped-shape=isAGroupedShapeSelected :keep-distance-button-text=\"this.keepDistanceButtonText\" \n  :need-copy-button=\"false\" :need-switch-distribution-mode-button=\"false\"\n  @changecenter-button=\"ChangeCenterButtonAction\" @detachshape-button=\"DetachShapeButtonAction\" @keepdistance-button=\"KeepDistribution\"\n  @copy-button=\"Copy\" @copy-all-button=\"CopyAll\" @past-button=\"Past\" @remove-button=\"Remove\" @remove-all-button=\"RemoveAll\"></ContextMenu>\n  </div>\n  -->\n  <!--\n  <div id=\"center_menu\">\n  <CenterMenu :defaultAlignment=\"this.selectedShapeAlignment\" @center-button=\"ChangeAlignCenter\"></CenterMenu>\n  </div>\n  -->\n  \n  <input type=\"text\" id=\"input\" \n        size=\"10\" value=\"a text\"\n       @keyup.enter=\"updateText\"\n       >\n  </div>\n</template>\n\n<script>\n\n//import ContextMenu from \"./ContextMenu.vue\"\n//import CenterMenu from \"./CenterMenu.vue\"\n//import ToolBar from \"./ToolBar.vue\";\n\nconst dragFunc=function (pos) {\n  let width=this.getStage().width();\n  let height=this.getStage().height();\n  let strokeSize=10\n    if(pos.x>width-strokeSize && pos.y>height-strokeSize){\n      return{\n        x: width-strokeSize,\n        y: height-strokeSize,\n      }\n    } else if(pos.x>width-strokeSize && pos.y<strokeSize){\n      return{\n        x: width-strokeSize,\n        y: strokeSize,\n      }\n    } else if(pos.y>height-strokeSize && pos.x<strokeSize){\n      return{\n        x: strokeSize,\n        y: height-strokeSize,\n      }\n    } else if(pos.x<strokeSize && pos.y<strokeSize){\n      return{\n        x: strokeSize,\n        y: strokeSize,\n      }\n    } else if(pos.x<strokeSize){\n      return{\n        x: strokeSize,\n        y: pos.y,\n      }\n    }else if(pos.y<strokeSize){\n      return{\n        x: pos.x,\n        y: strokeSize,\n      }\n    }else if(pos.x>width-strokeSize){\n      return{\n        x: width-strokeSize,\n        y: pos.y,\n      }\n    }else if(pos.y>height-strokeSize){\n      return{\n        x: pos.x,\n        y: height-strokeSize,\n      }\n    } else{\n      return {\n        x: pos.x,\n        y: pos.y,\n      };\n    }\n};\n\n\nexport default {\n  props:{\n    width:{\n      type: Number,\n      default:window.innerWidth,\n    },\n    height:{\n      type: Number,\n      default:window.innerHeight,\n    }\n  },\n  components:{\n    //ContextMenu,\n    //CenterMenu,\n    //ToolBar,\n},\n  data() {\n    return {\n      stageSize: {\n        width: this.width,\n        height: this.height,\n      },\n      lengthToCapture:10,\n      lengthToDetach:15,\n      editedText:null,\n\n      eraseMode:0,\n\n      selectedShapeAlignment:'',\n\n      neighbour:[],\n      dist_with_neighbour:null,\n      \n      needMenu: 'initial', //say if the context menu has to be \"active\" or not.\n      isALineSelected:false, \n      isAGroupedShapeSelected:false,\n      isStageOnlySelected: false,\n      //dragItemId: null, //id of the item which is dragging.\n      //text which will appear on the button corresponding to the management of the distribution\n      keepDistanceButtonText:\"Liberate Distribution\",\n      max_id_figures: 6, //max among id of shapes and line since the canvas exist (line excluded) \n      //max_id_lines: 2, //max among id of lines since the canvas exist (line excluded) \n      //groups of shapes (ie a line with shapes on it)\n      groups:[{\n        //rotation: 20,\n        name: \"group\",\n        className: \"Group\",\n        id: '1',\n        x:0,\n        y:0,\n        offsetX:0,\n        offsetY:0,\n        rotation: 0,\n        draggable: false,\n        ghosts:[],\n        shapes_g:[ {\n        rotation:0,\n        x: 30,\n        y: 220,\n        scaleX:1,\n        scaleY:1,\n        offsetX: 0,\n        offsetY: 40,\n        radius: 40,\n        fill: 'orange',\n        strokeWidth: 0,\n        stroke: 'black',\n        draggable:true,\n        isGrouped: 1,\n        className:\"Circle\",\n        /*When it is on a line, a shape can be rotate by the user independently from the line.\n          To keep the independant rotation of the attached shape, we add the parameter \"personalRotation\".\n          So, when the shape is attached, is final rotation is the sum of this parameter with the rotation of the line.\n          */\n        personalRotation:0, \n        id:'6',\n        dragBoundFunc: dragFunc,\n        centerPosition:'Bottom',\n      },{\n          rotation: 0,\n          id:'8',\n          x: 150,\n          y: 220,\n          width: 70,\n          height: 70,\n          scaleX: 1,\n          scaleY: 1,\n          strokeWidth: 0,\n          stroke: 'black',\n          opacity:1,\n          fill: 'green',\n          name: 'rect2',\n          draggable: true,\n          className:\"Rect\",\n          isGrouped: 0,\n          dragBoundFunc: dragFunc,\n          offsetX: 70/2,\n          offsetY: 70,\n          /*When it is on a line, a shape can be rotate by the user independently from the line.\n          To keep the independant rotation of the attached shape, we add the parameter \"personalRotation\".\n          So, when the shape is attached, is final rotation is the sum of this parameter with the rotation of the line.\n          */\n          personalRotation:0, \n          centerPosition:'Bottom',\n        },{\n          rotation: 0,\n          id:'7',\n          x: 250,\n          y: 220,\n          sides:3,\n          radius:45,\n          width: 90,\n          height: 90,\n          scaleX: 1,\n          scaleY: 1,\n          opacity:1,\n          strokeWidth: 0,\n          stroke: 'black',\n          fill: 'purple',\n          name: 'triangle1',\n          draggable: true,\n          className:\"Triangle\",\n          isGrouped: 0,\n          dragBoundFunc: dragFunc,\n          offsetX: 0,\n          offsetY: 22.5,\n          personalRotation:0, \n          centerPosition:'Bottom',\n        },], //list of shapes that are on the line\n        //the line of the group:\n        aShapeHasBeenDetach:0,\n        line:{\n          x:150,\n          y:220,\n          points: [0, 0, 0, 0, 250, 0],\n          positionPoints:[{\n        x: 300,\n        y: 500,\n        scaleX:1,\n        scaleY:1,\n        offsetX: 0,\n        offsetY: 0,\n        radius: 3,\n        opacity:1,\n        fill: 'yellow',\n        draggable:false,\n        isGrouped: 0,\n        className:\"positionPoint\",\n        id:'positionPoint1',\n        distance_to_line_center:undefined,\n      },{\n        x: 300,\n        y: 500,\n        scaleX:1,\n        scaleY:1,\n        offsetX: 0,\n        offsetY: 0,\n        radius: 3,\n        fill: 'yellow',\n        opacity:1,\n        draggable:false,\n        isGrouped: 0,\n        className:\"positionPoint\",\n        id:'positionPoint2',\n        distance_to_line_center:undefined,\n      },{\n        x: 300,\n        y: 500,\n        scaleX:1,\n        scaleY:1,\n        offsetX: 0,\n        offsetY: 0,\n        radius: 3,\n        fill: 'yellow',\n        opacity:1,\n        draggable:false,\n        isGrouped: 0,\n        className:\"positionPoint\",\n        id:'positionPoint3',\n        distance_to_line_center:undefined,\n      },],\n          strokeWidth: 10,\n          rotation: 0,\n          tension:0,\n          closed: true,\n          draggable: true,\n          scaleX:1,\n          scaleY:1,\n          opacity:0.5,\n          offset:{\n            x:125,\n            y:0,\n          },\n          name: \"ligne\",\n          className: \"Line\",\n          stroke: 'rgb(48,48,48)',\n          id:'1',\n          //distShapesToCenter:[],\n          keepDistribution: true, //say of we keep the distribution on the line or not\n          freeDistances:[], // distance that can be taken by other shapes (if we keep distribution on the line).\n          occupiedDistances:[-125,0,125], //distance already \"taken\" by shapes on the line.       \n          //text which will appear on the button corresponding to the management of the distribution:\n          keepDistanceButtonText:\"Liberate Distribution\",\n          //function which determine how the line can be dragged:\n          defaultAlignment:\"Bottom\",\n          dragBoundFunc: dragFunc,\n        },\n      },\n      /*{\n        name: \"group2\",\n        className: \"Group\",\n        id: '7',\n        x:0,\n        y:0,\n        offsetX:0,\n        offsetY:0,\n        rotation: 0,\n        draggable: false,\n        shapes_g:[],\n        line:{\n        x:500,\n        y:300,\n        points: [0, 0, 0, 0, 300, 0],\n        positionPoints:[],\n        strokeWidth: 10,\n        rotation: 0,\n        tension:0,\n        closed: true,\n        draggable: true,\n        scaleX:1,\n        scaleY:1,\n        opacity:0.5,\n        offset:{\n          x:150,\n          y:0,\n        },\n        //draggable:true,\n        name: \"ligne\",\n        className: \"Line\",\n        stroke: 'black',\n        id:'7',\n        distShapesToCenter:[],\n        keepDistribution: true,\n        freeDistances:[],\n        occupiedDistances:[],\n        keepDistanceButtonText:\"Liberate Distribution\",\n        defaultAlignment:\"Middle\",\n        dragBoundFunc: dragFunc,\n      },\n      \n      }*/\n      ],\n      transformers:[\n        {\n          id: 'lineTransformer',\n          enabledAnchors: [],\n          rotateEnabled: false,\n          borderEnabled:false,\n          flipEnabled: false, // in order to not have a rotation of the transformer which lead to problem related to shapes position on a line\n          nodes: [],\n\n        },\n        {\n          id: 'shapeTransformer',\n          nodes: [],\n        }\n      ],\n      shapes: [],\n      center:{\n        x: 300,\n        y: 500,\n        scaleX:1,\n        scaleY:1,\n        offsetX: 0,\n        offsetY: 0,\n        radius: 4,\n        fill: 'black',\n        opacity:1,\n        draggable:true,\n        isGrouped: 0,\n        className:\"Circle\",\n        id:'center',\n        dragBoundFunc:dragFunc,\n      },\n      positionPoint:{\n        x: 300,\n        y: 500,\n        scaleX:1,\n        scaleY:1,\n        offsetX: 0,\n        offsetY: 0,\n        radius: 3,\n        fill: 'yellow',\n        opacity:1,\n        draggable:false,\n        isGrouped: 0,\n        className:\"positionPoint\",\n        id:'positionPoint',\n        distance_to_line_center:undefined,\n      },\n      selectedShapeId: '',\n    };\n  },\n  mounted(){\n    let texts=this.$refs.stage.getStage().getChildren()[0].getChildren().filter((r)=>r.attrs.className=='Text');\n    \n    \n    for(let i=0;i<texts.length;i++){\n      texts[i].attrs.length_x=texts[i].width();\n      texts[i].attrs.length_y=texts[i].height();\n      texts[i].offsetX(texts[i].attrs.length_x/2);\n    }\n    let grp=this.groups[0];\n    let line=grp.line;\n    let shapes_g=grp.shapes_g;\n    for(let i=0;i<shapes_g.length;i++){\n      this.updateDragFunc(shapes_g[i],line);\n      \n      this.updateAllPosInGrp(grp.id);\n    }\n  },\n  created(){\n    //nb of shapes on the canvas (line excluded), we consider that there is no shape on line:\n    this.max_id_figures=this.shapes.length +this.groups.length; \n    //this.max_id_lines=this.groups.length;\n    /*\n    const image = new window.Image();\n    image.src = require(\"@/assets/exsitu.png\");\n    // set image only when it is loaded\n    image.height=150;\n    image.width=150;\n    image.onload = () => {\n      this.shapes.find((r)=>r.className===\"Image\").image= image;\n      this.shapes.find((r)=>r.className===\"Image\").offsetX=image.width/2;\n      this.shapes.find((r)=>r.className===\"Image\").offsetY=0; \n    };\n    */\n  },\n  methods: {\n\n      \n    switchEraseMode(){\n      if(this.eraseMode==0){\n        this.eraseMode=1;\n        this.eraser.opacity=0.4\n        document.getElementById(\"DiscoverabilityDemo\").style.cursor='url('+require('@/assets/ugly_eraser.png')+'),default';\n        \n      this.eraseNodefromTransformer(\"shapeTransformer\");\n      this.eraseNodefromTransformer(\"lineTransformer\");\n      } else{\n        this.eraseMode=0;\n        this.eraser.opacity=1;\n        document.getElementById(\"DiscoverabilityDemo\").style.cursor=\"default\";\n      }\n    },\n    /*\n    Check if all shapes that are supposed to be on a line still in this line.\n    id_grp is the id of the group which contains the line.\n    */\n    checkIfShapesOnLine(id_grp){\n      const grp= this.groups.find((r) => r.id===id_grp);\n      const line=grp.line;\n      const groupedShapes = grp.shapes_g;\n      //const lengthToDetach=10;\n      \n      /*\n      To determine if a shape is on a line, we see if the point is not on the corresponding\n      straight line y=a*x+b regarding certains intervals for x and y.Those intervals depends of the rotation of\n      the line. \n      */\n     /*\n      let coord_y1=line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x1=line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let coord_y2= line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x2=line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let a=(coord_y1-coord_y2)/(coord_x2-coord_x1);\n      let b=line.y-a*line.x;\n      let is_on_straight_line=false;\n      */\n      \n      let i=0;\n      while(i<groupedShapes.length){\n        \n       if(!this.isCoordinateOnLine(groupedShapes[i].x,groupedShapes[i].y,line.id)){\n          console.log(\"a shape is not on a line\");\n          groupedShapes[i].dragBoundFunc= dragFunc;\n          groupedShapes[i].isGrouped=0;\n          line.positionPoints.splice(i,1)\n          \n          this.shapes.push(groupedShapes[i],)\n          line.freeDistances.push(line.occupiedDistances[i]);\n          line.occupiedDistances.splice(i,1);\n          groupedShapes.splice(i,1);\n          //We erase ghosts og attached shapes and we make sure that their opacity is 1.\n          grp.ghosts.splice(0,grp.ghosts.length);\n          for (let i=0;i<groupedShapes.length;i++){\n           groupedShapes[i].opacity=1;\n          }\n          \n          this.updateNaration(grp)\n        }else{\n          i=i+1;\n        }\n      }\n    },\n\n    //say of {x,y} is a point from the line\n    isCoordinateOnLine(x,y,id_grp){\n      const grp=this.groups.find((r) => r.id===id_grp);\n      const line=grp.line;\n      let is_not_on_straight_line=true;\n      let coord_y1=line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x1=line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let coord_y2= line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x2=line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let a=(coord_y1-coord_y2)/(coord_x2-coord_x1);\n      let b=line.y-a*line.x;\n      if(Math.abs(coord_x1-coord_x2)>1){\n        is_not_on_straight_line=(Math.abs(a*x+b-y)>1);\n      }else{\n        is_not_on_straight_line=(Math.abs(x-line.x)>1)\n      }\n      if(\n        (is_not_on_straight_line)\n\n      ||((line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<y\n      ||line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>y)\n      && ((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<x\n        ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>x)\n      &&((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<y\n        ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>y)\n      &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>-Math.PI)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>x)\n      &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>-Math.PI)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>y)\n      &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>x)\n      &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>y)\n      &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>=0)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>x)\n      &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>=0)))\n\n      \n      )\n      {\n        return false; \n      } else{\n        return true;\n      }\n    },\n\n    //update a group with the id id_grp\n    updateGrp(e,id_grp){\n      const grep=this.groups.find((r)=>r.id===id_grp);\n      const line= grep.line;\n      grep.offsetX=line.offsetX;\n      grep.offsetY=line.offsetY;\n      \n      line.x=e.target.x();\n      line.y=e.target.y();\n      this.center.x=line.x;\n      this.center.y=line.y;\n      /*\n      if(line.keepDistribution){\n        this.updateOccupiedDistance(line.id);\n      }\n      */\n      this.updateAllPosInGrp(line.id); \n      this.checkIfShapesOnLine(line.id);\n    },\n\n\n    //update the position of all shapes that are on the line of the group with the id id_grp.\n    updateAllPosInGrp(id_grp){\n      const grp= this.groups.find((r) => r.id===id_grp);     \n      const line= grp.line;\n      const shapes_g = grp.shapes_g;\n      for (let i=0;i<shapes_g.length;i++){\n          if(line.keepDistribution){\n            shapes_g[i].x=line.x+line.occupiedDistances[i]*Math.cos(line.rotation*(Math.PI/180));\n            shapes_g[i].y=line.y+line.occupiedDistances[i]*Math.sin(line.rotation*(Math.PI/180));\n            shapes_g[i].distance_to_line_center=line.occupiedDistances[i];\n            shapes_g[i].rotation=shapes_g[i].personalRotation+line.rotation;\n            \n          } else{\n            shapes_g[i].x=line.x+line.occupiedDistances[i]*Math.cos(line.rotation*(Math.PI/180));\n            shapes_g[i].y=line.y+line.occupiedDistances[i]*Math.sin(line.rotation*(Math.PI/180));\n            shapes_g[i].distance_to_line_center=line.occupiedDistances[i];\n            shapes_g[i].rotation=shapes_g[i].personalRotation+line.rotation;\n          }\n          line.positionPoints[i].x=shapes_g[i].x;\n          line.positionPoints[i].y=shapes_g[i].y;\n          line.positionPoints[i].distance_to_line_center=shapes_g[i].distance_to_line_center;\n      }\n      let i=shapes_g.length;\n      while(i<line.positionPoints.length){\n        if(line.keepDistribution){\n          line.positionPoints.splice(i,1);\n        }else{\n        line.positionPoints[i].x=line.x+line.freeDistances[i-shapes_g.length]*Math.cos(line.rotation*(Math.PI/180));\n        line.positionPoints[i].y=line.y+line.freeDistances[i-shapes_g.length]*Math.sin(line.rotation*(Math.PI/180));\n        line.positionPoints[i].distance_to_line_center=line.freeDistances[i-shapes_g.length];\n        i++;\n        }\n        \n      }\n    \n    },\n    isOutsideTheLine(shape,line){\n      let coord_y1=line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x1=line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let coord_y2= line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x2=line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let a=(coord_y1-coord_y2)/(coord_x2-coord_x1);\n      let b=line.y-a*line.x;\n      let is_on_straight_line=false;\n      if(Math.abs(coord_x1-coord_x2)>=1){\n        is_on_straight_line=(Math.abs(a*shape.x+b-shape.y)<1);\n      }else{\n        is_on_straight_line=(Math.abs(shape.x-line.x)<1);\n      }\n      if(\n        !(is_on_straight_line)\n      ||((line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n        ||line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      && ((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>-Math.PI)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>-Math.PI)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>=0)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>=0)))\n      ){\n        return true;\n      }else{ return false}\n    },\n    \n    //update the canvas\n    update(){\n      const shapes = this.shapes\n      \n      //const lengthToCapture=10; //bigger is the number, bigger is the intervals of x and y where a shape can be added to a line.\n      let is_on_straight_line=false;\n      for (let i=0;i<shapes.length;i++){\n        let x=shapes[i].x;\n        let y=shapes[i].y;\n      for (let j=0;j<this.groups.length;j++){\n      \n        let line=this.groups[j].line;\n\n        \n        let coord_y1=line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n        let coord_x1=line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n        let coord_y2= line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n        let coord_x2=line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n        let a=(coord_y1-coord_y2)/(coord_x2-coord_x1);\n        let b=line.y-a*line.x;\n        if(Math.abs(coord_x1-coord_x2)>1){\n          is_on_straight_line=(Math.abs(a*x+b-y)<=this.lengthToCapture);\n        }else{\n          is_on_straight_line=(Math.abs(x-line.x)<=this.lengthToCapture);\n          //is_on_straight_line=true;\n        }\n        if(\n        (\n          is_on_straight_line\n      &&(line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToCapture>=y\n      && line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToCapture<=y)\n      &&(line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToCapture>=x\n      && line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToCapture<=x)\n      &&(line.rotation*(Math.PI/180)<=0 \n      && line.rotation*(Math.PI/180)>-Math.PI/2))\n\n      ||(\n        is_on_straight_line\n      &&(line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))+this.lengthToCapture>=y\n      && line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))-this.lengthToCapture<=y) \n      &&(line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))+this.lengthToCapture>=x\n      && line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))-this.lengthToCapture<=x)\n      &&(line.rotation*(Math.PI/180)<=-Math.PI/2 \n      && line.rotation*(Math.PI/180)>=-Math.PI))\n\n      ||(\n        is_on_straight_line\n      &&(line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))+this.lengthToCapture>=y\n      &&line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))-this.lengthToCapture<=y)\n      &&(line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))+this.lengthToCapture>=x\n      && line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))-this.lengthToCapture<=x)\n      &&(line.rotation*(Math.PI/180)<=Math.PI \n      && line.rotation*(Math.PI/180)>Math.PI/2))\n\n      ||(\n        is_on_straight_line\n      &&(line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToCapture>=y\n      && line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToCapture<=y)\n      &&(line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToCapture>=x\n      && line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToCapture<=x)\n      &&(line.rotation*(Math.PI/180)<=Math.PI/2\n      && line.rotation*(Math.PI/180)>=0))\n      )\n       {\n          shapes[i].isGrouped=1;\n          this.makeGroup(line.id);\n        }\n      }\n      }\n    },\n    \n    initializeDragging(e){\n      let grp=this.groups.find((r)=>r.id==e.target.getParent().attrs.id);\n      if(grp.shapes_g.length>1 && grp.line.keepDistribution==1){\n        let neighbour=this.closestGroupedShape(grp,e);\n        this.neighbour.push(e.target.getParent().getChildren().find((r)=>r.attrs.id==neighbour.id),);\n        let position={x: e.target.x(),y: e.target.y()};\n        this.createGhost(grp,position,this.neighbour[this.neighbour.length-1])\n        this.dist_with_neighbour=this.distBtwShapes(e.target.attrs,this.neighbour[this.neighbour.length-1].attrs);\n      }\n      \n    },\n    \n    closestGroupedShape(grp,e){\n      //When an  attached shape has no opacity it means that it is not in the neighbourhood of the shape we drag.\n      let neighbour=grp.shapes_g.find((r)=>r.id!=e.target.attrs.id && r.opacity!=0);\n      for (let i=0;i<grp.shapes_g.length;i++){\n        this.distBtwShapes(grp.shapes_g[i],e.target.attrs)\n        if(this.distBtwShapes(grp.shapes_g[i],e.target.attrs)<this.distBtwShapes(neighbour,e.target.attrs)\n        && grp.shapes_g[i].id!=e.target.attrs.id && grp.shapes_g[i].opacity!=0){\n          neighbour=grp.shapes_g[i]\n        }\n      }\n      /*\n      if(neighbour.id!=e.target.attrs.id){\n        return neighbour;\n      }else{\n        return undefined;\n      }\n      */\n      \n      return neighbour;\n    },\n    createGhost(grp,position,neighbour){\n      if(grp.line.keepDistribution==1){\n        //let neighbour=e.target.getParent().getChildren()[e.target.getParent().getChildren().indexOf(e.target)-1];\n        let clone=neighbour.clone({\n            id: 'clone'+neighbour.attrs.id,\n            x:position.x,\n            y:position.y,\n            opacity:0,\n            draggable:false,\n        });\n        //e.target.getLayer().add(clone1);\n        //e.target.getLayer().add(clone);\n        grp.ghosts.push(clone.attrs,)\n      }\n    },\n    distBtwShapes(shape1,shape2){\n      return Math.sqrt((shape2.y-shape1.y)**2+(shape2.x-shape1.x)**2);\n      \n    },\n    distFromStartPoint(shape,e){\n      return Math.sqrt((shape.y-e.target.y())**2+(shape.x-e.target.x())**2);\n    },\n    targetNeighbour(e){\n      let grp= this.groups.find((r)=>r.id===e.target.getParent().attrs.id);\n      let shape=grp.shapes_g.find((r)=>r.id==e.target.attrs.id)\n      let index=grp.shapes_g.indexOf(shape);\n      if(index==0){\n        return grp.shapes_g[1];\n      } else if(index==grp.shapes_g.length-1){\n        return grp.shapes_g[index-1]\n      } else{\n        let distRight=this.distBtwShapes(e.target.attrs,grp.shapes_g[index+1]);\n        let distLeft=this.distBtwShapes(e.target.attrs,grp.shapes_g[index-1]);\n        if(distRight>distLeft){\n          return grp.shapes_g[index-1];\n        } else{\n          return grp.shapes_g[index+1];\n        }\n      }\n    },\n    onDragging(e){\n      \n      let grp=this.groups.find((r)=>r.id===e.target.getParent().attrs.id);\n      let shape= grp.shapes_g.find((r)=>r.id==e.target.id());\n      let dist=Math.sqrt((e.target.getStage().getPointerPosition().y-e.target.y())**2+(e.target.getStage().getPointerPosition().x-e.target.x())**2);\n      if(grp.line.keepDistribution==1 && grp.shapes_g.length>1){\n        //let clone=e.target.getParent().getParent().getChildren().find((r)=>r.attrs.id===('clone'+this.neighbour[this.neighbour.length-1].attrs.id))\n        let clone=grp.ghosts.find((r)=>r.id==('clone'+this.neighbour[this.neighbour.length-1].attrs.id))\n        /*if(this.distBtwShapes(e.target.attrs,this.neighbour.attrs)>this.dist_with_neighbour){\n          console.log(shape)\n        }else */\n        if(grp.shapes_g.length>1&& this.isCoordinateOnLine(e.target.x(),e.target.y(),grp.id)){\n          let neighbour=grp.shapes_g.find((r)=>r.id===this.neighbour[this.neighbour.length-1].attrs.id);\n          let distFromStart= this.distFromStartPoint(shape,e);\n          let dist_btw_shapes=grp.line.points[4]*grp.line.scaleX/(grp.shapes_g.length-1);\n          \n          //-(grp.line.points[4]*grp.line.scaleX/2)*(grp.ghosts.length-1);\n          \n          if(this.closestGroupedShape(grp,e).id!=this.neighbour[this.neighbour.length-1].attrs.id){\n            console.log(\"a change\")\n            let position;\n            //If the opacity of the neighbour is null in its current state, \n            //it means that its place is currently considered as the one of the object we drag.\n            if(this.neighbour[this.neighbour.length-1].attrs.opacity==0){\n              position={x: neighbour.x,y: neighbour.y};\n            }else{\n              position={x: shape.x,y: shape.y};\n            }\n            if(clone.opacity<=0.5 && distFromStart<=(grp.line.points[4]*grp.line.scaleX/2)){\n              //if opacity<=0 and if the closestGRoupedShape change it means that the ghost shape clone is useless.\n              console.log(\"ghost erase\")\n              grp.ghosts.splice(grp.ghosts.indexOf(clone),1)\n            }\n            else{\n              \n            shape.x=neighbour.x;\n            shape.y=neighbour.y;\n            neighbour.x=clone.x;\n            neighbour.y=clone.y;\n            neighbour.opacity=1;\n            grp.ghosts.splice(grp.ghosts.indexOf(clone),1)\n            this.sortByDistToLineCenter(grp) // in order to sort attached shapes because the position of one of them has been update\n            }\n            //if the shape we drag is at one end of the line, it is useless to find a neighbour\n            /*if(this.distBtwShapes(grp.line,e.target.attrs)>=grp.line.points[4]*grp.line.scaleX/2){\n              console.log(clone)\n            }else{\n              */\n            this.neighbour.push(e.target.getParent().getChildren().find((r)=>r.attrs.id==this.closestGroupedShape(grp,e).id),);   \n            this.createGhost(grp,position,this.neighbour[this.neighbour.length-1])\n            \n            clone=grp.ghosts.find((r)=>r.id==('clone'+this.neighbour[this.neighbour.length-1].attrs.id))\n            //}\n          }\n          distFromStart= this.distFromStartPoint(shape,e)\n          //-(grp.line.points[4]*grp.line.scaleX/2)*(grp.ghosts.length-1);\n          this.dist_with_neighbour=this.distBtwShapes(e.target.attrs,this.neighbour[this.neighbour.length-1].attrs);\n          //clone.opacity(1*((dist_btw_shapes-this.dist_with_neighbour)/dist_btw_shapes));\n          //let x=(dist_btw_shapes-this.dist_with_neighbour)/dist_btw_shapes;\n          let x=distFromStart/dist_btw_shapes;\n          let opacity_change=x;\n          if (x>=0.3){\n            opacity_change=0.3;\n          }\n          if(x>=1){\n            opacity_change=1;\n          }\n          clone.opacity=opacity_change;\n          this.neighbour[this.neighbour.length-1].opacity(1-1*opacity_change)\n          neighbour=grp.shapes_g.find((r)=>r.id===this.neighbour[this.neighbour.length-1].attrs.id);\n          neighbour.opacity=1-1*opacity_change\n        }else{\n          for (let i=0;i<grp.shapes_g.length;i++){\n            grp.shapes_g[i].opacity=1;\n          }\n          clone.opacity=0;\n        }\n        //let neighbour=e.target.getParent().getChildren()[e.target.getParent().getChildren().indexOf(e.target)-1];\n        //console.log(clone)\n      }\n      if(e.target.className==\"Rect\"){\n        dist-=e.target.attrs.height*e.target.attrs.scaleY;\n      } else if(e.target.className==\"Circle\"){\n        dist-=(2*e.target.attrs.radius)*e.target.attrs.scaleY;\n      } else if(e.target.className==\"Text\"){\n        dist-=e.target.attrs.length_y*e.target.attrs.scaleY;\n      } else if(e.target.className==\"Image\"){\n        dist-=e.target.height()*e.target.scaleY();\n      } else if(e.target.attrs.className==\"Triangle\"){\n        dist-=e.target.height()*e.target.scaleY();\n      } \n      \n      if (dist>50){\n        //let shape= this.groups.find((r)=>r.id===e.target.getParent().attrs.id).shapes_g.find((r)=>r.id==e.target.id());\n        //this.groups.find((r)=>r.id===e.target.getParent().attrs.id).shapes_g.find((r)=>r.id==e.target.id()).needToBeDetach=1;\n        /*\n        shape.dragBoundFunc= function (pos) {\n              return {\n                x: pos.x,\n                y: pos.y,\n              };\n        }\n        */\n        //shape.x=e.target.getStage().getPointerPosition().x;\n        //shape.y=e.target.getStage().getPointerPosition().y;\n        //if (Math.abs(e.target.getStage().getPointerPosition().y-e.target.y())>220){\n\n        //shape.x=e.target.getStage().getPointerPosition().x;\n        //shape.y=e.target.getStage().getPointerPosition().y;\n        \n        this.groups.find((r)=>r.id===e.target.getParent().attrs.id).aShapeHasBeenDetach=1;\n        this.DetachShape(shape,e.target.getStage().getPointerPosition().x,e.target.getStage().getPointerPosition().y);\n        //}\n        \n        \n        \n      }\n    },\n\n    //Give the sign of the distance of shape from the center of a line.\n    GiveSignOfDistance(shape,line){\n      let result;\n      let angle=line.rotation*(Math.PI/180);\n      let distX=shape.x-line.x;\n      let distY=shape.y-line.y;\n      /*\n      \n      if(angle<=-Math.PI/4 || angle>=-Math.PI/2){\n        result=-Math.sign(distY);\n      }\n      else if(angle<=-Math.PI/2 || angle>=-3*Math.PI/4){\n        result=Math.sign(distY);\n      }\n      else if(angle<=-3*Math.PI/4 || angle>=-Math.PI){\n        result=-Math.sign(distX);\n      }else if(angle>=3*Math.PI/4 || angle<=Math.PI){\n        result=Math.sign(distX);\n      }else if(angle>=Math.PI/2 || angle<3*Math.PI/4){\n        result=-Math.sign(distY);\n      } else if(angle<=Math.PI/2 || angle>Math.PI/4){\n        result=-Math.sign(distY);\n      } else if(angle<=Math.PI/4 || angle>=0){\n        result=Math.sign(distX);\n      }\n      */\n      \n      \n      if(Math.abs(distX)<=this.lengthToCapture && line.rotation==-90){\n        \n        result=-Math.sign(distY);\n      } else if (Math.abs(distX)<=this.lengthToCapture && line.rotation==90){\n        result=Math.sign(distY);\n      }\n      else{\n        result=Math.sign(distX);\n      }\n      if(angle<-Math.PI/2 || angle>Math.PI/2){\n        result=-result;\n      }\n      \n      return result;\n    },\n\n    //Different from the previous function bcs the straight line of the center is perdendicular to the line\n    GiveSignOfDistanceBtwCenterAndShape(center,shape){\n      let result;\n      let angle=shape.rotation*(Math.PI/180);\n      let distX=center.x-shape.x;\n      let distY=center.y-shape.y;\n      /*\n      \n      if(angle<=-Math.PI/4 || angle>=-Math.PI/2){\n        result=-Math.sign(distY);\n      }\n      else if(angle<=-Math.PI/2 || angle>=-3*Math.PI/4){\n        result=Math.sign(distY);\n      }\n      else if(angle<=-3*Math.PI/4 || angle>=-Math.PI){\n        result=-Math.sign(distX);\n      }else if(angle>=3*Math.PI/4 || angle<=Math.PI){\n        result=Math.sign(distX);\n      }else if(angle>=Math.PI/2 || angle<3*Math.PI/4){\n        result=-Math.sign(distY);\n      } else if(angle<=Math.PI/2 || angle>Math.PI/4){\n        result=-Math.sign(distY);\n      } else if(angle<=Math.PI/4 || angle>=0){\n        result=Math.sign(distX);\n      }\n      */\n      \n      \n      if(Math.abs(distY)<=this.lengthToCapture && shape.rotation==-90){\n        \n        result=Math.sign(distX);\n      } else if (Math.abs(distY)<=this.lengthToCapture && shape.rotation==90){\n        result=-Math.sign(distX);\n      }\n      else{\n        result=Math.sign(distY);\n      }\n      if(angle<-Math.PI/2 || angle>Math.PI/2){\n        result=-result;\n      }\n      \n      return result;\n    },\n\n    /*add shapes with isGrouped==1 to the group with the id id_grp.\n    */\n    makeGroup(id_grp){\n      this.eraseNodefromTransformer(\"shapeTransformer\");\n      this.eraseNodefromTransformer(\"lineTransformer\");\n      const grp=this.groups.find((r)=> r.id===id_grp);\n      const line=grp.line;\n      const shapes = this.shapes;\n      line.freeDistances.sort(this.isSmaller); //we will give the shortest available distance to the added shape\n      shapes.sort(this.isBeforeRegardingX);\n      for (let i=0;i<shapes.length;i++){\n        if(shapes[i].isGrouped==1){\n          const positionPoint=Object.assign({},this.positionPoint);\n          let distX=shapes[i].x-line.x;\n          let distY=shapes[i].y-line.y; \n          shapes[i].personalRotation=0;\n          //let pot_dist=this.GiveSignOfDistance(shapes[i],line)*Math.sqrt((distX)**2+(distY)**2);\n          /*\n          if(line.keepDistribution && line.freeDistances.length>0){\n          let distances=line.freeDistances+line.occupiedDistances;\n          console.log(distances);\n           let freeDistance=this.isNearest(line.freeDistances,pot_dist);\n           //shapes[i].distance_to_line_center=freeDistance.res; \n           shapes[i].distance_to_line_center=this.GiveSignOfDistance(shapes[i],line)*Math.sqrt((distX)**2+(distY)**2);\n            \n           line.occupiedDistances.push(shapes[i].distance_to_line_center,);\n           line.freeDistances.splice(freeDistance.indice,1);\n\n          } else{\n            */\n            //let distX=shapes[i].x-line.x;\n            //let distY=shapes[i].y-line.y;\n            shapes[i].distance_to_line_center=this.GiveSignOfDistance(shapes[i],line)*Math.sqrt((distX)**2+(distY)**2);\n            /*If the distance is a little bit to far from the center \n            we adjust it so that the shape can be at one of the border of the stickyline*/\n            if(Math.abs(shapes[i].distance_to_line_center)>=line.points[4]*line.scaleX/2){\n              shapes[i].distance_to_line_center=Math.sign(shapes[i].distance_to_line_center)*line.points[4]*line.scaleX/2\n            }\n            this.ChangeCenterRegardingCommand(shapes[i].id,grp.line.defaultAlignment);\n            \n              //shapes[i].isGrouped=0;\n              this.updateDragFunc(shapes[i],line);\n              grp.shapes_g.push(shapes[i],);\n              console.log(\"no 'free distance' anymore\")\n              grp.line.occupiedDistances.push(shapes[i].distance_to_line_center,);\n              positionPoint.id=\"positionPoint\"+grp.id+grp.line.positionPoints.length;\n              grp.line.positionPoints.push(positionPoint,);\n              //shapes[i].distance_to_line_center=this.GiveSignOfDistance(shapes[i],line)*Math.sqrt((distX)**2+(distY)**2);\n            \n            //line.occupiedDistances.push(shapes[i].distance_to_line_center,);\n          //}\n          console.log(\"A new shape has been added with a distance\"+shapes[i].distance_to_line_center);\n          //shapes[i].isGrouped=0;\n          //this.updateDragFunc(shapes[i],line);\n          //grp.shapes_g.push(shapes[i],);\n          this.updateOccupiedDistance(line.id);\n          \n          this.updateAllPosInGrp(id_grp);\n          shapes.splice(i,1);\n          \n          this.updateNaration(grp)\n        }\n      }\n      this.center.x=line.x;\n      this.center.y=line.y;\n    },\n\n    updateOccupiedDistance(id_grp){\n      \n      const grp=this.groups.find((r)=> r.id===id_grp);\n      //this.updateAllPosInGrp(id_grp);\n      this.sortByDistToLineCenter(grp);\n      \n      //let l=grp.line.points[4]/2;\n      if(grp.line.keepDistribution){\n      let L=grp.line.points[4];\n      let nb_shapes=grp.shapes_g.length;\n      let d=(L/(nb_shapes-1))*grp.line.scaleX;\n      if(nb_shapes%2==0){\n        \n      for (let i =1;i<=nb_shapes/2-1;i++){\n        //grp.line.occupiedDistances[i-1]=-(l/i);\n        grp.line.occupiedDistances[i-1]=-((nb_shapes/2-1)-i+1)*d-d/2\n      }\n      for (let i =1;i<=nb_shapes/2-1;i++){\n        grp.line.occupiedDistances[nb_shapes/2+i]=i*d+d/2;\n      }\n      grp.line.occupiedDistances[nb_shapes/2-1]=-d/2\n      grp.line.occupiedDistances[nb_shapes/2]=d/2\n      } else{\n        for (let i =1;i<=(nb_shapes-1)/2;i++){\n          grp.line.occupiedDistances[i-1]=-d*(((nb_shapes-1)/2)-i+1);\n        }\n        for (let i =1;i<=(nb_shapes-1)/2;i++){\n          grp.line.occupiedDistances[((nb_shapes-1)/2)+i]=d*i;\n        }\n        grp.line.occupiedDistances[(nb_shapes-1)/2]=0;\n      }\n      \n      for (let i=0;i<grp.shapes_g.length;i++){\n        grp.shapes_g[i].distance_to_line_center=grp.line.occupiedDistances[i];\n      }\n      }\n      else{\n        grp.line.occupiedDistances.sort(this.isSmaller);\n      }\n      \n      \n      \n    \n\n    },\n\n   isSmaller(a,b){\n    if(a<b){\n      return -1;\n    }else{\n      return 1\n    }\n   },\n\n   isBeforeRegardingX(a,b){\n    if(a.x<b.x){\n      return -1;\n    }else{\n      return 1;\n    }\n   },\n\n    \n   updateOccDist(grp,shape){\n    let res=this.isNearest(grp.line,shape);\n    //let grp=this.groups.find((r)=>r.id===line.id);\n    if(res.isFree){\n      shape.distance_to_line_center=grp.line.freeDistances[res.indice];\n      grp.line.freeDistances.splice(res.indice,1);\n      this.sortByDistToLineCenter(grp);\n      for(let l=0;l<grp.shapes_g.length;l++){\n        if(grp.line.occupiedDistances.length==l){\n          grp.line.occupiedDistances.push(grp.shapes_g[l].distance_to_line_center,);\n        }else{\n          grp.line.occupiedDistances[l]=grp.shapes_g[l].distance_to_line_center;\n        }\n      } \n    } else{\n      grp.shapes_g.find((r)=>r.id==shape.id).distance_to_line_center=grp.line.occupiedDistances[res.indice];\n      grp.line.occupiedDistances.splice(res.indice,1);\n      //line.occupiedDistances.push(shape.distance_to_line_center,);\n      //line.freeDistances.splice(res.indice,1);   \n      this.updateOccDist(grp,grp.shapes_g[res.indice]);\n    }\n   },\n   isNearest(line,shape){\n    let ecart;\n    let invx=line.x+line.freeDistances[0]*Math.cos(line.rotation*(Math.PI/180));\n    let invy=line.y+line.freeDistances[0]*Math.sin(line.rotation*(Math.PI/180));\n    let ecart_min=Math.sqrt((invx-shape.x)**2+(invy-shape.y)**2);\n    let indice=0;\n    for(let i=1;i<line.freeDistances.length;i++){\n      invx=line.x+line.freeDistances[i]*Math.cos(line.rotation*(Math.PI/180));\n      invy=line.y+line.freeDistances[i]*Math.sin(line.rotation*(Math.PI/180));\n      ecart=Math.sqrt((invx-shape.x)**2+(invy-shape.y)**2);\n      if(ecart<ecart_min){\n        //res=line.freeDistances[i];\n        ecart_min=ecart;\n        indice=i;\n      }\n    }\n    return indice;\n    /*\n    let allDist=line.freeDistances.concat(line.occupiedDistances);\n    console.log(allDist);\n    \n    let ecart;\n    let invx=line.x+allDist[0]*Math.cos(line.rotation*(Math.PI/180));\n    let invy=line.y+allDist[0]*Math.sin(line.rotation*(Math.PI/180));\n    let ecart_min=Math.sqrt((invx-shape.x)**2+(invy-shape.y)**2)\n    let indice=0;\n    console.log(ecart_min);\n    for(let i=1;i<allDist.length;i++){\n      invx=line.x+allDist[i]*Math.cos(line.rotation*(Math.PI/180));\n      invy=line.y+allDist[i]*Math.sin(line.rotation*(Math.PI/180));\n      ecart=Math.sqrt((invx-shape.x)**2+(invy-shape.y)**2);\n      if(this.groups.find((r)=>r.id==line.id).shapes_g.indexOf(shape)!=-1){\n        console.log(ecart_min);\n        console.log(ecart);\n        if(ecart<ecart_min && ecart!=0){\n          //res=allDist[i];\n          ecart_min=ecart;\n          indice=i;\n        }\n      }else if(ecart<ecart_min){\n        //res=allDist[i];\n        ecart_min=ecart;\n        indice=i;\n      }\n    }\n    console.log(indice);\n    if(indice>=line.freeDistances.length){\n      return{\n        isFree: false,\n        indice: indice-line.freeDistances.length,\n      }\n    }else{\n      return{\n        isFree: true,\n        indice: indice,\n      }\n    }\n    */\n\n    /*\n    line.freeDistances.sort(this.isSmaller);\n    let ecart;\n    let invx=line.x+line.freeDistances[0]*Math.cos(line.rotation*(Math.PI/180));\n    let invy=line.y+line.freeDistances[0]*Math.sin(line.rotation*(Math.PI/180));\n    let ecart_min=Math.sqrt((invx-shape.x)**2+(invy-shape.y)**2)\n    let indice=0;\n    for(let i=0;i<line.freeDistances.length;i++){\n      invx=line.x+line.freeDistances[i]*Math.cos(line.rotation*(Math.PI/180));\n      invy=line.y+line.freeDistances[i]*Math.sin(line.rotation*(Math.PI/180));\n      ecart=Math.sqrt((invx-shape.x)**2+(invy-shape.y)**2)\n      if(ecart<ecart_min){\n        //res=freeDistances[i];\n        ecart_min=ecart;\n        indice=i;\n      }\n    }\n    return indice;\n    */\n    /*\n    if(shapeDistance>=0){\n      for(let i=0;i<freeDistances.length;i++){\n        if(freeDistances[i]>shapeDistance){\n          return i;\n        }\n      }\n      return freeDistances.length-1;\n    }else{\n      let ecart_min=Math.abs(Math.abs(freeDistances[0])-Math.abs(shapeDistance))\n      let indice=0;\n      for(let i=0;i<freeDistances.length;i++){\n        let ecart=Math.abs(Math.abs(freeDistances[i])-Math.abs(shapeDistance));\n        if(ecart<ecart_min){\n          //res=freeDistances[i];\n          ecart_min=ecart;\n          indice=i;\n        }\n      }\n      return indice;\n    }\n    */\n    /*\n    //let res=freeDistances[0];\n    let ecart_min=Math.abs(Math.abs(freeDistances[0])-Math.abs(shapeDistance))\n    let indice=0;\n    for(let i=0;i<freeDistances.length;i++){\n      let ecart=Math.abs(Math.abs(freeDistances[i])-Math.abs(shapeDistance));\n      if(ecart<ecart_min){\n        //res=freeDistances[i];\n        ecart_min=ecart;\n        indice=i;\n      }\n    }\n    return indice;\n    */\n   },\n   \n\n   sortByDistToLineCenter(grp){\n    //this.updateAllPosInGrp(grp.id)\n    //let last_distX=new Array(grp.shapes_g.length);\n    \n    //let distX;\n    //let distY;\n    //let sign;\n    //let dist=new Array(grp.shapes_g.length);\n    //let angle;\n    if(grp.line.keepDistribution){\n      for (let l=0;l<grp.shapes_g.length;l++){\n          let distX=grp.shapes_g[l].x-grp.line.x;\n          let distY=grp.shapes_g[l].y-grp.line.y;\n          //dist[l]=this.GiveSignOfDistance(grp.shapes_g[l],grp.line)*Math.sqrt((distX)**2+(distY)**2);\n          grp.shapes_g[l].distance_to_line_center=this.GiveSignOfDistance(grp.shapes_g[l],grp.line)*Math.sqrt((distX)**2+(distY)**2);\n          //last_distX[l]=distX;\n        }\n    }\n    for(let i=1;i<grp.shapes_g.length;i++){\n      \n     \n      let shape=grp.shapes_g[i];\n      //let distance=dist[i];\n      let j=i\n      while(j>0 && grp.shapes_g[j-1].distance_to_line_center>shape.distance_to_line_center){\n        grp.shapes_g[j]=grp.shapes_g[j-1];\n        //dist[j]=dist[j-1]\n        j=j-1;\n      }\n      grp.shapes_g[j]=shape;\n      //dist[j]=distance;\n    }\n   },\n   \n\n   sortAnyShapesByDistToLineCenter(shapes,line){\n    //this.updateAllPosInGrp(grp.id)\n    //let last_distX=new Array(grp.shapes_g.length);\n    \n    //let distX;\n    //let distY;\n    //let sign;\n    //let dist=new Array(grp.shapes_g.length);\n    //let angle;\n    for (let l=0;l<shapes.length;l++){\n        let distX=shapes[l].x-line.x;\n        let distY=shapes[l].y-line.y;\n        /*\n        angle=grp.shapes_g[l].rotation*(Math.PI/180);\n\n      \n      if(angle<=-Math.PI/4 || angle>=-Math.PI/2){\n        sign=-Math.sign(distY);\n      }\n      else if(angle<=-Math.PI/2 || angle>=-3*Math.PI/4){\n        sign=Math.sign(distY);\n      }\n      else if(angle<=-3*Math.PI/4 || angle>=-Math.PI){\n        sign=-Math.sign(distX);\n      }else if(angle>=3*Math.PI/4 || angle<=Math.PI){\n        sign=Math.sign(distX);\n      }else if(angle>=Math.PI/2 || angle<3*Math.PI/4){\n        sign=-Math.sign(distY);\n      } else if(angle<=Math.PI/2 || angle>Math.PI/4){\n        sign=-Math.sign(distY);\n      } else if(angle<=Math.PI/4 || angle>=0){\n        sign=Math.sign(distX);\n      }\n       console.log(sign);\n        */\n       \n        /*\n        if(Math.sin(grp.line.rotation*(Math.PI/180))==0){\n            grp.shapes_g[l].distance_to_line_center=grp.shapes_g[l].x-grp.line.x;\n        }else{\n            grp.shapes_g[l].distance_to_line_center=Math.sign(distX)*Math.sqrt((distX)**2+(distY)**2);\n          \n            if(grp.line.rotation*(Math.PI/180)<=-Math.PI/2 || grp.line.rotation*(Math.PI/180)<=Math.PI/2 &&grp.line.rotation*(Math.PI/180)>=0){\n              grp.shapes_g[l].distance_to_line_center=-grp.shapes_g[l].distance_to_line_center\n            }\n        }\n        */\n        //dist[l]=this.GiveSignOfDistance(grp.shapes_g[l],grp.line)*Math.sqrt((distX)**2+(distY)**2);\n        shapes.distance_to_line_center=this.GiveSignOfDistance(shapes,line)*Math.sqrt((distX)**2+(distY)**2);\n        /*\n        if((grp.line.rotation*(Math.PI/180)<=-Math.PI/2 || (grp.line.rotation*(Math.PI/180)<=Math.PI/2 && grp.line.rotation*(Math.PI/180)>=0)) && (Math.sign(last_distX[l])!=Math.sign(distX))){\n          grp.shapes_g[l].distance_to_line_center=-grp.shapes_g[l].distance_to_line_center\n        }\n        */\n        //last_distX[l]=distX;\n      }\n    for(let i=1;i<shapes.length;i++){\n      \n     \n      let shape=shapes[i];\n      //let distance=dist[i];\n      let j=i\n      while(j>0 && shapes[j-1].distance_to_line_center>shape.distance_to_line_center){\n        shapes[j]=shapes[j-1];\n        //dist[j]=dist[j-1]\n        j=j-1;\n      }\n      shapes[j]=shape;\n      //dist[j]=distance;\n    }\n   },\n\n  \n\n   /*\n   update the drag function of a shape which is on a line. \n   */\n   updateDragFunc(shape,line){\n          let angle=line.rotation*(Math.PI/180);\n          if (angle<=0 && angle>=-Math.PI/4){\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x +(pos.x-line.x)*Math.cos(angle),\n                y: line.y+(pos.x-line.x)*Math.sin(angle),\n              };\n            }\n          } else if (angle<-Math.PI/4 && angle>=-Math.PI/2){\n            // We prefer, in this case, moving the shape of the line regarding the y of the mouse position instead of the x.\n            // So that the user can move the shape more intuitively\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x-(pos.y-line.y)*Math.cos(angle),\n                y: line.y-(pos.y-line.y)*Math.sin(angle),\n              };\n            }\n          }\n          else if (angle<-Math.PI/2 && angle>=-3*Math.PI/4){\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x-(pos.y-line.y)*Math.cos(angle),\n                y: line.y-(pos.y-line.y)*Math.sin(angle),\n              };\n            }\n          } else if (angle<-3*Math.PI/4 && angle>=-Math.PI){\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x-(pos.x-line.x)*Math.cos(angle),\n                y: line.y-(pos.x-line.x)*Math.sin(angle),\n              };\n            }\n          }else if (angle<=Math.PI && angle>=3*Math.PI/4){\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x-(pos.x-line.x)*Math.cos(angle),\n                y: line.y-(pos.x-line.x)*Math.sin(angle),\n              };\n            }\n          } else if (angle<3*Math.PI/4 && angle>=Math.PI/2){\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x+(pos.y-line.y)*Math.cos(angle),\n                y: line.y+(pos.y-line.y)*Math.sin(angle),\n              };\n            }\n          } else if (angle<Math.PI/2 && angle>=Math.PI/4){\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x+(pos.y-line.y)*Math.cos(angle),\n                y: line.y+(pos.y-line.y)*Math.sin(angle),\n              };\n            }\n          }else if (angle<Math.PI/4 && angle>=0){\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x+(pos.x-line.x)*Math.cos(angle),\n                y: line.y+(pos.x-line.x)*Math.sin(angle),\n              };\n            }\n          }\n   },\n\n   /*\n   Update the position of a free shape when it is dragging.\n   */\n    updatePos(e){\n      const shape = this.shapes.find(i => i.id === e.target.id());\n      shape.x=e.target.x();\n      shape.y=e.target.y();\n      this.center.x=e.target.x();\n      this.center.y=e.target.y();\n\n      let pos = { x: shape.x, y: shape.y };\n      e.target.position(pos);\n      e.target.getLayer().batchDraw();\n      \n    },\n\n    /*\n    Update the positio  of shape attached to a line (from the group with id=id_grp) when it is dragging.\n     */\n   updatePosInGrp(e,id_grp){\n      let distX;\n      let distY;\n      let distance_to_line_center;\n      const grp=this.groups.find((r)=> r.id===id_grp);\n      \n      if(grp.aShapeHasBeenDetach==1){\n        grp.aShapeHasBeenDetach=0;\n        return;\n      }\n      const line=grp.line;\n      const shape = grp.shapes_g.find(i => i.id === e.target.id());\n      const shapes_g = grp.shapes_g; \n      //const lengthToDetach=10;\n      /*\n      if(shape.needToBeDetach==1){\n        shape.needToBeDetach=0;\n        this.DetachShape(shape);\n        this.updateAllPosInGrp(e.target.getParent().attrs.id);\n      }\n      */\n      if(line.keepDistribution){\n        grp.ghosts.splice(0,grp.ghosts.length);\n        \n        for(let i=0;i<shapes_g.length;i++){\n          shapes_g[i].opacity=1;\n        }\n        this.neighbour.splice(0,this.neighbour.length)\n        \n        if(this.isCoordinateOnLine(e.target.x(),e.target.y(),line.id)){\n        //this.neighbour[this.neighbour.length-1].opacity(1);\n        /*\n        for(let i=0;i<this.neighbour.length;i++){\n          this.neighbour[i].opacity(1);\n        }\n        */\n          distX=shape.x-e.target.x();\n          distY=shape.y -e.target.y();\n          let L=grp.line.points[4];\n          let nb_shapes=grp.shapes_g.length;\n          let d=(L/(nb_shapes-1))*grp.line.scaleX;\n          let dist=Math.sqrt(distX**2 +distY**2);\n          if(dist>=d){\n            shape.x=e.target.x();\n            shape.y=e.target.y();\n            this.updateOccupiedDistance(line.id)\n            shape.x=line.x+line.occupiedDistances[shapes_g.indexOf(shape)]*Math.cos(line.rotation*(Math.PI/180));\n            shape.y=line.y+line.occupiedDistances[shapes_g.indexOf(shape)]*Math.sin(line.rotation*(Math.PI/180));\n            shape.distance_to_line_center=line.occupiedDistances[shapes_g.indexOf(shape)];\n            shape.rotation=line.rotation;\n            this.updateAllPosInGrp(line.id);\n          }else{\n            shape.x=line.x+line.occupiedDistances[shapes_g.indexOf(shape)]*Math.cos(line.rotation*(Math.PI/180));\n            shape.y=line.y+line.occupiedDistances[shapes_g.indexOf(shape)]*Math.sin(line.rotation*(Math.PI/180));\n            shape.distance_to_line_center=line.occupiedDistances[shapes_g.indexOf(shape)];\n            shape.rotation=line.rotation; \n          }   \n        }else{\n          shape.x=e.target.x();\n          shape.y=e.target.y();\n        }\n        line.positionPoints[grp.shapes_g.indexOf(shape)].x=shape.x;\n        line.positionPoints[grp.shapes_g.indexOf(shape)].y=shape.y;\n        line.positionPoints[grp.shapes_g.indexOf(shape)].distance_to_line_center=shape.distance_to_line_center;\n        \n      } else{\n        \n          line.positionPoints[grp.shapes_g.indexOf(shape)].x=shape.x;\n          line.positionPoints[grp.shapes_g.indexOf(shape)].y=shape.y;\n          shape.x=e.target.x();\n          shape.y=e.target.y();\n          \n          if(Math.sin(line.rotation*(Math.PI/180))==0){\n            distance_to_line_center=shape.x-line.x;\n          }else{\n            if(Math.sign(shape.x-line.x)!=0){\n              distance_to_line_center=Math.sign(-shape.rotation)*Math.sign(shape.x-line.x)*Math.sqrt((shape.x-line.x)**2+(shape.y-line.y)**2);\n            } else{\n             distance_to_line_center=Math.sign(-shape.rotation)*Math.sign(shape.y-line.y)*Math.sqrt((shape.x-line.x)**2+(shape.y-line.y)**2); \n            }\n          \n            if(shape.rotation*(Math.PI/180)<=-Math.PI/2 || (shape.rotation*(Math.PI/180)<=Math.PI/2 && shape.rotation*(Math.PI/180)>=0)){\n              distance_to_line_center=-distance_to_line_center\n            }\n          }\n          //shape.distance_to_line_center=distance_to_line_center;\n          //grp.line.occupiedDistances[shapes_g.indexOf(shape)]=shape.distance_to_line_center;\n        line.positionPoints[grp.shapes_g.indexOf(shape)].distance_to_line_center=shape.distance_to_line_center;\n          \n      }\n      let pos = { x: shape.x, y: shape.y };\n      this.center.x=shape.x;\n      this.center.y=shape.y;\n      e.target.position(pos);\n      e.target.getLayer().batchDraw();\n      if(!this.isCoordinateOnLine(shape.x,shape.y,line.id)){\n        shape.dragBoundFunc= dragFunc;\n        shape.isGrouped=0;\n        this.shapes.push(shape,)\n        for (let i=0;i<shapes_g.length;i++){\n          if(shapes_g[i].id==shape.id){\n            line.freeDistances.push(line.occupiedDistances[i]);\n            line.occupiedDistances.splice(i,1);\n            shapes_g.splice(i,1);\n            console.log(\"a shape has been removed from the line\");\n          }\n        } \n      }else{\n        if(!line.keepDistribution){\n          grp.line.occupiedDistances[shapes_g.indexOf(shape)]=distance_to_line_center;\n        }else{\n        grp.line.occupiedDistances[shapes_g.indexOf(shape)]=shape.distance_to_line_center;\n        }\n        \n      line.positionPoints[grp.shapes_g.indexOf(shape)].x=shape.x;\n      line.positionPoints[grp.shapes_g.indexOf(shape)].y=shape.y;\n      line.positionPoints[grp.shapes_g.indexOf(shape)].distance_to_line_center=shape.distance_to_line_center;\n       \n      } \n      \n          if(line.keepDistribution){\n            this.updateOccupiedDistance(line.id);\n          }\n          \n          this.updateAllPosInGrp(line.id);\n          this.updateNaration(grp);\n    },\n    /*\n    Function called when the transformation of a shape with a transfomer is finished.\n    */\n    updateTransformedShape(e) {\n      \n\n      let res;\n      let shape; //Object concerned by the transformation\n      if(e.target.className==\"Line\"){\n        shape=this.groups.find(\n        (r) => r.id === this.selectedShapeId\n      ).line;\n      }else{\n        res=this.findShape(this.selectedShapeId)\n        shape=res.shape_data;\n        if(shape== undefined){\n          return;\n        }\n      }\n\n      \n      let last_shapex= shape.x;\n      let last_shapey= shape.y;\n\n      //update data of the transformed object.\n      shape.x = e.target.x();\n      shape.y = e.target.y();\n      shape.rotation = e.target.rotation();\n      let last_scaleX= shape.scaleX;\n      shape.scaleX = e.target.scaleX();\n      shape.scaleY = e.target.scaleY();\n\n      if(e.target.className==\"Line\"){\n        const grp=this.groups.find((r)=> r.id===shape.id);\n        if(shape.keepDistribution){\n          for (let i=0;i<shape.occupiedDistances.length;i++){\n            shape.occupiedDistances[i]=(shape.occupiedDistances[i]/last_scaleX)*shape.scaleX;\n          }\n          /*\n          for (let i=0;i<shape.freeDistances.length;i++){\n            shape.freeDistances[i]=(shape.freeDistances[i]/last_scaleX)*shape.scaleX;\n          }\n          */\n          \n          //this.updateOccupiedDistance(shape.id)\n          this.update();\n          this.updateGrp(e, this.selectedShapeId);\n          this.checkIfShapesOnLine(this.selectedShapeId);        \n        }else{\n          \n          \n          \n         if(last_scaleX!=shape.scaleX){\n          for(let i=0;i<grp.shapes_g.length;i++){\n          \n          //If the width of the line has been changed, we update the distance from the shape to the center of the line\n            \n              let distX=grp.shapes_g[i].x-shape.x;\n              let distY=grp.shapes_g[i].y-shape.y;\n              /*\n              if(Math.sign(grp.shapes_g[i].distance_to_line_center)==0){\n                grp.shapes_g[i].distance_to_line_center=-this.GiveSignOfDistance(grp.shapes_g[i],shape)*Math.sqrt((distX)**2 +(distY)**2);\n              \n              }else{\n                grp.shapes_g[i].distance_to_line_center=Math.sign(grp.shapes_g[i].distance_to_line_center)*Math.sqrt((distX)**2 +(distY)**2);\n              }\n              if(Math.sign((grp.shapes_g[i].x-last_shapex))!=Math.sign(distX)){\n                grp.shapes_g[i].distance_to_line_center=-grp.shapes_g[i].distance_to_line_center;\n              }\n              */\n             if(Math.sign(grp.line.occupiedDistances[i])==0){\n                //if(grp.line.rotation!=-90 && grp.line.rotation!=90){\n                  //grp.line.occupiedDistances[i]=-this.GiveSignOfDistance(grp.shapes_g[i],shape)*Math.sqrt((distX)**2 +(distY)**2);\n                //}else{\n                  grp.line.occupiedDistances[i]=this.GiveSignOfDistance(grp.shapes_g[i],shape)*Math.sqrt((distX)**2 +(distY)**2);\n                  \n                //}\n              \n              }else{\n                grp.line.occupiedDistances[i]=Math.sign(grp.line.occupiedDistances[i])*Math.sqrt((distX)**2 +(distY)**2);\n              }\n\n              \n              if(Math.sign((grp.shapes_g[i].x-last_shapex))!=Math.sign(distX) && Math.sign((grp.shapes_g[i].x-last_shapex))!=0 && grp.line.rotation!=90 && grp.line.rotation!=-90){\n                \n                grp.line.occupiedDistances[i]=-grp.line.occupiedDistances[i];\n              }\n              if(Math.sign((grp.shapes_g[i].y-last_shapey))!=Math.sign(distY) && Math.sign((grp.shapes_g[i].y-last_shapey))!=0 && (grp.line.rotation==90 || grp.line.rotation==-90)){\n                grp.line.occupiedDistances[i]=-grp.line.occupiedDistances[i];\n              }\n              //this.checkIfShapesOnLine(this.selectedShapeId);  \n            \n            //this.checkIfShapesOnLine(this.selectedShapeId);\n            //grp.line.occupiedDistances[i]=grp.shapes_g[i].distance_to_line_center;\n            \n          }\n          for (let i=0;i<shape.freeDistances.length;i++){\n            let distX=last_shapex-shape.x;\n            let distY=last_shapey-shape.y; \n            let dist=Math.sqrt(distX**2+distY**2);\n            if(shape.rotation<-90 ||shape.rotation>90){\n              shape.freeDistances[i]=shape.freeDistances[i]-Math.sign(last_shapex-shape.x)*dist;\n            } else if(shape.rotation==90 || shape.rotation==-90){\n              shape.freeDistances[i]=shape.freeDistances[i]-distY\n            } else{\n              shape.freeDistances[i]=shape.freeDistances[i]+Math.sign(last_shapex-shape.x)*dist;\n            \n            }\n          }\n         }\n          this.update();\n          this.updateGrp(e, this.selectedShapeId);\n          this.checkIfShapesOnLine(this.selectedShapeId);\n\n          // We now see if freeDistances need to be delete(so if they are bigger than the half of the stickyline);\n          \n        }\n        for(let i=0;i<grp.shapes_g.length;i++){\n            \n          this.updateDragFunc(grp.shapes_g[i],shape);\n\n        }\n      }else if(res.grp_id!='-1'){\n        //this.update();\n        //let layer=e.target.getParent().getLayer();\n        //layer.batchDraw();\n        this.updateAllPosInGrp(res.grp_id);\n        this.updateOccupiedDistance(res.grp_id);\n        e.target.x(e.target.getParent().attrs.shapes_g.find((r)=>r.id===e.target.id()).x);\n        e.target.y(e.target.getParent().attrs.shapes_g.find((r)=>r.id===e.target.id()).y);\n        this.groups.find((r)=>r.id===res.grp_id).shapes_g.find((r)=>r.id===e.target.id()).personalRotation=e.target.rotation()-e.target.getParent().attrs.line.rotation;\n        \n        \n        this.updateAllPosInGrp(res.grp_id);\n        this.checkIfShapesOnLine(res.grp_id);\n        this.updateDragFuncOfCenter();\n      \n      }\n      else{\n        this.update();\n        \n        this.updateDragFuncOfCenter();\n      }\n      this.center.x=e.target.attrs.x;\n      this.center.y=e.target.attrs.y;\n    },\n    \n    handleTransformation(e) {\n      if (e.evt==undefined) {\n        return;\n      }\n      if(this.eraseMode==1){\n        this.eraserAction(e);\n        return;\n      }\n      \n      //If we click on the stage, we have to remove the transformer from the node where it was.\n      if (e.target === e.target.getStage()) {\n        this.selectedShapeId = 'NoId';\n        this.eraseNodefromTransformer(\"lineTransformer\");\n        this.eraseNodefromTransformer(\"shapeTransformer\");\n        this.center.opacity=0;\n        return;\n      }\n\n      // If we click on a transformer, nothing happen.\n      const clickedOnTransformer = e.target.getParent().className === 'Transformer';\n      if (clickedOnTransformer) {\n        return;\n      }\n      \n      const id = e.target.id();\n      let transformer_id;\n      let shape=this.findShape(id).shape_data;\n\n      //if it is a line, we need the transformer dedicated to the line (ie transformer with id=\"lineTransformer\")\n      //if it is a classic shape, we need the transformer dedicated to the shape (ie transformer with id=\"shapeTransformer\")\n      if(e.target.attrs.id==\"center\"){\n        return;\n      }\n      if(e.target.className==\"Line\"){\n        transformer_id=\"lineTransformer\"\n        shape = this.groups.find((r) => r.id === id).line;\n        this.center.draggable=false;\n        this.selectedShapeAlignment=shape.defaultAlignment;\n        this.eraseNodefromTransformer(\"shapeTransformer\");\n      }else{\n        transformer_id=\"shapeTransformer\"\n        this.center.draggable=true;\n        this.selectedShapeAlignment=shape.centerPosition;\n        this.eraseNodefromTransformer(\"lineTransformer\");\n      }\n      \n      if (shape!=undefined) {\n        this.selectedShapeId = id;\n        this.center.opacity=1;\n        this.updateTransformer(transformer_id);\n      } else{\n        /*Only if the center is not selected.\n        When the center is dragged, this function is called.\n        But a shape is actualy selected (the one of the center).\n        */\n        this.selectedShapeId = 'NoId';\n      }\n      //this.updateTransformer(transformer_id);\n      \n      this.updateDragFuncOfCenter()\n    },\n\n    //remove node from transformer with id=transformer_id\n    eraseNodefromTransformer(transformer_id) {\n      let stage= this.$refs.stage.getStage();      \n      const transformerNode = stage.find(\"#\"+transformer_id)[0]; \n      transformerNode.nodes([]);\n    },\n\n    //Update transformer with id=transformer_id\n    //It places the transformer regarding what node is selected\n    updateTransformer(transformer_id) {\n\n      let stage= this.$refs.stage.getStage();\n      const transformerNode = stage.find(\"#\"+transformer_id)[0];\n      let selectedNode;\n      if (transformer_id==\"lineTransformer\"){\n        selectedNode = stage.children[0].getChildren().filter((r)=> r.attrs.className==\"Group\" && r.attrs.id==this.selectedShapeId)[0]\n        .getChildren().filter(r=>r.attrs.className==\"Line\" && r.attrs.id==this.selectedShapeId)[0];\n      }else{\n      selectedNode = stage.children[0].getChildren().filter((r)=>r.attrs.className!=\"Group\" && r.attrs.id==this.selectedShapeId)[0];\n\n      let isFunded=true;\n      if(selectedNode==undefined){\n        isFunded=false;\n      }\n      let i=0;\n      while(!isFunded){\n        if(i<this.groups.length){\n          selectedNode=stage.children[0].getChildren().filter((r)=>r.attrs.className==\"Group\")[i].getChildren().find((r)=>r.attrs.id==this.selectedShapeId && r.attrs.className!=\"Line\");\n        if(selectedNode==undefined){\n          isFunded=false;\n        }else{\n          isFunded=true;\n        }\n        i++;\n        }else{        \n          isFunded=true;\n        }\n      }\n      }\n      /*\n      if (transformer_id==\"lineTransformer\"){\n        selectedNode = stage.children[0].getChildren().filter((r)=> r.attrs.className==\"Group\" && r.attrs.id==this.selectedShapeId)[0]\n        .getChildren().filter(r=>r.attrs.className==\"Line\" && r.attrs.id==this.selectedShapeId)[0];\n      }\n      */\n     \n      //If the selected node has already the transformer on it, nothing happen\n      if (selectedNode === transformerNode.node()) {\n        return;\n      }\n\n      //If a node is selected\n      if (selectedNode!=undefined) {\n        //We attach the transformer to the node\n        transformerNode.nodes([selectedNode]);\n      } else {\n        //if no node is selected, we remove the transformer from its node.\n        transformerNode.nodes([]);\n      }\n      this.center.x=selectedNode.attrs.x;\n      this.center.y=selectedNode.attrs.y;\n      \n    },\n/*\n  DisplayCenterMenu(e){\n    CenterMenu.props.ConcernedShape=e.target;\n   document.getElementById(\"center_menu\").style.display=\"initial\";\n   document.getElementById(\"center_menu\").style.top=e.target.getStage().getPointerPosition().y+8+\"px\";\n  document.getElementById(\"center_menu\").style.left=e.target.getStage().getPointerPosition().x+8+\"px\";\n  },\n  */\n\n  //display context menu according to the target\n  /*\n  DisplayContextMenu(e){\n    e.evt.preventDefault()\n    if (e.target.className!=undefined && e.target.attrs.id!=\"center\"){\n      this.isStageOnlySelected=false;\n      ContextMenu.data().dM='initial';\n      this.$emit('needmenu');\n      this.needMenu=true;\n      ContextMenu.props.ConcernedShape=e.target;\n      if (e.target.attrs.className==\"Line\"){\n        this.isALineSelected=true;\n        this.isAGroupedShapeSelected=true;\n        //We precise the text which depends on the line where we clicked.\n        this.keepDistanceButtonText=e.target.attrs.keepDistanceButtonText;\n      } else if(e.target.getParent().attrs.className==\"Group\"){\n        this.isAGroupedShapeSelected=true;\n      }\n      else{\n        this.isALineSelected=false;\n        this.isAGroupedShapeSelected=false;\n      }\n      \n      document.getElementById(\"activeReuseSubstrate\").style.display=\"initial\";\n      document.getElementById(\"activeReuseSubstrate\").style.top= document.getElementById(\"ReificationSubstrateDemo\").getBoundingClientRect().top+document.documentElement.scrollTop+e.target.getStage().getPointerPosition().y+\"px\";\n      document.getElementById(\"activeReuseSubstrate\").style.left= document.getElementById(\"ReificationSubstrateDemo\").getBoundingClientRect().left+document.documentElement.scrollLeft+e.target.getStage().getPointerPosition().x+\"px\";\n    }\n    if (e.target === e.target.getStage()) {\n      this.needMenu=true;\n      this.isALineSelected=false;\n      this.isAGroupedShapeSelected=false;\n      this.isStageOnlySelected=true;\n      document.getElementById(\"activeReuseSubstrate\").style.display=\"initial\";\n      document.getElementById(\"activeReuseSubstrate\").style.top=document.getElementById(\"ReificationSubstrateDemo\").getBoundingClientRect().top+document.documentElement.scrollTop+e.target.getStage().getPointerPosition().y+\"px\";\n      document.getElementById(\"activeReuseSubstrate\").style.left=document.getElementById(\"ReificationSubstrateDemo\").getBoundingClientRect().left+document.documentElement.scrollLeft+e.target.getStage().getPointerPosition().x+\"px\";\n    \n    }\n  },\n\n  //hide context menu\n  HideContextMenu(){\n    this.needMenu=false;\n    document.getElementById(\"activeReuseSubstrate\").style.display=\"none\";\n    document.getElementById(\"center_menu\").style.display=\"none\";\n  },\n*/\n\n  \n ChangeCenter(e){\n  let res=this.findShape(this.selectedShapeId);\n  let shape=res.shape_data;\n  let threshold1;\n  let threshold2;\n  let dist=this.GiveSignOfDistanceBtwCenterAndShape(e.target.attrs,shape)*Math.sqrt((e.target.y()-(shape.y))**2+(e.target.x()-shape.x)**2)+shape.offsetY*shape.scaleY;\n  \n  //let last_offsetX=shape.offsetX;\n  let last_offsetY=shape.offsetY;\n  if(shape==undefined){\n    shape=this.groups.find((r)=>r.id==this.selectedShapeId).line;\n\n  }else{\n    \n      if(shape.className==\"Rect\") {\n        threshold1=shape.height*shape.scaleY/3;\n        threshold2=shape.height*shape.scaleY*2/3;\n        if(dist>=threshold1 && dist<=threshold2){\n          shape.offsetX=shape.width/2;\n          shape.offsetY=shape.height/2;\n          shape.centerPosition=\"Middle\";\n        }else if(dist>threshold2){\n          shape.offsetX=shape.width/2;\n          shape.offsetY=shape.height;\n          shape.centerPosition=\"Bottom\";\n        }\n        else{\n          shape.offsetX=shape.width/2;\n          shape.offsetY=0;\n          shape.centerPosition=\"Top\";\n        }\n      }\n      else if(shape.className==\"Circle\") {\n        dist=dist+shape.radius*shape.scaleY;\n        threshold1=shape.radius*shape.scaleY*2/3;\n        threshold2=shape.radius*shape.scaleY*4/3;\n        if(dist>=threshold1 && dist<=threshold2){\n          shape.offsetX=0;\n          shape.offsetY=0;\n          shape.centerPosition=\"Middle\";\n        }else if(dist>threshold2){\n          shape.offsetX=0;\n          shape.offsetY=shape.radius;\n          shape.centerPosition=\"Bottom\";\n        }else{\n          shape.offsetX=0;\n          shape.offsetY=-shape.radius;\n          shape.centerPosition=\"Top\";\n        } \n      }\n      else if(shape.className==\"Image\") {\n        threshold1=shape.image.height*shape.scaleY/3;\n        threshold2=shape.image.height*shape.scaleY*2/3;\n        if(dist>=threshold1 && dist<=threshold2){\n          shape.offsetX=shape.image.width/2;\n          shape.offsetY=shape.image.height/2;\n          shape.centerPosition=\"Middle\";\n        }else if(dist>threshold2){\n          shape.offsetX=shape.image.width/2;\n          shape.offsetY=shape.image.height;\n          shape.centerPosition=\"Bottom\";\n        }\n        else {\n          shape.offsetX=shape.image.width/2;\n          shape.offsetY=0;\n          shape.centerPosition=\"Top\";\n        }\n      }\n      else if(shape.className==\"Text\") {\n        threshold1=shape.length_y*shape.scaleY/3;\n        threshold2=shape.length_y*shape.scaleY*2/3;\n        if(dist>=threshold1 && dist<=threshold2){\n          shape.offsetX=shape.length_x/2;\n          shape.offsetY=shape.length_y/2;\n          shape.centerPosition=\"Middle\";\n        }else if(dist>threshold2){\n          shape.offsetX=shape.length_x/2;\n          shape.offsetY=shape.length_y;\n          shape.centerPosition=\"Bottom\";\n        }\n        else{\n          shape.offsetX=shape.length_x/2;\n          shape.offsetY=0;\n          shape.centerPosition=\"Top\";\n        }\n      }\n      else if(shape.className==\"Triangle\") {\n        dist=dist+shape.radius*shape.scaleY;\n        threshold1=shape.radius*shape.scaleY/2;\n        threshold2=shape.radius*shape.scaleY*5/4;\n        if(dist>=threshold1 && dist<=threshold2){\n          shape.offsetX=0;\n          shape.offsetY=0;\n        }else if(dist>threshold2){\n          shape.offsetX=0;\n          shape.offsetY=shape.radius/2\n          shape.centerPosition=\"Bottom\";\n        }\n        else{\n          shape.offsetX=0;\n          shape.offsetY=-shape.radius;\n          shape.centerPosition=\"Top\";\n        }\n      }\n      shape.y=shape.y-(last_offsetY-shape.offsetY)*shape.scaleY*Math.cos(shape.rotation*(Math.PI/180));\n      shape.x=shape.x+(last_offsetY-shape.offsetY)*shape.scaleY*Math.sin(shape.rotation*(Math.PI/180));\n      this.selectedShapeAlignment=shape.centerPosition;\n\n      if (res.grp_id!='-1'){\n        this.updateAllPosInGrp(res.grp_id);\n      }\n        \n      e.target.x(shape.x);\n      e.target.y(shape.y);\n\n     \n\n      \n  }\n  },\n  \n  /*\n  ChangeAlignCenter(align_choice){\n    let center=CenterMenu.props.ConcernedShape;\n    let grp=this.groups.find((r)=>r.id===this.selectedShapeId);\n    let shape;\n    if(grp!=undefined){\n      for(let i=0;i<grp.shapes_g.length;i++){\n        this.ChangeCenterRegardingCommand(grp.shapes_g[i].id,align_choice)\n      }\n      center.x(grp.line.x);\n      center.y(grp.line.y);\n      if(grp.line.defaultAlignment==align_choice){\n        grp.line.defaultAlignment='' //If we select again the same alogn_choice, we deselect it, no alignement center is fixed.\n      }else{\n        grp.line.defaultAlignment=align_choice;\n      }\n      this.selectedShapeAlignment=grp.line.defaultAlignment;\n    }else{\n      shape=this.findShape(this.selectedShapeId).shape_data;\n      this.ChangeCenterRegardingCommand(shape.id,align_choice)\n      this.selectedShapeAlignment=shape.centerPosition;\n      center.x(shape.x);\n      center.y(shape.y);\n    }\n  },\n  */\n  //Allow to change the center regarding a text command (Top,Middle or Bottom)\n  ChangeCenterRegardingCommand(shape_id,command){\n    let res=this.findShape(shape_id);\n    let shape=res.shape_data;\n    let last_offsetY=shape.offsetY;\n    if(shape.className==\"Rect\" ){\n      if(command==\"Top\"){\n        shape.offsetY=0;\n        shape.offsetX=shape.width/2;\n      }\n      else if(command==\"Middle\"){\n          shape.offsetX=shape.width/2;\n          shape.offsetY=shape.height/2;\n      }else if(command==\"Bottom\"){\n            shape.offsetX=shape.width/2;\n            shape.offsetY=shape.height;\n      }\n    }\n      else if(shape.className==\"Circle\") {\n        if(command==\"Top\"){\n          shape.offsetX=0;\n          shape.offsetY=-shape.radius;\n        }else if(command==\"Middle\"){\n          shape.offsetX=0;\n          shape.offsetY=0\n        }else if(command==\"Bottom\"){\n          shape.offsetX=0;\n          shape.offsetY=shape.radius;\n        } \n      }\n      else if(shape.className==\"Image\") {\n        if(command==\"Middle\"){\n          shape.offsetX=shape.image.width/2;\n          shape.offsetY=shape.image.height/2;\n        }else if(command==\"Bottom\"){\n          shape.offsetX=shape.image.width/2;\n          shape.offsetY=shape.image.height;\n        }\n        else if (command==\"Top\"){\n          shape.offsetX=shape.image.width/2;\n          shape.offsetY=0;\n        }\n      }\n      else if(shape.className==\"Text\") {\n        if(command==\"Middle\"){\n          shape.offsetX=shape.length_x/2;\n          shape.offsetY=shape.length_y/2;\n        }else if(command==\"Bottom\"){\n          shape.offsetX=shape.length_x/2;\n          shape.offsetY=shape.length_y;\n        }\n        else if(command==\"Top\"){\n          shape.offsetX=shape.length_x/2;\n          shape.offsetY=0;\n        }\n      }\n      else if(shape.className==\"Triangle\") {\n        if(command==\"Middle\"){\n          shape.offsetX=0;\n          shape.offsetY=0;\n        }else if(command==\"Bottom\"){\n          shape.offsetX=0;\n          shape.offsetY=shape.radius/2;\n        }\n        else if(command==\"Top\"){\n          shape.offsetX=0;\n          shape.offsetY=-shape.radius;\n        }\n      }\n      shape.centerPosition=command;\n      shape.y=shape.y-(last_offsetY-shape.offsetY)*shape.scaleY*Math.cos(shape.rotation*(Math.PI/180));\n      shape.x=shape.x+(last_offsetY-shape.offsetY)*shape.scaleY*Math.sin(shape.rotation*(Math.PI/180));\n\n      if (res.grp_id!='-1'){\n        this.updateAllPosInGrp(res.grp_id);\n      }\n        \n      //center.x(shape.x);\n      //center.y(shape.y);\n  },\n  updateDragFuncOfCenter(){\n    \n    let shape=this.findShape(this.selectedShapeId).shape_data\n    if(shape==undefined){\n      return;\n    }\n    let center=this.center;\n    let angle=shape.rotation*(Math.PI/180);\n    if(angle>=-Math.PI/2 && angle<=0){\n      angle-=90*(Math.PI/180);\n    }else if(angle<-Math.PI/2){\n      angle+=(Math.PI/2);\n      angle=Math.PI+angle;\n    } else if(angle<=Math.PI && angle>0){\n      angle-=90*(Math.PI/180);\n    } \n    if (angle<=0 && angle>=-Math.PI/4){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x +(pos.x-shape.x)*Math.cos(angle),\n          y: shape.y+(pos.x-shape.x)*Math.sin(angle),\n        };\n      }\n    } else if (angle<-Math.PI/4 && angle>=-Math.PI/2){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x-(pos.y-shape.y)*Math.cos(angle),\n          y: shape.y-(pos.y-shape.y)*Math.sin(angle),\n        };\n      }\n    }\n    else if (angle<-Math.PI/2 && angle>=-3*Math.PI/4){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x-(pos.y-shape.y)*Math.cos(angle),\n          y: shape.y-(pos.y-shape.y)*Math.sin(angle),\n        };\n      }\n    } else if (angle<-3*Math.PI/4 && angle>=-Math.PI){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x-(pos.x-shape.x)*Math.cos(angle),\n          y: shape.y-(pos.x-shape.x)*Math.sin(angle),\n        };\n      }\n    }else if (angle<=Math.PI && angle>=3*Math.PI/4){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x-(pos.x-shape.x)*Math.cos(angle),\n          y: shape.y-(pos.x-shape.x)*Math.sin(angle),\n        };\n      }\n    } else if (angle<3*Math.PI/4 && angle>=Math.PI/2){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x+(pos.y-shape.y)*Math.cos(angle),\n          y: shape.y+(pos.y-shape.y)*Math.sin(angle),\n        };\n      }\n    } else if (angle<Math.PI/2 && angle>=Math.PI/4){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x+(pos.y-shape.y)*Math.cos(angle),\n          y: shape.y+(pos.y-shape.y)*Math.sin(angle),\n        };\n      }\n    }else if (angle<Math.PI/4 && angle>=0){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x+(pos.x-shape.x)*Math.cos(angle),\n          y: shape.y+(pos.x-shape.x)*Math.sin(angle),\n        };\n      }\n    }\n  },\n  MovingCenter(){\n    //let shape=this.findShape(this.selectedShapeId)\n    //console.log(e.target)\n  },\n  /*\n  //called when the \"Change Center\" button is clicked\n  ChangeCenterButtonAction(){\n      let shape= ContextMenu.props.ConcernedShape;\n      if(shape.attrs.className==\"Line\"){\n        let shapes_g=shape.getParent().attrs.shapes_g //the list of the shapes which are on the line is in the corresponding group.\n        for (let j=0;j<shapes_g.length;j++){\n          this.ChangeCenter(shapes_g[j]);\n        }\n      }else{\n        let shape_data=this.shapes.find(i => i.id ===shape.attrs.id);\n        let isFunded=true;\n        if(shape_data==undefined){\n          isFunded=false;\n        }\n        let i=0;\n        while(!isFunded){\n          if(i<this.groups.length){\n            shape_data=this.groups[i].shapes_g.find(i => i.id === shape.attrs.id);\n          if(shape_data==undefined){\n            isFunded=false;\n          }else{\n            isFunded=true;\n          }\n          i++;\n          }else{        \n            isFunded=true;\n          }\n        }\n        this.ChangeCenter(shape_data)\n      }\n    },\n    */\n    \n    //allow to copy a target\n    \n    /*\n    Copy(){\n      ContextMenu.props.CopiedShape=ContextMenu.props.ConcernedShape;\n      ContextMenu.props.pastOneObject=true;\n    },\n    \n    CopyAll(){\n      ContextMenu.props.CopiedShape=ContextMenu.props.ConcernedShape;\n      ContextMenu.props.pastOneObject=false;\n    },\n    \n    Past(){   \n      //Prevent error when no shape is copied\n      if(ContextMenu.props.CopiedShape.attrs==undefined){\n        return;\n      }\n      let clone=ContextMenu.props.CopiedShape.clone({\n        id: ''+this.max_id_figures,\n      })\n      //let layer=ContextMenu.props.CopiedShape.getLayer();\n      let i= this.groups.length\n      //let new_id=i+1;\n      if(ContextMenu.props.CopiedShape.attrs.className==\"Line\"){\n        this.max_id_figures=this.max_id_figures+1;\n        if(!ContextMenu.props.pastOneObject){\n          //let i= this.groups.length;\n          //let new_id=i+1;\n        \n          clone=ContextMenu.props.CopiedShape.getParent().clone({\n            id: ''+ this.max_id_figures,\n            name: \"group\"+this.max_id_figures,\n            shapes_g:[],\n          })\n          clone.attrs.line.id=''+this.max_id_figures;\n          clone.attrs.line.x=ContextMenu.props.ConcernedShape.getStage().getPointerPosition().x;\n          clone.attrs.line.y=ContextMenu.props.ConcernedShape.getStage().getPointerPosition().y;\n          let positionPoints=Object.assign([],clone.attrs.line.positionPoints);\n            let length=positionPoints.length;\n            clone.attrs.line.positionPoints=[];\n            for(let i=0;i<length.valueOf();i++){\n              let clone_positionPoint=ContextMenu.props.CopiedShape.getParent().getChildren().find((r)=>r.attrs.id===positionPoints[i].id).clone({\n              id:'positionPoint'+clone.attrs.line.id+i,\n              });\n              clone.attrs.line.positionPoints.push(clone_positionPoint.attrs,);\n            }\n          \n          //layer= ContextMenu.props.CopiedShape.getParent().getLayer();\n          this.groups.push(clone.attrs,);\n          let shapesg=this.groups[this.groups.indexOf(this.groups.find((r)=> r.id==ContextMenu.props.CopiedShape.getParent().attrs.id))].shapes_g;\n          let shapesg_length=shapesg.length;\n          for (let j=0; j<shapesg_length;j++){\n            this.max_id_figures=this.max_id_figures + 1;\n            let clone_shape=ContextMenu.props.CopiedShape.getParent().getChildren().find((r)=>r.attrs.id===shapesg[j].id).clone({\n              id:''+this.max_id_figures,\n            });\n           // this.updateDragFunc(clone_shape,clone_line);\n            this.groups[i].shapes_g.push(clone_shape.attrs,);\n            this.updateDragFunc(this.groups[i].shapes_g[this.groups[i].shapes_g.length-1],this.groups[i].line);\n          }\n          this.updateAllPosInGrp(clone.attrs.id);\n        }else{\n          //let i= this.groups.length;\n          //let new_id=i+1;\n        \n          clone=ContextMenu.props.CopiedShape.getParent().clone({\n            id: ''+this.max_id_figures,\n            name: \"group\"+this.max_id_figures,\n            shapes_g:[],\n          })\n          clone.attrs.line.id=''+this.max_id_figures;\n          clone.attrs.line.x=ContextMenu.props.ConcernedShape.getStage().getPointerPosition().x;\n          clone.attrs.line.y=ContextMenu.props.ConcernedShape.getStage().getPointerPosition().y;\n          for(let j=0;j<clone.attrs.line.occupiedDistances.length;j++){\n            clone.attrs.line.freeDistances.push(clone.attrs.line.occupiedDistances[j],);\n          }\n          clone.attrs.line.occupiedDistances=[];\n          if(clone.attrs.line.keepDistribution!=1){\n            let positionPoints=Object.assign([],clone.attrs.line.positionPoints);\n            let length=positionPoints.length;\n            clone.attrs.line.positionPoints=[];\n            for(let i=0;i<length.valueOf();i++){\n              let clone_positionPoint=ContextMenu.props.CopiedShape.getParent().getChildren().find((r)=>r.attrs.id===positionPoints[i].id).clone({\n              id:'positionPoint'+clone.attrs.line.id+i,\n              });\n              clone.attrs.line.positionPoints.push(clone_positionPoint.attrs,);\n            }\n          }\n          //layer= ContextMenu.props.CopiedShape.getParent().getLayer();\n          this.groups.push(clone.attrs,)\n        }\n        //In order to actualize the new line (in particular to show the positionPoints):\n        this.updateAllPosInGrp(clone.attrs.id)\n      } \n      else{\n        this.max_id_figures=this.max_id_figures + 1;\n        clone=ContextMenu.props.CopiedShape.clone({\n          id: ''+this.max_id_figures,  \n          x:ContextMenu.props.ConcernedShape.getStage().getPointerPosition().x,\n          y:ContextMenu.props.ConcernedShape.getStage().getPointerPosition().y,\n        });\n        clone.attrs.dragBoundFunc=function (pos) {\n          return {\n            x: pos.x,\n            y: pos.y,\n          };\n        };\n        clone.attrs.isGrouped=0;\n        this.shapes.push(clone.attrs,); \n         \n      }\n      //layer.batchDraw(); \n      \n    },\n    \n    //RemoveShape(shape)\n    Remove(shape){\n      //let shape=ContextMenu.props.ConcernedShape;\n      if(shape.attrs.className==\"Line\"){\n        let grp=this.groups.find((r)=>r.id===shape.attrs.id);\n        const length=grp.shapes_g.length;\n        for(let i=0;i<length;i++){\n          grp.shapes_g[i].dragBoundFunc= dragFunc;\n          grp.shapes_g[i].isGrouped=0;\n          this.shapes.push(grp.shapes_g[i],);\n        }\n        this.eraseNodefromTransformer(\"lineTransformer\");\n        this.groups.splice(this.groups.indexOf(grp),1);\n        shape.getParent().destroy();\n\n        //We give to the circle (representing center of shapes) a default position\n        if(this.groups[0]!=undefined){\n          this.center.x=this.groups[0].line.x;\n          this.center.y=this.groups[0].line.y;\n        } else if(this.shapes[0]!=undefined){\n          this.center.x=this.shapes[0].x;\n          this.center.y=this.shapes[0].y;\n        }\n        this.center.opacity=0;\n        \n      }else if(shape.attrs.className==\"positionPoint\"){\n        let line=shape.getParent().attrs.line;\n        let target_positionPoint=line.positionPoints.find((r)=>r.id===shape.attrs.id);\n        let index=line.freeDistances.indexOf(shape.attrs.distance_to_line_center);\n        console.log(line.positionPoints);\n        if(line.keepDistribution!=1 && index!=-1){\n          line.freeDistances.splice(index,1);\n          line.positionPoints.splice(line.positionPoints.indexOf(target_positionPoint),1)\n        }\n      }\n      else{\n        let res=this.findShape(shape.attrs.id)\n        let shape_data=res.shape_data;\n        let grp_id=res.grp_id;\n        if(shape_data!=undefined){\n        if(grp_id!='-1'){\n        //let shape_data=this.shapes.find(i => i.id ===shape.attrs.id);\n        let grp=this.groups.find((r)=>r.id===grp_id);\n          grp.line.freeDistances.push(grp.line.occupiedDistances[grp.shapes_g.indexOf(shape_data)],)\n          grp.line.occupiedDistances.splice(grp.shapes_g.indexOf(shape_data),1)\n          \n          grp.shapes_g.splice(grp.shapes_g.indexOf(shape_data),1);\n          this.updateOccupiedDistance(grp.id);\n          \n          this.updateAllPosInGrp(grp.id);\n          \n         console.log(grp.line.positionPoints)\n      \n        } else{\n          this.eraseNodefromTransformer(\"shapeTransformer\");\n          this.shapes.splice(this.shapes.indexOf(shape_data),1);\n          //We give to the circle (representing center of shapes) a default position\n          if(this.groups[0]!=undefined){\n            this.center.x=this.groups[0].line.x;\n            this.center.y=this.groups[0].line.y;\n          } else if(this.shapes[0]!=undefined){\n            this.center.x=this.shapes[0].x;\n            this.center.y=this.shapes[0].y;\n          }\n          this.center.opacity=0;\n        }\n        shape.destroy();\n        }\n      }\n    },\n\n    RemoveAll(){\n      let shape=ContextMenu.props.ConcernedShape;\n      if(shape.className==\"Line\"){\n        let grp=this.groups.find((r)=>r.id===shape.attrs.id);\n        while(grp.shapes_g.length!=0){\n          grp.shapes_g[0].dragBoundFunc= dragFunc;\n          grp.shapes_g.splice(0,1);\n        }\n        this.eraseNodefromTransformer(\"lineTransformer\");\n        this.groups.splice(this.groups.indexOf(grp),1);\n        shape.getParent().destroy();\n\n        //We give to the circle (representing center of shapes) a default position\n        if(this.groups[0]!=undefined){\n          this.center.x=this.groups[0].line.x;\n          this.center.y=this.groups[0].line.y;\n        } else if(this.shapes[0]!=undefined){\n          this.center.x=this.shapes[0].x;\n          this.center.y=this.shapes[0].y;\n        }\n        \n      }else{\n        return;\n      }\n    },\n    */\n\n    findShape(id){ \n      let shape_data=this.shapes.find(i => i.id ===id);\n      let grp_id='-1'; // return grp_id=-1 if the shape doesn't belong to attached group.\n      let isFunded=true;\n      if(shape_data==undefined){\n        isFunded=false;\n      }\n      let i=0;\n      while(!isFunded){\n        if(i<this.groups.length){\n          shape_data=this.groups[i].shapes_g.find(i => i.id === id);\n        if(shape_data==undefined){\n          isFunded=false;\n        }else{\n          grp_id=this.groups[i].id; \n          isFunded=true;\n        }\n        i++;\n        }else{        \n          isFunded=true;\n        }\n      }\n      return {shape_data, grp_id}\n    },\n\n    //detach a shape from its line.\n     DetachShape(shape,target_x,target_y){\n      \n      \n      const added_distance=this.lengthToCapture+5;\n      let grp=this.groups.find((r)=>r.shapes_g.indexOf(shape)!=-1);\n      let i=grp.shapes_g.indexOf(shape);\n      \n      shape.dragBoundFunc= dragFunc;\n\n      let coord_y1=grp.line.y-grp.line.points[4]*(1/2)*grp.line.scaleX*Math.sin(grp.line.rotation*(Math.PI/180));\n      let coord_x2=grp.line.x+grp.line.points[4]*(1/2)*grp.line.scaleX*Math.cos(grp.line.rotation*(Math.PI/180));\n      let coord_y2= grp.line.y+grp.line.points[4]*(1/2)*grp.line.scaleX*Math.sin(grp.line.rotation*(Math.PI/180));\n      let coord_x1=grp.line.x-grp.line.points[4]*(1/2)*grp.line.scaleX*Math.cos(grp.line.rotation*(Math.PI/180));\n      let a=(coord_y2-coord_y1)/(coord_x2-coord_x1);\n      //let b=grp.line.y-a*grp.line.x;\n      let b=shape.x*(1/a)+shape.y;\n      if (grp.line.rotation<0 && grp.line.rotation>-45){\n        \n        shape.x=shape.x+Math.sign(shape.y-target_y)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } else if (grp.line.rotation<=-45 && grp.line.rotation>-90){\n        \n        shape.x=shape.x+Math.sign(shape.x-target_x)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      }\n      \n      else if(grp.line.rotation<-90 && grp.line.rotation>-135){\n        shape.x=shape.x+Math.sign(shape.x-target_x)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } \n      else if(grp.line.rotation<=-135 && grp.line.rotation>-180){\n        shape.x=shape.x-Math.sign(shape.y-target_y)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } \n      \n      else if( grp.line.rotation>135 && grp.line.rotation<180){\n        \n        shape.x=shape.x-Math.sign(shape.y-target_y)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } else if( grp.line.rotation>90 && grp.line.rotation<=135){\n        \n        shape.x=shape.x-Math.sign(shape.x-target_x)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } else if( grp.line.rotation>45 && grp.line.rotation<=90){\n        \n        shape.x=shape.x-Math.sign(shape.x-target_x)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } else if( grp.line.rotation>0 && grp.line.rotation<=45){\n        \n        shape.x=shape.x+Math.sign(shape.y-target_y)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } \n      else if(grp.line.rotation==-90){\n        shape.x=shape.x-Math.sign(shape.x-target_x)*added_distance\n      } else if(grp.line.rotation==90){\n        shape.x=shape.x+Math.sign(shape.x-target_x)*added_distance\n      } else if(grp.line.rotation==180 || grp.line.rotation==-180){\n        shape.y=shape.y-Math.sign(shape.y-target_y)*added_distance\n      } else if(grp.line.rotation==0){\n        shape.y=shape.y-Math.sign(shape.y-target_y)*added_distance\n      } \n      //shape.rotation=shape.rotation+shape.personalRotation;\n      shape.isGrouped=0;\n      this.shapes.push(shape,)\n      this.center.x=shape.x;\n      this.center.y=shape.y;\n      grp.line.freeDistances.push(grp.line.occupiedDistances[i]);\n      grp.line.occupiedDistances.splice(i,1);\n      grp.shapes_g.splice(i,1);\n      grp.line.positionPoints.splice(i,1)\n      \n      this.updateOccupiedDistance(grp.id)\n      this.updateAllPosInGrp(grp.id)\n      this.updateNaration(grp)\n\n      this.eraseNodefromTransformer(\"shapeTransformer\");\n      //We erase ghosts og attached shapes and we make sure that their opacity is 1.\n      grp.ghosts.splice(0,grp.ghosts.length);\n      for (let i=0;i<grp.shapes_g.length;i++){\n        grp.shapes_g[i].opacity=1;\n      }\n    \n    },\n    /*\n    DetachShape(shape){\n      \n      \n      const added_distance=this.lengthToCapture+5;\n      let grp=this.groups.find((r)=>r.shapes_g.indexOf(shape)!=-1);\n      let i=grp.shapes_g.indexOf(shape);\n      \n      shape.dragBoundFunc= dragFunc;\n\n      let coord_y1=grp.line.y-grp.line.points[4]*(1/2)*grp.line.scaleX*Math.sin(grp.line.rotation*(Math.PI/180));\n      let coord_x2=grp.line.x+grp.line.points[4]*(1/2)*grp.line.scaleX*Math.cos(grp.line.rotation*(Math.PI/180));\n      let coord_y2= grp.line.y+grp.line.points[4]*(1/2)*grp.line.scaleX*Math.sin(grp.line.rotation*(Math.PI/180));\n      let coord_x1=grp.line.x-grp.line.points[4]*(1/2)*grp.line.scaleX*Math.cos(grp.line.rotation*(Math.PI/180));\n      let a=(coord_y2-coord_y1)/(coord_x2-coord_x1);\n      //let b=grp.line.y-a*grp.line.x;\n      let b=shape.x*(1/a)+shape.y;\n      if (grp.line.rotation<0 && grp.line.rotation>-90){\n        \n        shape.x=shape.x-added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } else if(grp.line.rotation<-90){\n        shape.x=shape.x-added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } else if( grp.line.rotation>0 && grp.line.rotation<180){\n        \n        shape.x=shape.x+added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } \n      else if(grp.line.rotation==-90){\n        shape.x=shape.x+added_distance\n      } else if(grp.line.rotation==90){\n        shape.x=shape.x-added_distance\n      } else if(grp.line.rotation==180 || grp.line.rotation==-180){\n        shape.y=shape.y-added_distance\n      } else if(grp.line.rotation==0){\n        shape.y=shape.y+added_distance\n      } \n      //shape.rotation=shape.rotation+shape.personalRotation;\n      shape.isGrouped=0;\n      this.shapes.push(shape,)\n      this.center.x=shape.x;\n      this.center.y=shape.y;\n      grp.line.freeDistances.push(grp.line.occupiedDistances[i]);\n      grp.line.occupiedDistances.splice(i,1);\n      grp.shapes_g.splice(i,1);\n      grp.line.positionPoints.splice(i,1)\n      \n      this.updateOccupiedDistance(grp.id)\n      this.updateAllPosInGrp(grp.id)\n    \n    },\n    */\n    /*\n\n    //called when the button \"Detach Shape\" is clicked\n    DetachShapeButtonAction(){\n      let shape= ContextMenu.props.ConcernedShape;\n      if(shape.attrs.className==\"Line\"){\n        let shapes_g=shape.getParent().attrs.shapes_g;\n        while(shapes_g.length!=0){\n          this.DetachShape(shapes_g[0]);\n        }\n      }else{\n        let shape_data=this.shapes.find(i => i.id ===shape.attrs.id);\n        let isFunded=true;\n        if(shape_data==undefined){\n          isFunded=false;\n        }\n        let i=0;\n        while(!isFunded){\n          if(i<this.groups.length){\n            shape_data=this.groups[i].shapes_g.find(i => i.id === shape.attrs.id);\n          if(shape_data==undefined){\n            isFunded=false;\n          }else{\n            isFunded=true;\n          }\n          i++;\n          }else{        \n            isFunded=true;\n          }\n        }\n        this.DetachShape(shape_data)\n      }\n    },\n\n    //called when the button \"keep/liberate distribution\" is clicked.\n    KeepDistribution(){\n      let grp=this.groups.find(i => i.id === ContextMenu.props.ConcernedShape.attrs.id);\n      let line=grp.line;\n      if(line==undefined){\n        return;\n      }else{\n        if(line.keepDistribution){\n          line.keepDistribution=false;\n          for (let i=0;i<grp.shapes_g.length;i++){\n            grp.shapes_g[i].distance_to_line_center=line.occupiedDistances[i]\n          }\n          line.freeDistances=[];\n\n          line.stroke='blue'\n          grp.line.keepDistanceButtonText=\"Keep Distribution\";\n          //ContextMenu.props.ConcernedShape.attrs.keepDistanceButtonText=\"Keep Distribution\";\n        }else{\n          line.keepDistribution=true;\n          for (let i=0;i<grp.shapes_g.length;i++){\n            line.occupiedDistances[i]=grp.shapes_g[i].distance_to_line_center;\n          }\n          line.stroke='black'\n          grp.line.keepDistanceButtonText=\"Liberate Distribution\";\n          //ContextMenu.props.ConcernedShape.attrs.keepDistanceButtonText=\"Liberate Distribution\";\n          this.updateOccupiedDistance(line.id);\n          this.updateAllPosInGrp(line.id);\n        }\n      }\n    },\n    */\n    createNewShape(shape){\n      if(shape.attrs.className==\"Line\"){\n        \n        this.max_id_figures=this.max_id_figures+1;\n\n          let clone=shape.getParent().clone({\n            id: ''+this.max_id_figures,\n            name: \"group\"+this.max_id_figures,\n            shapes_g:[],\n          })\n          clone.attrs.line.id=''+this.max_id_figures;\n          clone.attrs.line.x=shape.getStage().getPointerPosition().x;\n          clone.attrs.line.y=shape.getStage().getPointerPosition().y;\n          clone.attrs.line.draggable=true;\n          this.groups.push(clone.attrs,)\n          \n        \n      }else{\n        \n        this.max_id_figures=this.max_id_figures+1\n        let clone=shape.clone({\n          id: ''+this.max_id_figures,\n          draggable: true,\n        })\n        clone.attrs.isGrouped=0;\n        this.shapes.push(clone.attrs,);\n      }\n      \n\n    },\n    \n  \n  eraserAction(e){\n    this.Remove(e.target);\n    \n  },\n  unshowSelectedShape(e){\n    if(e.target.attrs.className==\"Line\" && this.eraseMode==0){\n      e.target.opacity(0.5)\n    }\n    else if(e.target.attrs.className==\"Line\" && this.eraseMode==1){\n      if(e.target.attrs.keepDistribution==1){\n        e.target.stroke(\"rgb(48,48,48)\")\n      }else{\n        e.target.stroke(\"blue\")\n      }\n    }\n    else if(e.target.attrs.className==\"positionPoint\" && this.eraseMode==1){\n      if(e.target.getParent().attrs.line.keepDistribution!=1){\n        e.target.strokeWidth(0)\n      }\n    }\n    else if(this.eraseMode==1){\n      e.target.strokeWidth(0)\n    }\n  },\n  showSelectedShape(e){\n    if(e.target.attrs.className==\"Line\" && this.eraseMode==0){\n      e.target.opacity(1)\n    }\n    else if(e.target.attrs.className==\"Line\" && this.eraseMode==1){\n      e.target.stroke('rgb(200, 59, 218)')\n    }\n    else if(e.target.attrs.className==\"positionPoint\" && this.eraseMode==1){\n      let line=e.target.getParent().attrs.line;\n      if(line.freeDistances.indexOf(e.target.attrs.distance_to_line_center)!=-1){\n        if(line.keepDistribution!=1){\n          e.target.stroke('rgb(200, 59, 218)')\n          e.target.strokeWidth(3)\n        }\n      }\n    }\n    else if(this.eraseMode==1){\n      e.target.stroke('rgb(200, 59, 218)')\n      e.target.strokeWidth(3)\n    }\n    /*\n    let shape=e.target;\n    if(this.eraseMode==1){\n    let shape_data=this.shapes.find(i => i.id ===shape.attrs.id);\n    let isFunded=true;\n    if(shape_data==undefined){\n      isFunded=false;\n      let i=0;\n      while(!isFunded){\n        if(i<this.groups.length){\n          shape_data=this.groups[i].shapes_g.find(i => i.id === shape.attrs.id);\n        if(shape_data==undefined){\n          isFunded=false;\n          i++;\n        }else{\n          isFunded=true;\n        }\n        }else{        \n          isFunded=true;\n        }\n      }\n    }\n    if (shape_data!=undefined){\n      shape_data.opacity=0.3\n    }\n    */\n\n  },\n  editText(e){\n    //let valuey=document.getElementById(\"stage\").style.top+e.target.y()\n    //let valuex=document.getElementById(\"stage\").style.left+e.target.x()\n    let stageBox=e.target.getStage().attrs.container.getBoundingClientRect();\n    document.getElementById(\"input\").style.top=stageBox.y+e.target.getAbsolutePosition().y+'px';\n    document.getElementById(\"input\").style.left=stageBox.x+e.target.getAbsolutePosition().x-document.getElementById(\"input\").size*5+'px';\n    document.getElementById(\"input\").style.display=\"initial\"\n    this.editedText=e.target\n  },\n  updateText(e){\n    let shape=this.shapes.find(i => i.id ===this.editedText.attrs.id);\n    let isFunded=true;\n    if(shape==undefined){\n      isFunded=false;\n    }\n    let i=0;\n    while(!isFunded){\n      if(i<this.groups.length){\n        shape=this.groups[i].shapes_g.find(i => i.id === this.editedText.attrs.id);\n      if(shape==undefined){\n        isFunded=false;\n      }else{\n        isFunded=true;\n      }\n      i++;\n      }else{        \n        isFunded=true;\n      }\n    }\n    if(shape!=undefined){\n    let last_width;\n    let last_height;\n    let diff_width;\n    let diff_height;\n\n    last_width=this.editedText.width();\n    last_height=this.editedText.height();\n\n    shape.text=e.target.value;\n\n    this.editedText.text(e.target.value);\n    diff_width=this.editedText.width()-last_width;\n    diff_height=this.editedText.height()-last_height;\n\n    \n    shape.offsetX=shape.offsetX+diff_width/2\n    shape.offsetY=shape.offsetY+diff_height/2\n    shape.length_x=this.editedText.width()\n    shape.length_y=this.editedText.height()\n    document.getElementById(\"input\").style.display=\"none\"\n    }\n\n  },\n  updateNaration(grp){\n      let text=\"<strong>Substrate :</strong><br>\"\n      text=text+\"- <mark class='grey'> StickyLine </mark><br>\";\n      text=text+\"Relation: <i>alignement and distribution with</i>:\";\n      for(let j=0;j<grp.shapes_g.length;j++){\n        text=text+\"<br>\"+\"- \"+grp.shapes_g[j].className\n      }\n      this.$emit('explain',{origin:\"Substrate - Discoverability<br><mark class='grey'> The instrument should reveal the possible action that are available to the user. </mark>\",text:text});\n  }\n},\n};\n\n</script>\n<style>\n#playground{\n  cursor: default\n}\n#activeReuseSubstrate{\n  position:absolute;\n  display: none;\n  top: 0px;\n  left: 0px;\n  width: 60px;\n  background-color: white;\n  box-shadow: 0 0 5px grey;\n  border-radius: 3px;\n}\n#center_menu{\n  position: absolute;\n  display: none;\n  top: 0px;\n  left: 0px;\n  width: 60px;\n  background-color: white;\n  box-shadow: 0 0 5px grey;\n  border-radius: 3px;\n}\ninput{\n  position:absolute;\n  display: none;\n  top:0px;\n  left:0px; \n}\n</style> ","import { render } from \"./DiscoverabilitySubstrateDemo.vue?vue&type=template&id=f3285b92\"\nimport script from \"./DiscoverabilitySubstrateDemo.vue?vue&type=script&lang=js\"\nexport * from \"./DiscoverabilitySubstrateDemo.vue?vue&type=script&lang=js\"\n\nimport \"./DiscoverabilitySubstrateDemo.vue?vue&type=style&index=0&id=f3285b92&lang=css\"\n\nimport exportComponent from \"/Users/junhangyu/Desktop/PE code/github/teachingApp/node_modules/vue-loader/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render]])\n\nexport default __exports__","<template>\n\n<div @click=\"HideContextMenu\" id=\"DiscoverabilityDemo\"\n@mousedown=\"updateNaration(this.groups[0])\">\n<!--\n  <ToolBar :height=\"100\" :width=\"400\"\n  @need_new_shape=\"createNewShape\" @eraser_is_selected=\"switchEraseMode\"></ToolBar>\n  -->\n  <v-stage\n    ref=\"stage\"\n    id=\"stage\"\n    :config=\"stageSize\"\n    @dragmove=\"update\"\n    @mousedown=\"handleTransformation\"\n    @touchstart=\"handleTransformation\"\n    @fusion=\"makeGroup\"\n    @contextMenu=\"DisplayContextMenu\"\n  >\n    <v-layer ref=\"layer\">\n      <v-group ref=\"groups\" v-for=\"step in groups\" :key=\"step.id\" :config=\"step\">\n      \n      \n      \n        <v-rect\n        v-for=\"item in step.shapes_g.filter(i=>i.className=='Rect')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        \n       \n        @transformend=\"updateTransformedShape\"\n        @dragend= \"updatePosInGrp($event,step.id) \"\n        @dragmove=\"CheckIfNeedToDetach\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n      />\n      <v-circle\n        v-for=\"item in step.shapes_g.filter(i=>i.className=='Circle')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragend=\"updatePosInGrp($event,step.id)\"\n        @dragmove=\"CheckIfNeedToDetach\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n      />\n      \n      <v-image\n        v-for=\"item in step.shapes_g.filter(i=>i.className=='Image')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragend=\"updatePosInGrp($event,step.id)\"\n        @dragmove=\"CheckIfNeedToDetach\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n      />\n      <v-text\n        v-for=\"item in step.shapes_g.filter(i=>i.className=='Text')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragend=\"updatePosInGrp($event,step.id)\"\n        @dragmove=\"CheckIfNeedToDetach\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n\n        @dblclick=\"editText\"\n        />\n        <v-regular-polygon\n        v-for=\"item in step.shapes_g.filter(i=>i.className=='Triangle')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragend=\"updatePosInGrp($event,step.id)\"\n        @dragmove=\"CheckIfNeedToDetach\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n      />\n        <v-line \n        :key=\"step.line.id\"\n        :config=\"step.line\"\n        @transformend=\"updateTransformedShape\"\n        @dragmove=\"updateGrp($event,step.id)\"\n        @mouseout=\"unshowSelectedShape\"\n        @mouseenter=\"showSelectedShape\"\n        />\n    <v-circle\n        v-for=\"item in step.line.positionPoints\"\n        :key=\"item.id\"\n        :config=\"item\"\n        \n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n      />\n      </v-group>\n      <v-rect\n        v-for=\"item in shapes.filter(i=>i.className=='Rect')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragmove=\"updatePos\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n        \n      />\n      \n      <v-circle\n        v-for=\"item in shapes.filter(i=>i.className=='Circle')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragmove=\"updatePos\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n        \n      />\n      <!--\n      <v-image\n        v-for=\"item in shapes.filter(i=>i.className=='Image')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragmove=\"updatePos\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n        />\n     \n      <v-text\n        v-for=\"item in shapes.filter(i=>i.className=='Text')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragmove=\"updatePos\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n        \n        @dblclick=\"editText\"\n        /> \n      -->\n      <v-regular-polygon\n        v-for=\"item in shapes.filter(i=>i.className=='Triangle')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragmove=\"updatePos\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n        />\n      \n      \n      <v-transformer  v-for=\"item in transformers\" :key=\"item.id\" :config=\"item\"/>\n      <v-circle :key=\"center.id\" :config=\"center\"\n      @dragend=\"ChangeCenter\"\n      @click=\"DisplayCenterMenu\"/>\n      <div id=\"eraser\"\n     \n      >\n      <v-text :config=\"{text: 'eraser',y:5,x:10,fill:'rgb(200, 59, 218)'}\">\n      </v-text>\n      <v-image\n        :key=\"eraser.id\"\n        :config=\"eraser\"\n        @mousedown=\"switchEraseMode\"\n        @mouseenter=\"changeCursor('pointer')\"\n        @mouseout=\"changeCursor('default')\"\n      />\n      </div>\n      <!--\n      <v-transformer id=\"shapeTransformer\"/>\n      <v-transformer id=\"lineTransformer\" :config=\"{enabledAnchors: ['middle-left', 'middle-right'],}\" />\n      -->\n    </v-layer>\n    \n  </v-stage>\n  \n  <!--\n  <div id=\"activeReuseSubstrate\">\n  <ContextMenu :menu-of-stage=\"isStageOnlySelected\" :menu-of-line=isALineSelected \n  :menu-of-grouped-shape=isAGroupedShapeSelected :keep-distance-button-text=\"this.keepDistanceButtonText\" \n  :need-copy-button=\"false\" :need-switch-distribution-mode-button=\"false\"\n  @changecenter-button=\"ChangeCenterButtonAction\" @detachshape-button=\"DetachShapeButtonAction\" @keepdistance-button=\"KeepDistribution\"\n  @copy-button=\"Copy\" @copy-all-button=\"CopyAll\" @past-button=\"Past\" @remove-button=\"Remove\" @remove-all-button=\"RemoveAll\"></ContextMenu>\n  </div>\n  -->\n  <!--\n  <div id=\"center_menu\">\n  <CenterMenu :defaultAlignment=\"this.selectedShapeAlignment\" @center-button=\"ChangeAlignCenter\"></CenterMenu>\n  </div>\n  -->\n  \n  <input type=\"text\" id=\"input\" \n        size=\"10\" value=\"a text\"\n       @keyup.enter=\"updateText\"\n       >\n  </div>\n</template>\n\n<script>\n\n//import ContextMenu from \"./ContextMenu.vue\"\n//import CenterMenu from \"./CenterMenu.vue\"\n//import ToolBar from \"./ToolBar.vue\";\n\nconst dragFunc=function (pos) {\n  let width=this.getStage().width();\n  let height=this.getStage().height();\n  let strokeSize=10\n    if(pos.x>width-strokeSize && pos.y>height-strokeSize){\n      return{\n        x: width-strokeSize,\n        y: height-strokeSize,\n      }\n    } else if(pos.x>width-strokeSize && pos.y<strokeSize){\n      return{\n        x: width-strokeSize,\n        y: strokeSize,\n      }\n    } else if(pos.y>height-strokeSize && pos.x<strokeSize){\n      return{\n        x: strokeSize,\n        y: height-strokeSize,\n      }\n    } else if(pos.x<strokeSize && pos.y<strokeSize){\n      return{\n        x: strokeSize,\n        y: strokeSize,\n      }\n    } else if(pos.x<strokeSize){\n      return{\n        x: strokeSize,\n        y: pos.y,\n      }\n    }else if(pos.y<strokeSize){\n      return{\n        x: pos.x,\n        y: strokeSize,\n      }\n    }else if(pos.x>width-strokeSize){\n      return{\n        x: width-strokeSize,\n        y: pos.y,\n      }\n    }else if(pos.y>height-strokeSize){\n      return{\n        x: pos.x,\n        y: height-strokeSize,\n      }\n    } else{\n      return {\n        x: pos.x,\n        y: pos.y,\n      };\n    }\n};\n\n\nexport default {\n  props:{\n    width:{\n      type: Number,\n      default:window.innerWidth,\n    },\n    height:{\n      type: Number,\n      default:window.innerHeight,\n    }\n  },\n  components:{\n    //ContextMenu,\n    //CenterMenu,\n    //ToolBar,\n},\n  data() {\n    return {\n      stageSize: {\n        width: this.width,\n        height: this.height,\n      },\n      lengthToCapture:10,\n      lengthToDetach:15,\n      editedText:null,\n\n      eraseMode:0,\n\n      selectedShapeAlignment:'',\n      \n      needMenu: 'initial', //say if the context menu has to be \"active\" or not.\n      isALineSelected:false, \n      isAGroupedShapeSelected:false,\n      isStageOnlySelected: false,\n      //dragItemId: null, //id of the item which is dragging.\n      //text which will appear on the button corresponding to the management of the distribution\n      keepDistanceButtonText:\"Liberate Distribution\",\n      max_id_figures: 6, //max among id of shapes and line since the canvas exist (line excluded) \n      //max_id_lines: 2, //max among id of lines since the canvas exist (line excluded) \n      //groups of shapes (ie a line with shapes on it)\n      eraser:{\n            isActivated:0,\n            rotation: 0,\n            x: 17,\n            y: 20,           \n            scaleX:1,\n            scaleY:1,\n            offsetY:0,\n            offsetX:0,\n            opacity:1, \n            //width:72,\n            //height:30,\n            image: null,\n            isGrouped: 0,\n            className:\"eraser\",    \n            fontSize: 30,\n            id:'5',\n      },\n\n      groups:[{\n        //rotation: 20,\n        name: \"group\",\n        className: \"Group\",\n        id: '1',\n        x:0,\n        y:0,\n        offsetX:0,\n        offsetY:0,\n        rotation: 0,\n        draggable: false,\n        shapes_g:[ {\n          rotation: 0,\n          id:'8',\n          x: 150,\n          y: 220,\n          width: 70,\n          height: 70,\n          scaleX: 1,\n          scaleY: 1,\n          strokeWidth: 0,\n          stroke: 'black',\n          fill: 'green',\n          name: 'rect2',\n          draggable: true,\n          className:\"Rect\",\n          isGrouped: 0,\n          dragBoundFunc: dragFunc,\n          offsetX: 70/2,\n          offsetY: 70,\n          /*When it is on a line, a shape can be rotate by the user independently from the line.\n          To keep the independant rotation of the attached shape, we add the parameter \"personalRotation\".\n          So, when the shape is attached, is final rotation is the sum of this parameter with the rotation of the line.\n          */\n          personalRotation:0, \n          centerPosition:'Bottom',\n        },{\n          rotation: 0,\n          id:'7',\n          x: 250,\n          y: 220,\n          sides:3,\n          radius:45,\n          width: 90,\n          height: 90,\n          scaleX: 1,\n          scaleY: 1,\n          strokeWidth: 0,\n          stroke: 'black',\n          fill: 'purple',\n          name: 'triangle1',\n          draggable: true,\n          className:\"Triangle\",\n          isGrouped: 0,\n          dragBoundFunc: dragFunc,\n          offsetX: 0,\n          offsetY: 22.5,\n          personalRotation:0, \n          centerPosition:'Bottom',\n        },], //list of shapes that are on the line\n        //the line of the group:\n        aShapeHasBeenDetach:0,\n        line:{\n          x:150,\n          y:220,\n          points: [0, 0, 0, 0, 250, 0],\n          positionPoints:[{\n        x: 300,\n        y: 500,\n        scaleX:1,\n        scaleY:1,\n        offsetX: 0,\n        offsetY: 0,\n        radius: 3,\n        fill: 'yellow',\n        opacity:1,\n        draggable:false,\n        isGrouped: 0,\n        className:\"positionPoint\",\n        id:'positionPoint1',\n        distance_to_line_center:undefined,\n      },{\n        x: 300,\n        y: 500,\n        scaleX:1,\n        scaleY:1,\n        offsetX: 0,\n        offsetY: 0,\n        radius: 3,\n        fill: 'yellow',\n        opacity:1,\n        draggable:false,\n        isGrouped: 0,\n        className:\"positionPoint\",\n        id:'positionPoint2',\n        distance_to_line_center:undefined,\n      },{\n        x: 300,\n        y: 500,\n        scaleX:1,\n        scaleY:1,\n        offsetX: 0,\n        offsetY: 0,\n        radius: 3,\n        fill: 'yellow',\n        opacity:1,\n        draggable:false,\n        isGrouped: 0,\n        className:\"positionPoint\",\n        id:'positionPoint3',\n        distance_to_line_center:undefined,\n      },],\n          strokeWidth: 10,\n          rotation: 0,\n          tension:0,\n          closed: true,\n          draggable: true,\n          scaleX:1,\n          scaleY:1,\n          opacity:0.5,\n          offset:{\n            x:125,\n            y:0,\n          },\n          name: \"ligne\",\n          className: \"Line\",\n          stroke: 'blue',\n          id:'1',\n          //distShapesToCenter:[],\n          keepDistribution: false, //say of we keep the distribution on the line or not\n          freeDistances:[-95], // distance that can be taken by other shapes (if we keep distribution on the line).\n          occupiedDistances:[-15,100], //distance already \"taken\" by shapes on the line.       \n          //text which will appear on the button corresponding to the management of the distribution:\n          keepDistanceButtonText:\"Liberate Distribution\",\n          //function which determine how the line can be dragged:\n          defaultAlignment:\"Bottom\",\n          dragBoundFunc: dragFunc,\n        },\n      },\n      /*{\n        name: \"group2\",\n        className: \"Group\",\n        id: '7',\n        x:0,\n        y:0,\n        offsetX:0,\n        offsetY:0,\n        rotation: 0,\n        draggable: false,\n        shapes_g:[],\n        line:{\n        x:500,\n        y:300,\n        points: [0, 0, 0, 0, 300, 0],\n        positionPoints:[],\n        strokeWidth: 10,\n        rotation: 0,\n        tension:0,\n        closed: true,\n        draggable: true,\n        scaleX:1,\n        scaleY:1,\n        opacity:0.5,\n        offset:{\n          x:150,\n          y:0,\n        },\n        //draggable:true,\n        name: \"ligne\",\n        className: \"Line\",\n        stroke: 'black',\n        id:'7',\n        distShapesToCenter:[],\n        keepDistribution: true,\n        freeDistances:[],\n        occupiedDistances:[],\n        keepDistanceButtonText:\"Liberate Distribution\",\n        defaultAlignment:\"Middle\",\n        dragBoundFunc: dragFunc,\n      },\n      \n      }*/\n      ],\n      transformers:[\n        { \n          id: 'lineTransformer',\n          enabledAnchors: [],\n          rotateEnabled: false,\n          borderEnabled:false,\n          flipEnabled: false, // in order to not have a rotation of the transformer which lead to problem related to shapes position on a line\n          nodes: [],\n\n        },\n        {\n          id: 'shapeTransformer',\n          nodes: [],\n        }\n      ],\n      shapes: [{\n        rotation:0,\n        x: 130,\n        y: 80,\n        scaleX:1,\n        scaleY:1,\n        offsetX: 0,\n        offsetY: 40,\n        radius: 40,\n        fill: 'orange',\n        strokeWidth: 0,\n        stroke: 'black',\n        draggable:true,\n        isGrouped: 0,\n        className:\"Circle\",\n        /*When it is on a line, a shape can be rotate by the user independently from the line.\n          To keep the independant rotation of the attached shape, we add the parameter \"personalRotation\".\n          So, when the shape is attached, is final rotation is the sum of this parameter with the rotation of the line.\n          */\n        personalRotation:0, \n        id:'6',\n        dragBoundFunc: dragFunc,\n        centerPosition:'Bottom',\n      },],\n      center:{\n        x: 300,\n        y: 500,\n        scaleX:1,\n        scaleY:1,\n        offsetX: 0,\n        offsetY: 0,\n        radius: 4,\n        fill: 'black',\n        opacity:1,\n        draggable:true,\n        isGrouped: 0,\n        className:\"Circle\",\n        id:'center',\n        dragBoundFunc:dragFunc,\n      },\n      positionPoint:{\n        x: 300,\n        y: 500,\n        scaleX:1,\n        scaleY:1,\n        offsetX: 0,\n        offsetY: 0,\n        radius: 3,\n        fill: 'yellow',\n        opacity:1,\n        draggable:false,\n        isGrouped: 0,\n        className:\"positionPoint\",\n        id:'positionPoint',\n        distance_to_line_center:undefined,\n      },\n      selectedShapeId: '',\n    };\n  },\n  mounted(){\n    let texts=this.$refs.stage.getStage().getChildren()[0].getChildren().filter((r)=>r.attrs.className=='Text');\n    \n    \n    for(let i=0;i<texts.length;i++){\n      texts[i].attrs.length_x=texts[i].width();\n      texts[i].attrs.length_y=texts[i].height();\n      texts[i].offsetX(texts[i].attrs.length_x/2);\n    }\n    let grp=this.groups[0];\n    let line=grp.line;\n    let shapes_g=grp.shapes_g;\n    for(let i=0;i<shapes_g.length;i++){\n      this.updateDragFunc(shapes_g[i],line);\n      \n      this.updateAllPosInGrp(grp.id);\n    }\n  },\n  created(){\n    //nb of shapes on the canvas (line excluded), we consider that there is no shape on line:\n    this.max_id_figures=this.shapes.length +this.groups.length; \n    //this.max_id_lines=this.groups.length;\n\n    const image = new window.Image();\n    image.src = require(\"@/assets/ugly_eraser.png\");\n    // set image only when it is loaded\n    //image.height=150;\n    //image.width=150;\n    image.onload = () => {\n      this.eraser.image= image;\n      //this.eraser.offsetX=image.width/2;\n      this.eraser.offsetY=0; \n    };\n  \n  },\n  methods: {\n    changeCursor(cursor){\n      if(this.eraseMode!=1){\n      document.getElementById('DiscoverabilityDemo').style.cursor=cursor;\n      }\n    },\n    switchEraseMode(){\n      if(this.eraseMode==0){\n        this.eraseMode=1;\n        this.eraser.opacity=0.4;\n        document.getElementById(\"DiscoverabilityDemo\").style.cursor='url('+require('@/assets/ugly_eraser.png')+'),default';\n        \n      this.eraseNodefromTransformer(\"shapeTransformer\");\n      this.eraseNodefromTransformer(\"lineTransformer\");\n      } else{\n        this.eraseMode=0;\n        this.eraser.opacity=1;\n        document.getElementById(\"DiscoverabilityDemo\").style.cursor=\"default\";\n      }\n    },\n    /*\n    Check if all shapes that are supposed to be on a line still in this line.\n    id_grp is the id of the group which contains the line.\n    */\n    checkIfShapesOnLine(id_grp){\n      const grp= this.groups.find((r) => r.id===id_grp);\n      const line=grp.line;\n      const groupedShapes = grp.shapes_g;\n      //const lengthToDetach=10;\n      \n      /*\n      To determine if a shape is on a line, we see if the point is not on the corresponding\n      straight line y=a*x+b regarding certains intervals for x and y.Those intervals depends of the rotation of\n      the line. \n      */\n     /*\n      let coord_y1=line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x1=line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let coord_y2= line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x2=line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let a=(coord_y1-coord_y2)/(coord_x2-coord_x1);\n      let b=line.y-a*line.x;\n      let is_on_straight_line=false;\n      */\n      \n      let i=0;\n      while(i<groupedShapes.length){\n        /*\n        if(Math.abs(coord_x1-coord_x2)>1){\n        is_on_straight_line=(Math.abs(a*groupedShapes[i].x+b-groupedShapes[i].y)<this.lengthToDetach);\n      }else{\n        is_on_straight_line=(Math.abs(groupedShapes[i].x-line.x)<this.lengthToDetach);\n      }\n        if (\n          !(is_on_straight_line)\n        ||((line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].y\n        ||line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].y)\n        && ((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n        ||((line.x+line.points[4]*line.scaleX*(1/2)*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].x\n        ||line.x-line.points[4]*line.scaleX*(1/2)*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].x)\n        &&((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n        ||((line.y+line.points[4]*line.scaleX*(1/2)*Math.sin(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].y\n        ||line.y-line.points[4]*line.scaleX*(1/2)*Math.sin(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].y)\n        &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>=-Math.PI)))\n\n        ||((line.x+line.points[4]*line.scaleX*(1/2)*Math.cos(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].x\n        ||line.x-line.points[4]*line.scaleX*(1/2)*Math.cos(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].x)\n        &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>=-Math.PI)))\n\n        ||((line.y+line.points[4]*line.scaleX*(1/2)*Math.sin(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].y\n        ||line.y-line.points[4]*line.scaleX*(1/2)*Math.sin(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].y)\n        &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n        ||((line.x+line.points[4]*line.scaleX*(1/2)*Math.cos(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].x\n        ||line.x-line.points[4]*line.scaleX*(1/2)*Math.cos(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].x)\n        &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n        ||((line.y+line.points[4]*line.scaleX*(1/2)*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].y\n        ||line.y-line.points[4]*line.scaleX*(1/2)*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].y)\n        &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>0)))\n\n        ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<groupedShapes[i].x\n        ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>groupedShapes[i].x)\n        &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>0)))\n        )\n        */\n       if(!this.isCoordinateOnLine(groupedShapes[i].x,groupedShapes[i].y,line.id)){\n          console.log(\"a shape is not on a line\");\n          groupedShapes[i].dragBoundFunc= dragFunc;\n          groupedShapes[i].isGrouped=0;\n          //line.positionPoints.splice(i,1)\n          \n          this.shapes.push(groupedShapes[i],)\n          line.freeDistances.push(line.occupiedDistances[i]);\n          line.occupiedDistances.splice(i,1);\n          groupedShapes.splice(i,1);\n          \n          this.updateNaration(grp)\n        }else{\n          i=i+1;\n        }\n      }\n    },\n\n    //say of {x,y} is a point from the line\n    isCoordinateOnLine(x,y,id_grp){\n      const grp=this.groups.find((r) => r.id===id_grp);\n      const line=grp.line;\n      let is_not_on_straight_line=true;\n      let coord_y1=line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x1=line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let coord_y2= line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x2=line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let a=(coord_y1-coord_y2)/(coord_x2-coord_x1);\n      let b=line.y-a*line.x;\n      if(Math.abs(coord_x1-coord_x2)>1){\n        is_not_on_straight_line=(Math.abs(a*x+b-y)>1);\n      }else{\n        is_not_on_straight_line=(Math.abs(x-line.x)>1)\n      }\n      if(\n        (is_not_on_straight_line)\n\n      ||((line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<y\n      ||line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>y)\n      && ((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<x\n        ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>x)\n      &&((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<y\n        ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>y)\n      &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>-Math.PI)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>x)\n      &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>-Math.PI)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>y)\n      &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>x)\n      &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>y)\n      &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>=0)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>x)\n      &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>=0)))\n\n      ||(!is_not_on_straight_line && Math.sqrt((line.x-x)**2+(line.y-y)**2)>line.points[4]*line.scaleX/2)\n\n      )\n      {\n        return false; \n      } else{\n        return true;\n      }\n    },\n\n    //update a group with the id id_grp\n    updateGrp(e,id_grp){\n      const grep=this.groups.find((r)=>r.id===id_grp);\n      const line= grep.line;\n      grep.offsetX=line.offsetX;\n      grep.offsetY=line.offsetY;\n      \n      line.x=e.target.x();\n      line.y=e.target.y();\n      this.center.x=line.x;\n      this.center.y=line.y;\n      /*\n      if(line.keepDistribution){\n        this.updateOccupiedDistance(line.id);\n      }\n      */\n      this.updateAllPosInGrp(line.id); \n      this.checkIfShapesOnLine(line.id);\n    },\n\n\n    //update the position of all shapes that are on the line of the group with the id id_grp.\n    updateAllPosInGrp(id_grp){\n      const grp= this.groups.find((r) => r.id===id_grp);     \n      const line= grp.line;\n      const shapes_g = grp.shapes_g;\n      for (let i=0;i<shapes_g.length;i++){\n          if(line.keepDistribution){\n            shapes_g[i].x=line.x+line.occupiedDistances[i]*Math.cos(line.rotation*(Math.PI/180));\n            shapes_g[i].y=line.y+line.occupiedDistances[i]*Math.sin(line.rotation*(Math.PI/180));\n            shapes_g[i].distance_to_line_center=line.occupiedDistances[i];\n            shapes_g[i].rotation=shapes_g[i].personalRotation+line.rotation;\n            \n          } else{\n            shapes_g[i].x=line.x+line.occupiedDistances[i]*Math.cos(line.rotation*(Math.PI/180));\n            shapes_g[i].y=line.y+line.occupiedDistances[i]*Math.sin(line.rotation*(Math.PI/180));\n            shapes_g[i].distance_to_line_center=line.occupiedDistances[i];\n            shapes_g[i].rotation=shapes_g[i].personalRotation+line.rotation;\n          }\n          line.positionPoints[i].x=shapes_g[i].x;\n          line.positionPoints[i].y=shapes_g[i].y;\n          line.positionPoints[i].distance_to_line_center=shapes_g[i].distance_to_line_center;\n      }\n      let i=shapes_g.length;\n      while(i<line.positionPoints.length){\n        if(line.keepDistribution){\n          line.positionPoints.splice(i,1);\n        }else{\n        line.positionPoints[i].x=line.x+line.freeDistances[i-shapes_g.length]*Math.cos(line.rotation*(Math.PI/180));\n        line.positionPoints[i].y=line.y+line.freeDistances[i-shapes_g.length]*Math.sin(line.rotation*(Math.PI/180));\n        line.positionPoints[i].distance_to_line_center=line.freeDistances[i-shapes_g.length];\n        i++;\n        }\n        \n      }\n    \n    },\n    isOutsideTheLine(shape,line){\n      let coord_y1=line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x1=line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let coord_y2= line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x2=line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let a=(coord_y1-coord_y2)/(coord_x2-coord_x1);\n      let b=line.y-a*line.x;\n      let is_on_straight_line=false;\n      if(Math.abs(coord_x1-coord_x2)>=1){\n        is_on_straight_line=(Math.abs(a*shape.x+b-shape.y)<1);\n      }else{\n        is_on_straight_line=(Math.abs(shape.x-line.x)<1);\n      }\n      if(\n        !(is_on_straight_line)\n      ||((line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n        ||line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      && ((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>-Math.PI)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>-Math.PI)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>=0)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>=0)))\n      ){\n        return true;\n      }else{ return false}\n    },\n    \n    //update the canvas\n    update(){\n      const shapes = this.shapes\n      \n      //const lengthToCapture=10; //bigger is the number, bigger is the intervals of x and y where a shape can be added to a line.\n      let is_on_straight_line=false;\n      for (let i=0;i<shapes.length;i++){\n        let x=shapes[i].x;\n        let y=shapes[i].y;\n      for (let j=0;j<this.groups.length;j++){\n      \n        let line=this.groups[j].line;\n\n        \n        let coord_y1=line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n        let coord_x1=line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n        let coord_y2= line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n        let coord_x2=line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n        let a=(coord_y1-coord_y2)/(coord_x2-coord_x1);\n        let b=line.y-a*line.x;\n        if(Math.abs(coord_x1-coord_x2)>1){\n          is_on_straight_line=(Math.abs(a*x+b-y)<=this.lengthToCapture);\n        }else{\n          is_on_straight_line=(Math.abs(x-line.x)<=this.lengthToCapture);\n          //is_on_straight_line=true;\n        }\n        if(\n        (\n          is_on_straight_line\n      &&(line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToCapture>=y\n      && line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToCapture<=y)\n      &&(line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToCapture>=x\n      && line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToCapture<=x)\n      &&(line.rotation*(Math.PI/180)<=0 \n      && line.rotation*(Math.PI/180)>-Math.PI/2))\n\n      ||(\n        is_on_straight_line\n      &&(line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))+this.lengthToCapture>=y\n      && line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))-this.lengthToCapture<=y) \n      &&(line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))+this.lengthToCapture>=x\n      && line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))-this.lengthToCapture<=x)\n      &&(line.rotation*(Math.PI/180)<=-Math.PI/2 \n      && line.rotation*(Math.PI/180)>=-Math.PI))\n\n      ||(\n        is_on_straight_line\n      &&(line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))+this.lengthToCapture>=y\n      &&line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))-this.lengthToCapture<=y)\n      &&(line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))+this.lengthToCapture>=x\n      && line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))-this.lengthToCapture<=x)\n      &&(line.rotation*(Math.PI/180)<=Math.PI \n      && line.rotation*(Math.PI/180)>Math.PI/2))\n\n      ||(\n        is_on_straight_line\n      &&(line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToCapture>=y\n      && line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToCapture<=y)\n      &&(line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToCapture>=x\n      && line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToCapture<=x)\n      &&(line.rotation*(Math.PI/180)<=Math.PI/2\n      && line.rotation*(Math.PI/180)>=0))\n      )\n       {\n          shapes[i].isGrouped=1;\n          this.makeGroup(line.id);\n        }\n      }\n      }\n    },\n\n    CheckIfNeedToDetach(e){\n      let grp=this.groups.find((r)=>r.id===e.target.getParent().attrs.id);\n      let shape= grp.shapes_g.find((r)=>r.id==e.target.id());\n      let dist=Math.sqrt((e.target.getStage().getPointerPosition().y-e.target.y())**2+(e.target.getStage().getPointerPosition().x-e.target.x())**2);\n      if(e.target.className==\"Rect\"){\n        dist-=e.target.attrs.height*e.target.attrs.scaleY;\n      } else if(e.target.className==\"Circle\"){\n        dist-=(2*e.target.attrs.radius)*e.target.attrs.scaleY;\n      } else if(e.target.className==\"Text\"){\n        dist-=e.target.attrs.length_y*e.target.attrs.scaleY;\n      } else if(e.target.className==\"Image\"){\n        dist-=e.target.height()*e.target.scaleY();\n      } else if(e.target.attrs.className==\"Triangle\"){\n        dist-=e.target.height()*e.target.scaleY();\n      } \n      \n      if (dist>50){\n        //let shape= this.groups.find((r)=>r.id===e.target.getParent().attrs.id).shapes_g.find((r)=>r.id==e.target.id());\n        //this.groups.find((r)=>r.id===e.target.getParent().attrs.id).shapes_g.find((r)=>r.id==e.target.id()).needToBeDetach=1;\n        /*\n        shape.dragBoundFunc= function (pos) {\n              return {\n                x: pos.x,\n                y: pos.y,\n              };\n        }\n        */\n        //shape.x=e.target.getStage().getPointerPosition().x;\n        //shape.y=e.target.getStage().getPointerPosition().y;\n        //if (Math.abs(e.target.getStage().getPointerPosition().y-e.target.y())>220){\n          \n        //shape.x=e.target.getStage().getPointerPosition().x;\n        //shape.y=e.target.getStage().getPointerPosition().y;\n        this.groups.find((r)=>r.id===e.target.getParent().attrs.id).aShapeHasBeenDetach=1;\n        this.DetachShape(shape,e.target.getStage().getPointerPosition().x,e.target.getStage().getPointerPosition().y);\n        \n        \n        \n        \n      }\n    },\n\n    //Give the sign of the distance of shape from the center of a line.\n    GiveSignOfDistance(shape,line){\n      let result;\n      let angle=line.rotation*(Math.PI/180);\n      let distX=shape.x-line.x;\n      let distY=shape.y-line.y;\n      /*\n      \n      if(angle<=-Math.PI/4 || angle>=-Math.PI/2){\n        result=-Math.sign(distY);\n      }\n      else if(angle<=-Math.PI/2 || angle>=-3*Math.PI/4){\n        result=Math.sign(distY);\n      }\n      else if(angle<=-3*Math.PI/4 || angle>=-Math.PI){\n        result=-Math.sign(distX);\n      }else if(angle>=3*Math.PI/4 || angle<=Math.PI){\n        result=Math.sign(distX);\n      }else if(angle>=Math.PI/2 || angle<3*Math.PI/4){\n        result=-Math.sign(distY);\n      } else if(angle<=Math.PI/2 || angle>Math.PI/4){\n        result=-Math.sign(distY);\n      } else if(angle<=Math.PI/4 || angle>=0){\n        result=Math.sign(distX);\n      }\n      */\n      \n      \n      if(Math.abs(distX)<=this.lengthToCapture && line.rotation==-90){\n        \n        result=-Math.sign(distY);\n      } else if (Math.abs(distX)<=this.lengthToCapture && line.rotation==90){\n        result=Math.sign(distY);\n      }\n      else{\n        result=Math.sign(distX);\n      }\n      if(angle<-Math.PI/2 || angle>Math.PI/2){\n        result=-result;\n      }\n      \n      return result;\n    },\n\n    //Different from the previous function bcs the straight line of the center is perdendicular to the line\n    GiveSignOfDistanceBtwCenterAndShape(center,shape){\n      let result;\n      let angle=shape.rotation*(Math.PI/180);\n      let distX=center.x-shape.x;\n      let distY=center.y-shape.y;\n      /*\n      \n      if(angle<=-Math.PI/4 || angle>=-Math.PI/2){\n        result=-Math.sign(distY);\n      }\n      else if(angle<=-Math.PI/2 || angle>=-3*Math.PI/4){\n        result=Math.sign(distY);\n      }\n      else if(angle<=-3*Math.PI/4 || angle>=-Math.PI){\n        result=-Math.sign(distX);\n      }else if(angle>=3*Math.PI/4 || angle<=Math.PI){\n        result=Math.sign(distX);\n      }else if(angle>=Math.PI/2 || angle<3*Math.PI/4){\n        result=-Math.sign(distY);\n      } else if(angle<=Math.PI/2 || angle>Math.PI/4){\n        result=-Math.sign(distY);\n      } else if(angle<=Math.PI/4 || angle>=0){\n        result=Math.sign(distX);\n      }\n      */\n      \n      \n      if(Math.abs(distY)<=this.lengthToCapture && shape.rotation==-90){\n        \n        result=Math.sign(distX);\n      } else if (Math.abs(distY)<=this.lengthToCapture && shape.rotation==90){\n        result=-Math.sign(distX);\n      }\n      else{\n        result=Math.sign(distY);\n      }\n      if(angle<-Math.PI/2 || angle>Math.PI/2){\n        result=-result;\n      }\n      \n      return result;\n    },\n\n    /*add shapes with isGrouped==1 to the group with the id id_grp.\n    */\n     makeGroup(id_grp){\n      this.eraseNodefromTransformer(\"shapeTransformer\");\n      this.eraseNodefromTransformer(\"lineTransformer\");\n      const grp=this.groups.find((r)=> r.id===id_grp);\n      const line=grp.line;\n      const shapes = this.shapes;\n      line.freeDistances.sort(this.isSmaller); //we will give the shortest available distance to the added shape\n      shapes.sort(this.isBeforeRegardingX);\n      for (let i=0;i<shapes.length;i++){\n        if(shapes[i].isGrouped==1){\n          const positionPoint=Object.assign({},this.positionPoint);\n          let distX=shapes[i].x-line.x;\n          let distY=shapes[i].y-line.y; \n          shapes[i].personalRotation=0;\n          //let pot_dist=this.GiveSignOfDistance(shapes[i],line)*Math.sqrt((distX)**2+(distY)**2);\n          /*\n          if(line.keepDistribution && line.freeDistances.length>0){\n          let distances=line.freeDistances+line.occupiedDistances;\n          console.log(distances);\n           let freeDistance=this.isNearest(line.freeDistances,pot_dist);\n           //shapes[i].distance_to_line_center=freeDistance.res; \n           shapes[i].distance_to_line_center=this.GiveSignOfDistance(shapes[i],line)*Math.sqrt((distX)**2+(distY)**2);\n            \n           line.occupiedDistances.push(shapes[i].distance_to_line_center,);\n           line.freeDistances.splice(freeDistance.indice,1);\n\n          } else{\n            */\n            //let distX=shapes[i].x-line.x;\n            //let distY=shapes[i].y-line.y;\n            shapes[i].distance_to_line_center=this.GiveSignOfDistance(shapes[i],line)*Math.sqrt((distX)**2+(distY)**2);\n            /*If the distance is a little bit to far from the center \n            we adjust it so that the shape can be at one of the border of the stickyline*/\n            if(Math.abs(shapes[i].distance_to_line_center)>=line.points[4]*line.scaleX/2){\n              shapes[i].distance_to_line_center=Math.sign(shapes[i].distance_to_line_center)*line.points[4]*line.scaleX/2\n            }\n            this.ChangeCenterRegardingCommand(shapes[i].id,grp.line.defaultAlignment);\n            if(!line.keepDistribution && line.freeDistances.length>0){\n              let indice=this.isNearest(line,shapes[i]);\n              console.log(grp.line.freeDistances);\n              console.log(indice);\n              //console.log(indice);\n              //shapes[i].distance_to_line_center=line.freeDistances[indice];\n              //line.freeDistances.splice(indice,1);\n              //shapes[i].isGrouped=0;\n              this.updateDragFunc(shapes[i],line);\n              grp.shapes_g.push(shapes[i],);\n              grp.line.occupiedDistances.push(grp.line.freeDistances[indice]);\n              grp.line.freeDistances.splice(indice,1);\n              //this.updateOccupiedDistance(grp.line.id);\n\n            }else{\n              //shapes[i].isGrouped=0;\n              this.updateDragFunc(shapes[i],line);\n              grp.shapes_g.push(shapes[i],);\n              console.log(\"no 'free distance' anymore\")\n              grp.line.occupiedDistances.push(shapes[i].distance_to_line_center,);\n              positionPoint.id=\"positionPoint\"+grp.id+grp.line.positionPoints.length;\n              grp.line.positionPoints.push(positionPoint,);\n              //shapes[i].distance_to_line_center=this.GiveSignOfDistance(shapes[i],line)*Math.sqrt((distX)**2+(distY)**2);\n            }\n            //line.occupiedDistances.push(shapes[i].distance_to_line_center,);\n          //}\n          console.log(\"A new shape has been added with a distance\"+shapes[i].distance_to_line_center);\n          //shapes[i].isGrouped=0;\n          //this.updateDragFunc(shapes[i],line);\n          //grp.shapes_g.push(shapes[i],);\n          this.updateOccupiedDistance(line.id);\n          \n          this.updateAllPosInGrp(id_grp);\n          shapes.splice(i,1);\n        }\n      }\n      \n      this.updateNaration(grp)\n      this.center.x=line.x;\n      this.center.y=line.y;\n    },\n\n    updateOccupiedDistance(id_grp){\n      \n      const grp=this.groups.find((r)=> r.id===id_grp);\n      //this.updateAllPosInGrp(id_grp);\n      this.sortByDistToLineCenter(grp);\n      \n      //let l=grp.line.points[4]/2;\n      if(grp.line.keepDistribution){\n      let L=grp.line.points[4];\n      let nb_shapes=grp.shapes_g.length;\n      let d=(L/(nb_shapes-1))*grp.line.scaleX;\n      if(nb_shapes%2==0){\n        \n      for (let i =1;i<=nb_shapes/2-1;i++){\n        //grp.line.occupiedDistances[i-1]=-(l/i);\n        grp.line.occupiedDistances[i-1]=-((nb_shapes/2-1)-i+1)*d-d/2\n      }\n      for (let i =1;i<=nb_shapes/2-1;i++){\n        grp.line.occupiedDistances[nb_shapes/2+i]=i*d+d/2;\n      }\n      grp.line.occupiedDistances[nb_shapes/2-1]=-d/2\n      grp.line.occupiedDistances[nb_shapes/2]=d/2\n      } else{\n        for (let i =1;i<=(nb_shapes-1)/2;i++){\n          grp.line.occupiedDistances[i-1]=-d*(((nb_shapes-1)/2)-i+1);\n        }\n        for (let i =1;i<=(nb_shapes-1)/2;i++){\n          grp.line.occupiedDistances[((nb_shapes-1)/2)+i]=d*i;\n        }\n        grp.line.occupiedDistances[(nb_shapes-1)/2]=0;\n      }\n      \n      for (let i=0;i<grp.shapes_g.length;i++){\n        grp.shapes_g[i].distance_to_line_center=grp.line.occupiedDistances[i];\n      }\n      }\n      else{\n        grp.line.occupiedDistances.sort(this.isSmaller);\n      }\n      \n      \n      \n    \n\n    },\n\n   isSmaller(a,b){\n    if(a<b){\n      return -1;\n    }else{\n      return 1\n    }\n   },\n\n   isBeforeRegardingX(a,b){\n    if(a.x<b.x){\n      return -1;\n    }else{\n      return 1;\n    }\n   },\n\n    \n   updateOccDist(grp,shape){\n    let res=this.isNearest(grp.line,shape);\n    //let grp=this.groups.find((r)=>r.id===line.id);\n    if(res.isFree){\n      shape.distance_to_line_center=grp.line.freeDistances[res.indice];\n      grp.line.freeDistances.splice(res.indice,1);\n      this.sortByDistToLineCenter(grp);\n      for(let l=0;l<grp.shapes_g.length;l++){\n        if(grp.line.occupiedDistances.length==l){\n          grp.line.occupiedDistances.push(grp.shapes_g[l].distance_to_line_center,);\n        }else{\n          grp.line.occupiedDistances[l]=grp.shapes_g[l].distance_to_line_center;\n        }\n      } \n    } else{\n      grp.shapes_g.find((r)=>r.id==shape.id).distance_to_line_center=grp.line.occupiedDistances[res.indice];\n      grp.line.occupiedDistances.splice(res.indice,1);\n      //line.occupiedDistances.push(shape.distance_to_line_center,);\n      //line.freeDistances.splice(res.indice,1);   \n      this.updateOccDist(grp,grp.shapes_g[res.indice]);\n    }\n   },\n   isNearest(line,shape){\n    let ecart;\n    let invx=line.x+line.freeDistances[0]*Math.cos(line.rotation*(Math.PI/180));\n    let invy=line.y+line.freeDistances[0]*Math.sin(line.rotation*(Math.PI/180));\n    let ecart_min=Math.sqrt((invx-shape.x)**2+(invy-shape.y)**2);\n    let indice=0;\n    for(let i=1;i<line.freeDistances.length;i++){\n      invx=line.x+line.freeDistances[i]*Math.cos(line.rotation*(Math.PI/180));\n      invy=line.y+line.freeDistances[i]*Math.sin(line.rotation*(Math.PI/180));\n      ecart=Math.sqrt((invx-shape.x)**2+(invy-shape.y)**2);\n      if(ecart<ecart_min){\n        //res=line.freeDistances[i];\n        ecart_min=ecart;\n        indice=i;\n      }\n    }\n    return indice;\n    /*\n    let allDist=line.freeDistances.concat(line.occupiedDistances);\n    console.log(allDist);\n    \n    let ecart;\n    let invx=line.x+allDist[0]*Math.cos(line.rotation*(Math.PI/180));\n    let invy=line.y+allDist[0]*Math.sin(line.rotation*(Math.PI/180));\n    let ecart_min=Math.sqrt((invx-shape.x)**2+(invy-shape.y)**2)\n    let indice=0;\n    console.log(ecart_min);\n    for(let i=1;i<allDist.length;i++){\n      invx=line.x+allDist[i]*Math.cos(line.rotation*(Math.PI/180));\n      invy=line.y+allDist[i]*Math.sin(line.rotation*(Math.PI/180));\n      ecart=Math.sqrt((invx-shape.x)**2+(invy-shape.y)**2);\n      if(this.groups.find((r)=>r.id==line.id).shapes_g.indexOf(shape)!=-1){\n        console.log(ecart_min);\n        console.log(ecart);\n        if(ecart<ecart_min && ecart!=0){\n          //res=allDist[i];\n          ecart_min=ecart;\n          indice=i;\n        }\n      }else if(ecart<ecart_min){\n        //res=allDist[i];\n        ecart_min=ecart;\n        indice=i;\n      }\n    }\n    console.log(indice);\n    if(indice>=line.freeDistances.length){\n      return{\n        isFree: false,\n        indice: indice-line.freeDistances.length,\n      }\n    }else{\n      return{\n        isFree: true,\n        indice: indice,\n      }\n    }\n    */\n\n    /*\n    line.freeDistances.sort(this.isSmaller);\n    let ecart;\n    let invx=line.x+line.freeDistances[0]*Math.cos(line.rotation*(Math.PI/180));\n    let invy=line.y+line.freeDistances[0]*Math.sin(line.rotation*(Math.PI/180));\n    let ecart_min=Math.sqrt((invx-shape.x)**2+(invy-shape.y)**2)\n    let indice=0;\n    for(let i=0;i<line.freeDistances.length;i++){\n      invx=line.x+line.freeDistances[i]*Math.cos(line.rotation*(Math.PI/180));\n      invy=line.y+line.freeDistances[i]*Math.sin(line.rotation*(Math.PI/180));\n      ecart=Math.sqrt((invx-shape.x)**2+(invy-shape.y)**2)\n      if(ecart<ecart_min){\n        //res=freeDistances[i];\n        ecart_min=ecart;\n        indice=i;\n      }\n    }\n    return indice;\n    */\n    /*\n    if(shapeDistance>=0){\n      for(let i=0;i<freeDistances.length;i++){\n        if(freeDistances[i]>shapeDistance){\n          return i;\n        }\n      }\n      return freeDistances.length-1;\n    }else{\n      let ecart_min=Math.abs(Math.abs(freeDistances[0])-Math.abs(shapeDistance))\n      let indice=0;\n      for(let i=0;i<freeDistances.length;i++){\n        let ecart=Math.abs(Math.abs(freeDistances[i])-Math.abs(shapeDistance));\n        if(ecart<ecart_min){\n          //res=freeDistances[i];\n          ecart_min=ecart;\n          indice=i;\n        }\n      }\n      return indice;\n    }\n    */\n    /*\n    //let res=freeDistances[0];\n    let ecart_min=Math.abs(Math.abs(freeDistances[0])-Math.abs(shapeDistance))\n    let indice=0;\n    for(let i=0;i<freeDistances.length;i++){\n      let ecart=Math.abs(Math.abs(freeDistances[i])-Math.abs(shapeDistance));\n      if(ecart<ecart_min){\n        //res=freeDistances[i];\n        ecart_min=ecart;\n        indice=i;\n      }\n    }\n    return indice;\n    */\n   },\n   \n\n   sortByDistToLineCenter(grp){\n    //this.updateAllPosInGrp(grp.id)\n    //let last_distX=new Array(grp.shapes_g.length);\n    \n    //let distX;\n    //let distY;\n    //let sign;\n    //let dist=new Array(grp.shapes_g.length);\n    //let angle;\n    if(grp.line.keepDistribution){\n      for (let l=0;l<grp.shapes_g.length;l++){\n          let distX=grp.shapes_g[l].x-grp.line.x;\n          let distY=grp.shapes_g[l].y-grp.line.y;\n          //dist[l]=this.GiveSignOfDistance(grp.shapes_g[l],grp.line)*Math.sqrt((distX)**2+(distY)**2);\n          grp.shapes_g[l].distance_to_line_center=this.GiveSignOfDistance(grp.shapes_g[l],grp.line)*Math.sqrt((distX)**2+(distY)**2);\n          //last_distX[l]=distX;\n        }\n    }\n    for(let i=1;i<grp.shapes_g.length;i++){\n      \n     \n      let shape=grp.shapes_g[i];\n      //let distance=dist[i];\n      let j=i\n      while(j>0 && grp.shapes_g[j-1].distance_to_line_center>shape.distance_to_line_center){\n        grp.shapes_g[j]=grp.shapes_g[j-1];\n        //dist[j]=dist[j-1]\n        j=j-1;\n      }\n      grp.shapes_g[j]=shape;\n      //dist[j]=distance;\n    }\n   },\n   \n\n   sortAnyShapesByDistToLineCenter(shapes,line){\n    //this.updateAllPosInGrp(grp.id)\n    //let last_distX=new Array(grp.shapes_g.length);\n    \n    //let distX;\n    //let distY;\n    //let sign;\n    //let dist=new Array(grp.shapes_g.length);\n    //let angle;\n    for (let l=0;l<shapes.length;l++){\n        let distX=shapes[l].x-line.x;\n        let distY=shapes[l].y-line.y;\n        /*\n        angle=grp.shapes_g[l].rotation*(Math.PI/180);\n\n      \n      if(angle<=-Math.PI/4 || angle>=-Math.PI/2){\n        sign=-Math.sign(distY);\n      }\n      else if(angle<=-Math.PI/2 || angle>=-3*Math.PI/4){\n        sign=Math.sign(distY);\n      }\n      else if(angle<=-3*Math.PI/4 || angle>=-Math.PI){\n        sign=-Math.sign(distX);\n      }else if(angle>=3*Math.PI/4 || angle<=Math.PI){\n        sign=Math.sign(distX);\n      }else if(angle>=Math.PI/2 || angle<3*Math.PI/4){\n        sign=-Math.sign(distY);\n      } else if(angle<=Math.PI/2 || angle>Math.PI/4){\n        sign=-Math.sign(distY);\n      } else if(angle<=Math.PI/4 || angle>=0){\n        sign=Math.sign(distX);\n      }\n       console.log(sign);\n        */\n       \n        /*\n        if(Math.sin(grp.line.rotation*(Math.PI/180))==0){\n            grp.shapes_g[l].distance_to_line_center=grp.shapes_g[l].x-grp.line.x;\n        }else{\n            grp.shapes_g[l].distance_to_line_center=Math.sign(distX)*Math.sqrt((distX)**2+(distY)**2);\n          \n            if(grp.line.rotation*(Math.PI/180)<=-Math.PI/2 || grp.line.rotation*(Math.PI/180)<=Math.PI/2 &&grp.line.rotation*(Math.PI/180)>=0){\n              grp.shapes_g[l].distance_to_line_center=-grp.shapes_g[l].distance_to_line_center\n            }\n        }\n        */\n        //dist[l]=this.GiveSignOfDistance(grp.shapes_g[l],grp.line)*Math.sqrt((distX)**2+(distY)**2);\n        shapes.distance_to_line_center=this.GiveSignOfDistance(shapes,line)*Math.sqrt((distX)**2+(distY)**2);\n        /*\n        if((grp.line.rotation*(Math.PI/180)<=-Math.PI/2 || (grp.line.rotation*(Math.PI/180)<=Math.PI/2 && grp.line.rotation*(Math.PI/180)>=0)) && (Math.sign(last_distX[l])!=Math.sign(distX))){\n          grp.shapes_g[l].distance_to_line_center=-grp.shapes_g[l].distance_to_line_center\n        }\n        */\n        //last_distX[l]=distX;\n      }\n    for(let i=1;i<shapes.length;i++){\n      \n     \n      let shape=shapes[i];\n      //let distance=dist[i];\n      let j=i\n      while(j>0 && shapes[j-1].distance_to_line_center>shape.distance_to_line_center){\n        shapes[j]=shapes[j-1];\n        //dist[j]=dist[j-1]\n        j=j-1;\n      }\n      shapes[j]=shape;\n      //dist[j]=distance;\n    }\n   },\n\n  \n\n   /*\n   update the drag function of a shape which is on a line. \n   */\n   updateDragFunc(shape,line){\n          let angle=line.rotation*(Math.PI/180);\n          if (angle<=0 && angle>=-Math.PI/4){\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x +(pos.x-line.x)*Math.cos(angle),\n                y: line.y+(pos.x-line.x)*Math.sin(angle),\n              };\n            }\n          } else if (angle<-Math.PI/4 && angle>=-Math.PI/2){\n            // We prefer, in this case, moving the shape of the line regarding the y of the mouse position instead of the x.\n            // So that the user can move the shape more intuitively\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x-(pos.y-line.y)*Math.cos(angle),\n                y: line.y-(pos.y-line.y)*Math.sin(angle),\n              };\n            }\n          }\n          else if (angle<-Math.PI/2 && angle>=-3*Math.PI/4){\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x-(pos.y-line.y)*Math.cos(angle),\n                y: line.y-(pos.y-line.y)*Math.sin(angle),\n              };\n            }\n          } else if (angle<-3*Math.PI/4 && angle>=-Math.PI){\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x-(pos.x-line.x)*Math.cos(angle),\n                y: line.y-(pos.x-line.x)*Math.sin(angle),\n              };\n            }\n          }else if (angle<=Math.PI && angle>=3*Math.PI/4){\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x-(pos.x-line.x)*Math.cos(angle),\n                y: line.y-(pos.x-line.x)*Math.sin(angle),\n              };\n            }\n          } else if (angle<3*Math.PI/4 && angle>=Math.PI/2){\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x+(pos.y-line.y)*Math.cos(angle),\n                y: line.y+(pos.y-line.y)*Math.sin(angle),\n              };\n            }\n          } else if (angle<Math.PI/2 && angle>=Math.PI/4){\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x+(pos.y-line.y)*Math.cos(angle),\n                y: line.y+(pos.y-line.y)*Math.sin(angle),\n              };\n            }\n          }else if (angle<Math.PI/4 && angle>=0){\n            shape.dragBoundFunc= function (pos) {\n              return {\n                x: line.x+(pos.x-line.x)*Math.cos(angle),\n                y: line.y+(pos.x-line.x)*Math.sin(angle),\n              };\n            }\n          }\n   },\n\n   /*\n   Update the position of a free shape when it is dragging.\n   */\n    updatePos(e){\n      const shape = this.shapes.find(i => i.id === e.target.id());\n      shape.x=e.target.x();\n      shape.y=e.target.y();\n      this.center.x=e.target.x();\n      this.center.y=e.target.y();\n\n      let pos = { x: shape.x, y: shape.y };\n      e.target.position(pos);\n      e.target.getLayer().batchDraw();\n      \n    },\n\n    /*\n    Update the positio  of shape attached to a line (from the group with id=id_grp) when it is dragging.\n     */\n    updatePosInGrp(e,id_grp){\n      let distX;\n      let distY;\n      let distance_to_line_center;\n      const grp=this.groups.find((r)=> r.id===id_grp);\n      \n      if(grp.aShapeHasBeenDetach==1){\n        grp.aShapeHasBeenDetach=0;\n        return;\n      }\n      const line=grp.line;\n      const shape = grp.shapes_g.find(i => i.id === e.target.id());\n      const shapes_g = grp.shapes_g; \n      //const lengthToDetach=10;\n      if(shape.needToBeDetach==1){\n        shape.needToBeDetach=0;\n        this.DetachShape(shape);\n        this.updateAllPosInGrp(e.target.getParent().attrs.id);\n      }\n      if(line.keepDistribution){\n        if(this.isCoordinateOnLine(e.target.x(),e.target.y(),line.id)){\n          distX=shape.x-e.target.x();\n          distY=shape.y -e.target.y();\n          let L=grp.line.points[4];\n          let nb_shapes=grp.shapes_g.length;\n          let d=(L/(nb_shapes-1))*grp.line.scaleX;\n          let dist=Math.sqrt(distX**2 +distY**2);\n          if(dist>=d){\n            shape.x=e.target.x();\n            shape.y=e.target.y();\n            this.updateOccupiedDistance(line.id)\n            shape.x=line.x+line.occupiedDistances[shapes_g.indexOf(shape)]*Math.cos(line.rotation*(Math.PI/180));\n            shape.y=line.y+line.occupiedDistances[shapes_g.indexOf(shape)]*Math.sin(line.rotation*(Math.PI/180));\n            shape.distance_to_line_center=line.occupiedDistances[shapes_g.indexOf(shape)];\n            shape.rotation=line.rotation;\n            this.updateAllPosInGrp(line.id);\n          }else{\n            shape.x=line.x+line.occupiedDistances[shapes_g.indexOf(shape)]*Math.cos(line.rotation*(Math.PI/180));\n            shape.y=line.y+line.occupiedDistances[shapes_g.indexOf(shape)]*Math.sin(line.rotation*(Math.PI/180));\n            shape.distance_to_line_center=line.occupiedDistances[shapes_g.indexOf(shape)];\n            shape.rotation=line.rotation; \n          }   \n        }else{\n          shape.x=e.target.x();\n          shape.y=e.target.y();\n        }\n        line.positionPoints[grp.shapes_g.indexOf(shape)].x=shape.x;\n        line.positionPoints[grp.shapes_g.indexOf(shape)].y=shape.y;\n        line.positionPoints[grp.shapes_g.indexOf(shape)].distance_to_line_center=shape.distance_to_line_center; \n      } else{\n        \n          line.positionPoints[grp.shapes_g.indexOf(shape)].x=shape.x;\n          line.positionPoints[grp.shapes_g.indexOf(shape)].y=shape.y;\n          shape.x=e.target.x();\n          shape.y=e.target.y();\n          \n          if(Math.sin(line.rotation*(Math.PI/180))==0){\n            distance_to_line_center=shape.x-line.x;\n          }else{\n            if(Math.sign(shape.x-line.x)!=0){\n              distance_to_line_center=Math.sign(-shape.rotation)*Math.sign(shape.x-line.x)*Math.sqrt((shape.x-line.x)**2+(shape.y-line.y)**2);\n            } else{\n             distance_to_line_center=Math.sign(-shape.rotation)*Math.sign(shape.y-line.y)*Math.sqrt((shape.x-line.x)**2+(shape.y-line.y)**2); \n            }\n          \n            if(shape.rotation*(Math.PI/180)<=-Math.PI/2 || (shape.rotation*(Math.PI/180)<=Math.PI/2 && shape.rotation*(Math.PI/180)>=0)){\n              distance_to_line_center=-distance_to_line_center\n            }\n          }\n          //shape.distance_to_line_center=distance_to_line_center;\n          //grp.line.occupiedDistances[shapes_g.indexOf(shape)]=shape.distance_to_line_center;\n        line.positionPoints[grp.shapes_g.indexOf(shape)].distance_to_line_center=shape.distance_to_line_center;\n          \n      }\n      let pos = { x: shape.x, y: shape.y };\n      this.center.x=shape.x;\n      this.center.y=shape.y;\n      e.target.position(pos);\n      e.target.getLayer().batchDraw();\n      if(!this.isCoordinateOnLine(shape.x,shape.y,line.id)){\n        shape.dragBoundFunc= dragFunc;\n        shape.isGrouped=0;\n        this.shapes.push(shape,)\n        for (let i=0;i<shapes_g.length;i++){\n          if(shapes_g[i].id==shape.id){\n            line.freeDistances.push(line.occupiedDistances[i]);\n            line.occupiedDistances.splice(i,1);\n            shapes_g.splice(i,1);\n            console.log(\"a shape has been removed from the line\");\n          }\n        } \n      }else{\n        if(!line.keepDistribution){\n          grp.line.occupiedDistances[shapes_g.indexOf(shape)]=distance_to_line_center;\n        }else{\n        grp.line.occupiedDistances[shapes_g.indexOf(shape)]=shape.distance_to_line_center;\n        }\n        \n      line.positionPoints[grp.shapes_g.indexOf(shape)].x=shape.x;\n      line.positionPoints[grp.shapes_g.indexOf(shape)].y=shape.y;\n      line.positionPoints[grp.shapes_g.indexOf(shape)].distance_to_line_center=shape.distance_to_line_center;\n       \n      }\n      /*\n      let coord_y1=line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x1=line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let coord_y2= line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x2=line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let a=(coord_y1-coord_y2)/(coord_x2-coord_x1);\n      let b=line.y-a*line.x;\n      let is_on_straight_line=false;\n      if(Math.abs(coord_x1-coord_x2)>=1){\n        is_on_straight_line=(Math.abs(a*shape.x+b-shape.y)<1);\n      }else{\n        is_on_straight_line=(Math.abs(shape.x-line.x)<1);\n      }\n      if(\n        !(is_on_straight_line)\n      ||((line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n        ||line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      && ((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>-Math.PI)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>-Math.PI)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>=0)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>=0)))\n      )\n      {\n        shape.dragBoundFunc= dragFunc;\n        this.shapes.push(shape,)\n        for (let i=0;i<shapes_g.length;i++){\n          if(shapes_g[i].id==shape.id){\n            line.freeDistances.push(line.occupiedDistances[i]);\n            line.occupiedDistances.splice(i,1);\n            shapes_g.splice(i,1);\n            console.log(\"a shape has been removed from the line\");\n          }\n        } \n      }else{\n        if(!line.keepDistribution){\n          grp.line.occupiedDistances[shapes_g.indexOf(shape)]=distance_to_line_center;\n        }else{\n        grp.line.occupiedDistances[shapes_g.indexOf(shape)]=shape.distance_to_line_center;\n        }\n      }\n      */\n      //this.updateOccupiedDistance(line.id);\n      \n          if(line.keepDistribution){\n            this.updateOccupiedDistance(line.id);\n          }\n          \n          this.updateAllPosInGrp(line.id);\n    },\n    /*\n    Function called when the transformation of a shape with a transfomer is finished.\n    */\n    updateTransformedShape(e) {\n      \n\n      let res;\n      let shape; //Object concerned by the transformation\n      if(e.target.className==\"Line\"){\n        shape=this.groups.find(\n        (r) => r.id === this.selectedShapeId\n      ).line;\n      }else{\n        res=this.findShape(this.selectedShapeId)\n        shape=res.shape_data;\n        if(shape== undefined){\n          return;\n        }\n      }\n\n      \n      let last_shapex= shape.x;\n      let last_shapey= shape.y;\n\n      //update data of the transformed object.\n      shape.x = e.target.x();\n      shape.y = e.target.y();\n      shape.rotation = e.target.rotation();\n      let last_scaleX= shape.scaleX;\n      shape.scaleX = e.target.scaleX();\n      shape.scaleY = e.target.scaleY();\n\n      if(e.target.className==\"Line\"){\n        const grp=this.groups.find((r)=> r.id===shape.id);\n        if(shape.keepDistribution){\n          for (let i=0;i<shape.occupiedDistances.length;i++){\n            shape.occupiedDistances[i]=(shape.occupiedDistances[i]/last_scaleX)*shape.scaleX;\n          }\n          /*\n          for (let i=0;i<shape.freeDistances.length;i++){\n            shape.freeDistances[i]=(shape.freeDistances[i]/last_scaleX)*shape.scaleX;\n          }\n          */\n          \n          //this.updateOccupiedDistance(shape.id)\n          this.update();\n          this.updateGrp(e, this.selectedShapeId);\n          this.checkIfShapesOnLine(this.selectedShapeId);        \n        }else{\n          \n          \n          \n         if(last_scaleX!=shape.scaleX){\n          for(let i=0;i<grp.shapes_g.length;i++){\n          \n          //If the width of the line has been changed, we update the distance from the shape to the center of the line\n            \n              let distX=grp.shapes_g[i].x-shape.x;\n              let distY=grp.shapes_g[i].y-shape.y;\n              /*\n              if(Math.sign(grp.shapes_g[i].distance_to_line_center)==0){\n                grp.shapes_g[i].distance_to_line_center=-this.GiveSignOfDistance(grp.shapes_g[i],shape)*Math.sqrt((distX)**2 +(distY)**2);\n              \n              }else{\n                grp.shapes_g[i].distance_to_line_center=Math.sign(grp.shapes_g[i].distance_to_line_center)*Math.sqrt((distX)**2 +(distY)**2);\n              }\n              if(Math.sign((grp.shapes_g[i].x-last_shapex))!=Math.sign(distX)){\n                grp.shapes_g[i].distance_to_line_center=-grp.shapes_g[i].distance_to_line_center;\n              }\n              */\n             if(Math.sign(grp.line.occupiedDistances[i])==0){\n                //if(grp.line.rotation!=-90 && grp.line.rotation!=90){\n                  //grp.line.occupiedDistances[i]=-this.GiveSignOfDistance(grp.shapes_g[i],shape)*Math.sqrt((distX)**2 +(distY)**2);\n                //}else{\n                  grp.line.occupiedDistances[i]=this.GiveSignOfDistance(grp.shapes_g[i],shape)*Math.sqrt((distX)**2 +(distY)**2);\n                  \n                //}\n              \n              }else{\n                grp.line.occupiedDistances[i]=Math.sign(grp.line.occupiedDistances[i])*Math.sqrt((distX)**2 +(distY)**2);\n              }\n\n              \n              if(Math.sign((grp.shapes_g[i].x-last_shapex))!=Math.sign(distX) && Math.sign((grp.shapes_g[i].x-last_shapex))!=0 && grp.line.rotation!=90 && grp.line.rotation!=-90){\n                \n                grp.line.occupiedDistances[i]=-grp.line.occupiedDistances[i];\n              }\n              if(Math.sign((grp.shapes_g[i].y-last_shapey))!=Math.sign(distY) && Math.sign((grp.shapes_g[i].y-last_shapey))!=0 && (grp.line.rotation==90 || grp.line.rotation==-90)){\n                grp.line.occupiedDistances[i]=-grp.line.occupiedDistances[i];\n              }\n              //this.checkIfShapesOnLine(this.selectedShapeId);  \n            \n            //this.checkIfShapesOnLine(this.selectedShapeId);\n            //grp.line.occupiedDistances[i]=grp.shapes_g[i].distance_to_line_center;\n            \n          }\n          for (let i=0;i<shape.freeDistances.length;i++){\n            let distX=last_shapex-shape.x;\n            let distY=last_shapey-shape.y; \n            let dist=Math.sqrt(distX**2+distY**2);\n            if(shape.rotation<-90 ||shape.rotation>90){\n              shape.freeDistances[i]=shape.freeDistances[i]-Math.sign(last_shapex-shape.x)*dist;\n            } else if(shape.rotation==90 || shape.rotation==-90){\n              shape.freeDistances[i]=shape.freeDistances[i]-distY\n            } else{\n              shape.freeDistances[i]=shape.freeDistances[i]+Math.sign(last_shapex-shape.x)*dist;\n            \n            }\n          }\n         }\n          this.update();\n          this.updateGrp(e, this.selectedShapeId);\n          this.checkIfShapesOnLine(this.selectedShapeId);\n\n          // We now see if freeDistances need to be delete(so if they are bigger than the half of the stickyline);\n          \n        }\n        for(let i=0;i<grp.shapes_g.length;i++){\n            \n          this.updateDragFunc(grp.shapes_g[i],shape);\n\n        }\n      }else if(res.grp_id!='-1'){\n        //this.update();\n        //let layer=e.target.getParent().getLayer();\n        //layer.batchDraw();\n        this.updateAllPosInGrp(res.grp_id);\n        this.updateOccupiedDistance(res.grp_id);\n        e.target.x(e.target.getParent().attrs.shapes_g.find((r)=>r.id===e.target.id()).x);\n        e.target.y(e.target.getParent().attrs.shapes_g.find((r)=>r.id===e.target.id()).y);\n        this.groups.find((r)=>r.id===res.grp_id).shapes_g.find((r)=>r.id===e.target.id()).personalRotation=e.target.rotation()-e.target.getParent().attrs.line.rotation;\n        \n        \n        this.updateAllPosInGrp(res.grp_id);\n        this.checkIfShapesOnLine(res.grp_id);\n        this.updateDragFuncOfCenter();\n      \n      }\n      else{\n        this.update();\n        \n        this.updateDragFuncOfCenter();\n      }\n      this.center.x=e.target.attrs.x;\n      this.center.y=e.target.attrs.y;\n    },\n    \n    handleTransformation(e) {\n      if (e.evt==undefined) {\n        return;\n      }\n      if(this.eraseMode==1){\n        this.eraserAction(e);\n        return;\n      }\n      \n      //If we click on the stage, we have to remove the transformer from the node where it was.\n      if (e.target === e.target.getStage()) {\n        this.selectedShapeId = 'NoId';\n        this.eraseNodefromTransformer(\"lineTransformer\");\n        this.eraseNodefromTransformer(\"shapeTransformer\");\n        this.center.opacity=0;\n        return;\n      }\n\n      // If we click on a transformer, nothing happen.\n      const clickedOnTransformer = e.target.getParent().className === 'Transformer';\n      if (clickedOnTransformer) {\n        return;\n      }\n      \n      const id = e.target.id();\n      let transformer_id;\n      let shape=this.findShape(id).shape_data;\n\n      //if it is a line, we need the transformer dedicated to the line (ie transformer with id=\"lineTransformer\")\n      //if it is a classic shape, we need the transformer dedicated to the shape (ie transformer with id=\"shapeTransformer\")\n      if(e.target.attrs.id==\"center\"){\n        return;\n      }\n      if(e.target.className==\"Line\"){\n        transformer_id=\"lineTransformer\"\n        shape = this.groups.find((r) => r.id === id).line;\n        this.center.draggable=false;\n        this.selectedShapeAlignment=shape.defaultAlignment;\n        this.eraseNodefromTransformer(\"shapeTransformer\");\n      }else{\n        transformer_id=\"shapeTransformer\"\n        this.center.draggable=true;\n        this.selectedShapeAlignment=shape.centerPosition;\n        this.eraseNodefromTransformer(\"lineTransformer\");\n      }\n      \n      if (shape!=undefined) {\n        this.selectedShapeId = id;\n        this.center.opacity=1;\n        this.updateTransformer(transformer_id);\n      } else{\n        /*Only if the center is not selected.\n        When the center is dragged, this function is called.\n        But a shape is actualy selected (the one of the center).\n        */\n        this.selectedShapeId = 'NoId';\n      }\n      //this.updateTransformer(transformer_id);\n      \n      this.updateDragFuncOfCenter()\n    },\n\n    //remove node from transformer with id=transformer_id\n    eraseNodefromTransformer(transformer_id) {\n      let stage= this.$refs.stage.getStage();      \n      const transformerNode = stage.find(\"#\"+transformer_id)[0]; \n      transformerNode.nodes([]);\n    },\n\n    //Update transformer with id=transformer_id\n    //It places the transformer regarding what node is selected\n    updateTransformer(transformer_id) {\n\n      let stage= this.$refs.stage.getStage();\n      const transformerNode = stage.find(\"#\"+transformer_id)[0];\n      let selectedNode;\n      if (transformer_id==\"lineTransformer\"){\n        selectedNode = stage.children[0].getChildren().filter((r)=> r.attrs.className==\"Group\" && r.attrs.id==this.selectedShapeId)[0]\n        .getChildren().filter(r=>r.attrs.className==\"Line\" && r.attrs.id==this.selectedShapeId)[0];\n      }else{\n      selectedNode = stage.children[0].getChildren().filter((r)=>r.attrs.className!=\"Group\" && r.attrs.id==this.selectedShapeId)[0];\n\n      let isFunded=true;\n      if(selectedNode==undefined){\n        isFunded=false;\n      }\n      let i=0;\n      while(!isFunded){\n        if(i<this.groups.length){\n          selectedNode=stage.children[0].getChildren().filter((r)=>r.attrs.className==\"Group\")[i].getChildren().find((r)=>r.attrs.id==this.selectedShapeId && r.attrs.className!=\"Line\");\n        if(selectedNode==undefined){\n          isFunded=false;\n        }else{\n          isFunded=true;\n        }\n        i++;\n        }else{        \n          isFunded=true;\n        }\n      }\n      }\n      /*\n      if (transformer_id==\"lineTransformer\"){\n        selectedNode = stage.children[0].getChildren().filter((r)=> r.attrs.className==\"Group\" && r.attrs.id==this.selectedShapeId)[0]\n        .getChildren().filter(r=>r.attrs.className==\"Line\" && r.attrs.id==this.selectedShapeId)[0];\n      }\n      */\n     \n      //If the selected node has already the transformer on it, nothing happen\n      if (selectedNode === transformerNode.node()) {\n        return;\n      }\n\n      //If a node is selected\n      if (selectedNode!=undefined) {\n        //We attach the transformer to the node\n        transformerNode.nodes([selectedNode]);\n      } else {\n        //if no node is selected, we remove the transformer from its node.\n        transformerNode.nodes([]);\n      }\n      this.center.x=selectedNode.attrs.x;\n      this.center.y=selectedNode.attrs.y;\n      \n    },\n/*\n  DisplayCenterMenu(e){\n    CenterMenu.props.ConcernedShape=e.target;\n   document.getElementById(\"center_menu\").style.display=\"initial\";\n   document.getElementById(\"center_menu\").style.top=e.target.getStage().getPointerPosition().y+8+\"px\";\n  document.getElementById(\"center_menu\").style.left=e.target.getStage().getPointerPosition().x+8+\"px\";\n  },\n  */\n\n  //display context menu according to the target\n  /*\n  DisplayContextMenu(e){\n    e.evt.preventDefault()\n    if (e.target.className!=undefined && e.target.attrs.id!=\"center\"){\n      this.isStageOnlySelected=false;\n      ContextMenu.data().dM='initial';\n      this.$emit('needmenu');\n      this.needMenu=true;\n      ContextMenu.props.ConcernedShape=e.target;\n      if (e.target.attrs.className==\"Line\"){\n        this.isALineSelected=true;\n        this.isAGroupedShapeSelected=true;\n        //We precise the text which depends on the line where we clicked.\n        this.keepDistanceButtonText=e.target.attrs.keepDistanceButtonText;\n      } else if(e.target.getParent().attrs.className==\"Group\"){\n        this.isAGroupedShapeSelected=true;\n      }\n      else{\n        this.isALineSelected=false;\n        this.isAGroupedShapeSelected=false;\n      }\n      \n      document.getElementById(\"activeReuseSubstrate\").style.display=\"initial\";\n      document.getElementById(\"activeReuseSubstrate\").style.top= document.getElementById(\"ReificationSubstrateDemo\").getBoundingClientRect().top+document.documentElement.scrollTop+e.target.getStage().getPointerPosition().y+\"px\";\n      document.getElementById(\"activeReuseSubstrate\").style.left= document.getElementById(\"ReificationSubstrateDemo\").getBoundingClientRect().left+document.documentElement.scrollLeft+e.target.getStage().getPointerPosition().x+\"px\";\n    }\n    if (e.target === e.target.getStage()) {\n      this.needMenu=true;\n      this.isALineSelected=false;\n      this.isAGroupedShapeSelected=false;\n      this.isStageOnlySelected=true;\n      document.getElementById(\"activeReuseSubstrate\").style.display=\"initial\";\n      document.getElementById(\"activeReuseSubstrate\").style.top=document.getElementById(\"ReificationSubstrateDemo\").getBoundingClientRect().top+document.documentElement.scrollTop+e.target.getStage().getPointerPosition().y+\"px\";\n      document.getElementById(\"activeReuseSubstrate\").style.left=document.getElementById(\"ReificationSubstrateDemo\").getBoundingClientRect().left+document.documentElement.scrollLeft+e.target.getStage().getPointerPosition().x+\"px\";\n    \n    }\n  },\n\n  //hide context menu\n  HideContextMenu(){\n    this.needMenu=false;\n    document.getElementById(\"activeReuseSubstrate\").style.display=\"none\";\n    document.getElementById(\"center_menu\").style.display=\"none\";\n  },\n*/\n\n  \n ChangeCenter(e){\n  let res=this.findShape(this.selectedShapeId);\n  let shape=res.shape_data;\n  let threshold1;\n  let threshold2;\n  let dist=this.GiveSignOfDistanceBtwCenterAndShape(e.target.attrs,shape)*Math.sqrt((e.target.y()-(shape.y))**2+(e.target.x()-shape.x)**2)+shape.offsetY*shape.scaleY;\n  \n  //let last_offsetX=shape.offsetX;\n  let last_offsetY=shape.offsetY;\n  if(shape==undefined){\n    shape=this.groups.find((r)=>r.id==this.selectedShapeId).line;\n\n  }else{\n    \n      if(shape.className==\"Rect\") {\n        threshold1=shape.height*shape.scaleY/3;\n        threshold2=shape.height*shape.scaleY*2/3;\n        if(dist>=threshold1 && dist<=threshold2){\n          shape.offsetX=shape.width/2;\n          shape.offsetY=shape.height/2;\n          shape.centerPosition=\"Middle\";\n        }else if(dist>threshold2){\n          shape.offsetX=shape.width/2;\n          shape.offsetY=shape.height;\n          shape.centerPosition=\"Bottom\";\n        }\n        else{\n          shape.offsetX=shape.width/2;\n          shape.offsetY=0;\n          shape.centerPosition=\"Top\";\n        }\n      }\n      else if(shape.className==\"Circle\") {\n        dist=dist+shape.radius*shape.scaleY;\n        threshold1=shape.radius*shape.scaleY*2/3;\n        threshold2=shape.radius*shape.scaleY*4/3;\n        if(dist>=threshold1 && dist<=threshold2){\n          shape.offsetX=0;\n          shape.offsetY=0;\n          shape.centerPosition=\"Middle\";\n        }else if(dist>threshold2){\n          shape.offsetX=0;\n          shape.offsetY=shape.radius;\n          shape.centerPosition=\"Bottom\";\n        }else{\n          shape.offsetX=0;\n          shape.offsetY=-shape.radius;\n          shape.centerPosition=\"Top\";\n        } \n      }\n      else if(shape.className==\"Image\") {\n        threshold1=shape.image.height*shape.scaleY/3;\n        threshold2=shape.image.height*shape.scaleY*2/3;\n        if(dist>=threshold1 && dist<=threshold2){\n          shape.offsetX=shape.image.width/2;\n          shape.offsetY=shape.image.height/2;\n          shape.centerPosition=\"Middle\";\n        }else if(dist>threshold2){\n          shape.offsetX=shape.image.width/2;\n          shape.offsetY=shape.image.height;\n          shape.centerPosition=\"Bottom\";\n        }\n        else {\n          shape.offsetX=shape.image.width/2;\n          shape.offsetY=0;\n          shape.centerPosition=\"Top\";\n        }\n      }\n      else if(shape.className==\"Text\") {\n        threshold1=shape.length_y*shape.scaleY/3;\n        threshold2=shape.length_y*shape.scaleY*2/3;\n        if(dist>=threshold1 && dist<=threshold2){\n          shape.offsetX=shape.length_x/2;\n          shape.offsetY=shape.length_y/2;\n          shape.centerPosition=\"Middle\";\n        }else if(dist>threshold2){\n          shape.offsetX=shape.length_x/2;\n          shape.offsetY=shape.length_y;\n          shape.centerPosition=\"Bottom\";\n        }\n        else{\n          shape.offsetX=shape.length_x/2;\n          shape.offsetY=0;\n          shape.centerPosition=\"Top\";\n        }\n      }\n      else if(shape.className==\"Triangle\") {\n        dist=dist+shape.radius*shape.scaleY;\n        threshold1=shape.radius*shape.scaleY/2;\n        threshold2=shape.radius*shape.scaleY*5/4;\n        if(dist>=threshold1 && dist<=threshold2){\n          shape.offsetX=0;\n          shape.offsetY=0;\n        }else if(dist>threshold2){\n          shape.offsetX=0;\n          shape.offsetY=shape.radius/2\n          shape.centerPosition=\"Bottom\";\n        }\n        else{\n          shape.offsetX=0;\n          shape.offsetY=-shape.radius;\n          shape.centerPosition=\"Top\";\n        }\n      }\n      shape.y=shape.y-(last_offsetY-shape.offsetY)*shape.scaleY*Math.cos(shape.rotation*(Math.PI/180));\n      shape.x=shape.x+(last_offsetY-shape.offsetY)*shape.scaleY*Math.sin(shape.rotation*(Math.PI/180));\n      this.selectedShapeAlignment=shape.centerPosition;\n\n      if (res.grp_id!='-1'){\n        this.updateAllPosInGrp(res.grp_id);\n      }\n        \n      e.target.x(shape.x);\n      e.target.y(shape.y);\n\n     \n\n      \n  }\n  },\n  \n  /*\n  ChangeAlignCenter(align_choice){\n    let center=CenterMenu.props.ConcernedShape;\n    let grp=this.groups.find((r)=>r.id===this.selectedShapeId);\n    let shape;\n    if(grp!=undefined){\n      for(let i=0;i<grp.shapes_g.length;i++){\n        this.ChangeCenterRegardingCommand(grp.shapes_g[i].id,align_choice)\n      }\n      center.x(grp.line.x);\n      center.y(grp.line.y);\n      if(grp.line.defaultAlignment==align_choice){\n        grp.line.defaultAlignment='' //If we select again the same alogn_choice, we deselect it, no alignement center is fixed.\n      }else{\n        grp.line.defaultAlignment=align_choice;\n      }\n      this.selectedShapeAlignment=grp.line.defaultAlignment;\n    }else{\n      shape=this.findShape(this.selectedShapeId).shape_data;\n      this.ChangeCenterRegardingCommand(shape.id,align_choice)\n      this.selectedShapeAlignment=shape.centerPosition;\n      center.x(shape.x);\n      center.y(shape.y);\n    }\n  },\n  */\n  //Allow to change the center regarding a text command (Top,Middle or Bottom)\n  ChangeCenterRegardingCommand(shape_id,command){\n    let res=this.findShape(shape_id);\n    let shape=res.shape_data;\n    let last_offsetY=shape.offsetY;\n    if(shape.className==\"Rect\" ){\n      if(command==\"Top\"){\n        shape.offsetY=0;\n        shape.offsetX=shape.width/2;\n      }\n      else if(command==\"Middle\"){\n          shape.offsetX=shape.width/2;\n          shape.offsetY=shape.height/2;\n      }else if(command==\"Bottom\"){\n            shape.offsetX=shape.width/2;\n            shape.offsetY=shape.height;\n      }\n    }\n      else if(shape.className==\"Circle\") {\n        if(command==\"Top\"){\n          shape.offsetX=0;\n          shape.offsetY=-shape.radius;\n        }else if(command==\"Middle\"){\n          shape.offsetX=0;\n          shape.offsetY=0\n        }else if(command==\"Bottom\"){\n          shape.offsetX=0;\n          shape.offsetY=shape.radius;\n        } \n      }\n      else if(shape.className==\"Image\") {\n        if(command==\"Middle\"){\n          shape.offsetX=shape.image.width/2;\n          shape.offsetY=shape.image.height/2;\n        }else if(command==\"Bottom\"){\n          shape.offsetX=shape.image.width/2;\n          shape.offsetY=shape.image.height;\n        }\n        else if (command==\"Top\"){\n          shape.offsetX=shape.image.width/2;\n          shape.offsetY=0;\n        }\n      }\n      else if(shape.className==\"Text\") {\n        if(command==\"Middle\"){\n          shape.offsetX=shape.length_x/2;\n          shape.offsetY=shape.length_y/2;\n        }else if(command==\"Bottom\"){\n          shape.offsetX=shape.length_x/2;\n          shape.offsetY=shape.length_y;\n        }\n        else if(command==\"Top\"){\n          shape.offsetX=shape.length_x/2;\n          shape.offsetY=0;\n        }\n      }\n      else if(shape.className==\"Triangle\") {\n        if(command==\"Middle\"){\n          shape.offsetX=0;\n          shape.offsetY=0;\n        }else if(command==\"Bottom\"){\n          shape.offsetX=0;\n          shape.offsetY=shape.radius/2;\n        }\n        else if(command==\"Top\"){\n          shape.offsetX=0;\n          shape.offsetY=-shape.radius;\n        }\n      }\n      shape.centerPosition=command;\n      shape.y=shape.y-(last_offsetY-shape.offsetY)*shape.scaleY*Math.cos(shape.rotation*(Math.PI/180));\n      shape.x=shape.x+(last_offsetY-shape.offsetY)*shape.scaleY*Math.sin(shape.rotation*(Math.PI/180));\n\n      if (res.grp_id!='-1'){\n        this.updateAllPosInGrp(res.grp_id);\n      }\n        \n      //center.x(shape.x);\n      //center.y(shape.y);\n  },\n  updateDragFuncOfCenter(){\n    let shape=this.findShape(this.selectedShapeId).shape_data\n    if(shape==undefined){\n      return;\n    }\n    let center=this.center;\n    let angle=shape.rotation*(Math.PI/180);\n    if(angle>=-Math.PI/2 && angle<=0){\n      angle-=90*(Math.PI/180);\n    }else if(angle<-Math.PI/2){\n      angle+=(Math.PI/2);\n      angle=Math.PI+angle;\n    } else if(angle<=Math.PI && angle>0){\n      angle-=90*(Math.PI/180);\n    } \n    if (angle<=0 && angle>=-Math.PI/4){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x +(pos.x-shape.x)*Math.cos(angle),\n          y: shape.y+(pos.x-shape.x)*Math.sin(angle),\n        };\n      }\n    } else if (angle<-Math.PI/4 && angle>=-Math.PI/2){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x-(pos.y-shape.y)*Math.cos(angle),\n          y: shape.y-(pos.y-shape.y)*Math.sin(angle),\n        };\n      }\n    }\n    else if (angle<-Math.PI/2 && angle>=-3*Math.PI/4){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x-(pos.y-shape.y)*Math.cos(angle),\n          y: shape.y-(pos.y-shape.y)*Math.sin(angle),\n        };\n      }\n    } else if (angle<-3*Math.PI/4 && angle>=-Math.PI){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x-(pos.x-shape.x)*Math.cos(angle),\n          y: shape.y-(pos.x-shape.x)*Math.sin(angle),\n        };\n      }\n    }else if (angle<=Math.PI && angle>=3*Math.PI/4){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x-(pos.x-shape.x)*Math.cos(angle),\n          y: shape.y-(pos.x-shape.x)*Math.sin(angle),\n        };\n      }\n    } else if (angle<3*Math.PI/4 && angle>=Math.PI/2){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x+(pos.y-shape.y)*Math.cos(angle),\n          y: shape.y+(pos.y-shape.y)*Math.sin(angle),\n        };\n      }\n    } else if (angle<Math.PI/2 && angle>=Math.PI/4){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x+(pos.y-shape.y)*Math.cos(angle),\n          y: shape.y+(pos.y-shape.y)*Math.sin(angle),\n        };\n      }\n    }else if (angle<Math.PI/4 && angle>=0){\n      center.dragBoundFunc= function (pos) {\n        return {\n          x: shape.x+(pos.x-shape.x)*Math.cos(angle),\n          y: shape.y+(pos.x-shape.x)*Math.sin(angle),\n        };\n      }\n    }\n  },\n  MovingCenter(){\n    //let shape=this.findShape(this.selectedShapeId)\n    //console.log(e.target)\n  },\n  /*\n  //called when the \"Change Center\" button is clicked\n  ChangeCenterButtonAction(){\n      let shape= ContextMenu.props.ConcernedShape;\n      if(shape.attrs.className==\"Line\"){\n        let shapes_g=shape.getParent().attrs.shapes_g //the list of the shapes which are on the line is in the corresponding group.\n        for (let j=0;j<shapes_g.length;j++){\n          this.ChangeCenter(shapes_g[j]);\n        }\n      }else{\n        let shape_data=this.shapes.find(i => i.id ===shape.attrs.id);\n        let isFunded=true;\n        if(shape_data==undefined){\n          isFunded=false;\n        }\n        let i=0;\n        while(!isFunded){\n          if(i<this.groups.length){\n            shape_data=this.groups[i].shapes_g.find(i => i.id === shape.attrs.id);\n          if(shape_data==undefined){\n            isFunded=false;\n          }else{\n            isFunded=true;\n          }\n          i++;\n          }else{        \n            isFunded=true;\n          }\n        }\n        this.ChangeCenter(shape_data)\n      }\n    },\n    */\n    \n    //allow to copy a target\n    \n    /*\n    Copy(){\n      ContextMenu.props.CopiedShape=ContextMenu.props.ConcernedShape;\n      ContextMenu.props.pastOneObject=true;\n    },\n    \n    CopyAll(){\n      ContextMenu.props.CopiedShape=ContextMenu.props.ConcernedShape;\n      ContextMenu.props.pastOneObject=false;\n    },\n    \n    Past(){   \n      //Prevent error when no shape is copied\n      if(ContextMenu.props.CopiedShape.attrs==undefined){\n        return;\n      }\n      let clone=ContextMenu.props.CopiedShape.clone({\n        id: ''+this.max_id_figures,\n      })\n      //let layer=ContextMenu.props.CopiedShape.getLayer();\n      let i= this.groups.length\n      //let new_id=i+1;\n      if(ContextMenu.props.CopiedShape.attrs.className==\"Line\"){\n        this.max_id_figures=this.max_id_figures+1;\n        if(!ContextMenu.props.pastOneObject){\n          //let i= this.groups.length;\n          //let new_id=i+1;\n        \n          clone=ContextMenu.props.CopiedShape.getParent().clone({\n            id: ''+ this.max_id_figures,\n            name: \"group\"+this.max_id_figures,\n            shapes_g:[],\n          })\n          clone.attrs.line.id=''+this.max_id_figures;\n          clone.attrs.line.x=ContextMenu.props.ConcernedShape.getStage().getPointerPosition().x;\n          clone.attrs.line.y=ContextMenu.props.ConcernedShape.getStage().getPointerPosition().y;\n          let positionPoints=Object.assign([],clone.attrs.line.positionPoints);\n            let length=positionPoints.length;\n            clone.attrs.line.positionPoints=[];\n            for(let i=0;i<length.valueOf();i++){\n              let clone_positionPoint=ContextMenu.props.CopiedShape.getParent().getChildren().find((r)=>r.attrs.id===positionPoints[i].id).clone({\n              id:'positionPoint'+clone.attrs.line.id+i,\n              });\n              clone.attrs.line.positionPoints.push(clone_positionPoint.attrs,);\n            }\n          \n          //layer= ContextMenu.props.CopiedShape.getParent().getLayer();\n          this.groups.push(clone.attrs,);\n          let shapesg=this.groups[this.groups.indexOf(this.groups.find((r)=> r.id==ContextMenu.props.CopiedShape.getParent().attrs.id))].shapes_g;\n          let shapesg_length=shapesg.length;\n          for (let j=0; j<shapesg_length;j++){\n            this.max_id_figures=this.max_id_figures + 1;\n            let clone_shape=ContextMenu.props.CopiedShape.getParent().getChildren().find((r)=>r.attrs.id===shapesg[j].id).clone({\n              id:''+this.max_id_figures,\n            });\n           // this.updateDragFunc(clone_shape,clone_line);\n            this.groups[i].shapes_g.push(clone_shape.attrs,);\n            this.updateDragFunc(this.groups[i].shapes_g[this.groups[i].shapes_g.length-1],this.groups[i].line);\n          }\n          this.updateAllPosInGrp(clone.attrs.id);\n        }else{\n          //let i= this.groups.length;\n          //let new_id=i+1;\n        \n          clone=ContextMenu.props.CopiedShape.getParent().clone({\n            id: ''+this.max_id_figures,\n            name: \"group\"+this.max_id_figures,\n            shapes_g:[],\n          })\n          clone.attrs.line.id=''+this.max_id_figures;\n          clone.attrs.line.x=ContextMenu.props.ConcernedShape.getStage().getPointerPosition().x;\n          clone.attrs.line.y=ContextMenu.props.ConcernedShape.getStage().getPointerPosition().y;\n          for(let j=0;j<clone.attrs.line.occupiedDistances.length;j++){\n            clone.attrs.line.freeDistances.push(clone.attrs.line.occupiedDistances[j],);\n          }\n          clone.attrs.line.occupiedDistances=[];\n          if(clone.attrs.line.keepDistribution!=1){\n            let positionPoints=Object.assign([],clone.attrs.line.positionPoints);\n            let length=positionPoints.length;\n            clone.attrs.line.positionPoints=[];\n            for(let i=0;i<length.valueOf();i++){\n              let clone_positionPoint=ContextMenu.props.CopiedShape.getParent().getChildren().find((r)=>r.attrs.id===positionPoints[i].id).clone({\n              id:'positionPoint'+clone.attrs.line.id+i,\n              });\n              clone.attrs.line.positionPoints.push(clone_positionPoint.attrs,);\n            }\n          }\n          //layer= ContextMenu.props.CopiedShape.getParent().getLayer();\n          this.groups.push(clone.attrs,)\n        }\n        //In order to actualize the new line (in particular to show the positionPoints):\n        this.updateAllPosInGrp(clone.attrs.id)\n      } \n      else{\n        this.max_id_figures=this.max_id_figures + 1;\n        clone=ContextMenu.props.CopiedShape.clone({\n          id: ''+this.max_id_figures,  \n          x:ContextMenu.props.ConcernedShape.getStage().getPointerPosition().x,\n          y:ContextMenu.props.ConcernedShape.getStage().getPointerPosition().y,\n        });\n        clone.attrs.dragBoundFunc=function (pos) {\n          return {\n            x: pos.x,\n            y: pos.y,\n          };\n        };\n        clone.attrs.isGrouped=0;\n        this.shapes.push(clone.attrs,); \n         \n      }\n      //layer.batchDraw(); \n      \n    },\n    */\n    \n    //RemoveShape(shape)\n    Remove(shape){\n      //let shape=ContextMenu.props.ConcernedShape;\n      if(shape.attrs.className==\"Line\"){\n        let grp=this.groups.find((r)=>r.id===shape.attrs.id);\n        const length=grp.shapes_g.length;\n        for(let i=0;i<length;i++){\n          grp.shapes_g[i].dragBoundFunc= dragFunc;\n          grp.shapes_g[i].isGrouped=0;\n          this.shapes.push(grp.shapes_g[i],);\n        }\n        this.eraseNodefromTransformer(\"lineTransformer\");\n        this.groups.splice(this.groups.indexOf(grp),1);\n        shape.getParent().destroy();\n\n        //We give to the circle (representing center of shapes) a default position\n        if(this.groups[0]!=undefined){\n          this.center.x=this.groups[0].line.x;\n          this.center.y=this.groups[0].line.y;\n        } else if(this.shapes[0]!=undefined){\n          this.center.x=this.shapes[0].x;\n          this.center.y=this.shapes[0].y;\n        }\n        this.center.opacity=0;\n        \n      }else if(shape.attrs.className==\"positionPoint\"){\n        let line=shape.getParent().attrs.line;\n        let target_positionPoint=line.positionPoints.find((r)=>r.id===shape.attrs.id);\n        let index=line.freeDistances.indexOf(shape.attrs.distance_to_line_center);\n        console.log(line.positionPoints);\n        if(line.keepDistribution!=1 && index!=-1){\n          line.freeDistances.splice(index,1);\n          line.positionPoints.splice(line.positionPoints.indexOf(target_positionPoint),1)\n        }\n      }\n      else{\n        let res=this.findShape(shape.attrs.id)\n        let shape_data=res.shape_data;\n        let grp_id=res.grp_id;\n        if(shape_data!=undefined){\n        if(grp_id!='-1'){\n        //let shape_data=this.shapes.find(i => i.id ===shape.attrs.id);\n        let grp=this.groups.find((r)=>r.id===grp_id);\n          grp.line.freeDistances.push(grp.line.occupiedDistances[grp.shapes_g.indexOf(shape_data)],)\n          grp.line.occupiedDistances.splice(grp.shapes_g.indexOf(shape_data),1)\n          \n          grp.shapes_g.splice(grp.shapes_g.indexOf(shape_data),1);\n          this.updateOccupiedDistance(grp.id);\n          \n          this.updateAllPosInGrp(grp.id);\n          \n         console.log(grp.line.positionPoints)\n      \n        } else{\n          this.eraseNodefromTransformer(\"shapeTransformer\");\n          this.shapes.splice(this.shapes.indexOf(shape_data),1);\n          //We give to the circle (representing center of shapes) a default position\n          if(this.groups[0]!=undefined){\n            this.center.x=this.groups[0].line.x;\n            this.center.y=this.groups[0].line.y;\n          } else if(this.shapes[0]!=undefined){\n            this.center.x=this.shapes[0].x;\n            this.center.y=this.shapes[0].y;\n          }\n          this.center.opacity=0;\n        }\n        shape.destroy();\n        }\n      }\n    },\n    /*\n    RemoveAll(){\n      let shape=ContextMenu.props.ConcernedShape;\n      if(shape.className==\"Line\"){\n        let grp=this.groups.find((r)=>r.id===shape.attrs.id);\n        while(grp.shapes_g.length!=0){\n          grp.shapes_g[0].dragBoundFunc= dragFunc;\n          grp.shapes_g.splice(0,1);\n        }\n        this.eraseNodefromTransformer(\"lineTransformer\");\n        this.groups.splice(this.groups.indexOf(grp),1);\n        shape.getParent().destroy();\n\n        //We give to the circle (representing center of shapes) a default position\n        if(this.groups[0]!=undefined){\n          this.center.x=this.groups[0].line.x;\n          this.center.y=this.groups[0].line.y;\n        } else if(this.shapes[0]!=undefined){\n          this.center.x=this.shapes[0].x;\n          this.center.y=this.shapes[0].y;\n        }\n        \n      }else{\n        return;\n      }\n    },\n    */\n\n    findShape(id){ \n      let shape_data=this.shapes.find(i => i.id ===id);\n      let grp_id='-1'; // return grp_id=-1 if the shape doesn't belong to attached group.\n      let isFunded=true;\n      if(shape_data==undefined){\n        isFunded=false;\n      }\n      let i=0;\n      while(!isFunded){\n        if(i<this.groups.length){\n          shape_data=this.groups[i].shapes_g.find(i => i.id === id);\n        if(shape_data==undefined){\n          isFunded=false;\n        }else{\n          grp_id=this.groups[i].id; \n          isFunded=true;\n        }\n        i++;\n        }else{        \n          isFunded=true;\n        }\n      }\n      return {shape_data, grp_id}\n    },\n\n    //detach a shape from its line.\n     DetachShape(shape,target_x,target_y){\n      \n      \n      const added_distance=this.lengthToCapture+5;\n      let grp=this.groups.find((r)=>r.shapes_g.indexOf(shape)!=-1);\n      let i=grp.shapes_g.indexOf(shape);\n      \n      shape.dragBoundFunc= dragFunc;\n\n      let coord_y1=grp.line.y-grp.line.points[4]*(1/2)*grp.line.scaleX*Math.sin(grp.line.rotation*(Math.PI/180));\n      let coord_x2=grp.line.x+grp.line.points[4]*(1/2)*grp.line.scaleX*Math.cos(grp.line.rotation*(Math.PI/180));\n      let coord_y2= grp.line.y+grp.line.points[4]*(1/2)*grp.line.scaleX*Math.sin(grp.line.rotation*(Math.PI/180));\n      let coord_x1=grp.line.x-grp.line.points[4]*(1/2)*grp.line.scaleX*Math.cos(grp.line.rotation*(Math.PI/180));\n      let a=(coord_y2-coord_y1)/(coord_x2-coord_x1);\n      //let b=grp.line.y-a*grp.line.x;\n      let b=shape.x*(1/a)+shape.y;\n      if (grp.line.rotation<0 && grp.line.rotation>-45){\n        \n        shape.x=shape.x+Math.sign(shape.y-target_y)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } else if (grp.line.rotation<=-45 && grp.line.rotation>-90){\n        \n        shape.x=shape.x+Math.sign(shape.x-target_x)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      }\n      \n      else if(grp.line.rotation<-90 && grp.line.rotation>-135){\n        shape.x=shape.x+Math.sign(shape.x-target_x)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } \n      else if(grp.line.rotation<=-135 && grp.line.rotation>-180){\n        shape.x=shape.x-Math.sign(shape.y-target_y)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } \n      \n      else if( grp.line.rotation>135 && grp.line.rotation<180){\n        \n        shape.x=shape.x-Math.sign(shape.y-target_y)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } else if( grp.line.rotation>90 && grp.line.rotation<=135){\n        \n        shape.x=shape.x-Math.sign(shape.x-target_x)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } else if( grp.line.rotation>45 && grp.line.rotation<=90){\n        \n        shape.x=shape.x-Math.sign(shape.x-target_x)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } else if( grp.line.rotation>0 && grp.line.rotation<=45){\n        \n        shape.x=shape.x+Math.sign(shape.y-target_y)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } \n      else if(grp.line.rotation==-90){\n        shape.x=shape.x-Math.sign(shape.x-target_x)*added_distance\n      } else if(grp.line.rotation==90){\n        shape.x=shape.x+Math.sign(shape.x-target_x)*added_distance\n      } else if(grp.line.rotation==180 || grp.line.rotation==-180){\n        shape.y=shape.y-Math.sign(shape.y-target_y)*added_distance\n      } else if(grp.line.rotation==0){\n        shape.y=shape.y-Math.sign(shape.y-target_y)*added_distance\n      } \n      //shape.rotation=shape.rotation+shape.personalRotation;\n      shape.isGrouped=0;\n      this.shapes.push(shape,)\n      this.center.x=shape.x;\n      this.center.y=shape.y;\n      grp.line.freeDistances.push(grp.line.occupiedDistances[i]);\n      grp.line.occupiedDistances.splice(i,1);\n      grp.shapes_g.splice(i,1);\n      //grp.line.positionPoints.splice(i,1)\n      \n      this.updateOccupiedDistance(grp.id)\n      this.updateAllPosInGrp(grp.id)\n      this.updateNaration(grp)\n\n      this.eraseNodefromTransformer(\"shapeTransformer\");\n    \n    },\n    /*\n    DetachShape(shape){\n      \n      \n      const added_distance=this.lengthToCapture+5;\n      let grp=this.groups.find((r)=>r.shapes_g.indexOf(shape)!=-1);\n      let i=grp.shapes_g.indexOf(shape);\n      \n      shape.dragBoundFunc= dragFunc;\n\n      let coord_y1=grp.line.y-grp.line.points[4]*(1/2)*grp.line.scaleX*Math.sin(grp.line.rotation*(Math.PI/180));\n      let coord_x2=grp.line.x+grp.line.points[4]*(1/2)*grp.line.scaleX*Math.cos(grp.line.rotation*(Math.PI/180));\n      let coord_y2= grp.line.y+grp.line.points[4]*(1/2)*grp.line.scaleX*Math.sin(grp.line.rotation*(Math.PI/180));\n      let coord_x1=grp.line.x-grp.line.points[4]*(1/2)*grp.line.scaleX*Math.cos(grp.line.rotation*(Math.PI/180));\n      let a=(coord_y2-coord_y1)/(coord_x2-coord_x1);\n      //let b=grp.line.y-a*grp.line.x;\n      let b=shape.x*(1/a)+shape.y;\n      if (grp.line.rotation<0 && grp.line.rotation>-90){\n        \n        shape.x=shape.x-added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } else if(grp.line.rotation<-90){\n        shape.x=shape.x-added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } else if( grp.line.rotation>0 && grp.line.rotation<180){\n        \n        shape.x=shape.x+added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } \n      else if(grp.line.rotation==-90){\n        shape.x=shape.x+added_distance\n      } else if(grp.line.rotation==90){\n        shape.x=shape.x-added_distance\n      } else if(grp.line.rotation==180 || grp.line.rotation==-180){\n        shape.y=shape.y-added_distance\n      } else if(grp.line.rotation==0){\n        shape.y=shape.y+added_distance\n      } \n      //shape.rotation=shape.rotation+shape.personalRotation;\n      shape.isGrouped=0;\n      this.shapes.push(shape,)\n      this.center.x=shape.x;\n      this.center.y=shape.y;\n      grp.line.freeDistances.push(grp.line.occupiedDistances[i]);\n      grp.line.occupiedDistances.splice(i,1);\n      grp.shapes_g.splice(i,1);\n      grp.line.positionPoints.splice(i,1)\n      \n      this.updateOccupiedDistance(grp.id)\n      this.updateAllPosInGrp(grp.id)\n    \n    },\n    */\n    /*\n\n    //called when the button \"Detach Shape\" is clicked\n    DetachShapeButtonAction(){\n      let shape= ContextMenu.props.ConcernedShape;\n      if(shape.attrs.className==\"Line\"){\n        let shapes_g=shape.getParent().attrs.shapes_g;\n        while(shapes_g.length!=0){\n          this.DetachShape(shapes_g[0]);\n        }\n      }else{\n        let shape_data=this.shapes.find(i => i.id ===shape.attrs.id);\n        let isFunded=true;\n        if(shape_data==undefined){\n          isFunded=false;\n        }\n        let i=0;\n        while(!isFunded){\n          if(i<this.groups.length){\n            shape_data=this.groups[i].shapes_g.find(i => i.id === shape.attrs.id);\n          if(shape_data==undefined){\n            isFunded=false;\n          }else{\n            isFunded=true;\n          }\n          i++;\n          }else{        \n            isFunded=true;\n          }\n        }\n        this.DetachShape(shape_data)\n      }\n    },\n\n    //called when the button \"keep/liberate distribution\" is clicked.\n    KeepDistribution(){\n      let grp=this.groups.find(i => i.id === ContextMenu.props.ConcernedShape.attrs.id);\n      let line=grp.line;\n      if(line==undefined){\n        return;\n      }else{\n        if(line.keepDistribution){\n          line.keepDistribution=false;\n          for (let i=0;i<grp.shapes_g.length;i++){\n            grp.shapes_g[i].distance_to_line_center=line.occupiedDistances[i]\n          }\n          line.freeDistances=[];\n\n          line.stroke='blue'\n          grp.line.keepDistanceButtonText=\"Keep Distribution\";\n          //ContextMenu.props.ConcernedShape.attrs.keepDistanceButtonText=\"Keep Distribution\";\n        }else{\n          line.keepDistribution=true;\n          for (let i=0;i<grp.shapes_g.length;i++){\n            line.occupiedDistances[i]=grp.shapes_g[i].distance_to_line_center;\n          }\n          line.stroke='black'\n          grp.line.keepDistanceButtonText=\"Liberate Distribution\";\n          //ContextMenu.props.ConcernedShape.attrs.keepDistanceButtonText=\"Liberate Distribution\";\n          this.updateOccupiedDistance(line.id);\n          this.updateAllPosInGrp(line.id);\n        }\n      }\n    },\n    */\n    createNewShape(shape){\n      if(shape.attrs.className==\"Line\"){\n        \n        this.max_id_figures=this.max_id_figures+1;\n\n          let clone=shape.getParent().clone({\n            id: ''+this.max_id_figures,\n            name: \"group\"+this.max_id_figures,\n            shapes_g:[],\n          })\n          clone.attrs.line.id=''+this.max_id_figures;\n          clone.attrs.line.x=shape.getStage().getPointerPosition().x;\n          clone.attrs.line.y=shape.getStage().getPointerPosition().y;\n          clone.attrs.line.draggable=true;\n          this.groups.push(clone.attrs,)\n          \n        \n      }else{\n        \n        this.max_id_figures=this.max_id_figures+1\n        let clone=shape.clone({\n          id: ''+this.max_id_figures,\n          draggable: true,\n        })\n        clone.attrs.isGrouped=0;\n        this.shapes.push(clone.attrs,);\n      }\n      \n\n    },\n    \n  \n  eraserAction(e){\n    this.Remove(e.target);\n    \n  },\n  unshowSelectedShape(e){\n    if(e.target.attrs.className==\"Line\" && this.eraseMode==0){\n      e.target.opacity(0.5)\n    }\n    else if(e.target.attrs.className==\"Line\" && this.eraseMode==1){\n      if(e.target.attrs.keepDistribution==1){\n        e.target.stroke(\"rgb(48,48,48)\")\n      }else{\n        e.target.stroke(\"blue\")\n      }\n    }\n    else if(e.target.attrs.className==\"positionPoint\" && this.eraseMode==1){\n      if(e.target.getParent().attrs.line.keepDistribution!=1){\n        e.target.strokeWidth(0)\n      }\n    }\n    else if(this.eraseMode==1){\n      e.target.strokeWidth(0)\n    }\n  },\n  showSelectedShape(e){\n    if(e.target.attrs.className==\"Line\" && this.eraseMode==0){\n      e.target.opacity(1)\n    }\n    else if(e.target.attrs.className==\"Line\" && this.eraseMode==1){\n      e.target.stroke('rgb(200, 59, 218)')\n    }\n    else if(e.target.attrs.className==\"positionPoint\" && this.eraseMode==1){\n      let line=e.target.getParent().attrs.line;\n      if(line.freeDistances.indexOf(e.target.attrs.distance_to_line_center)!=-1){\n        if(line.keepDistribution!=1){\n          e.target.stroke('rgb(200, 59, 218)')\n          e.target.strokeWidth(3)\n        }\n      }\n    }\n    else if(this.eraseMode==1){\n      e.target.stroke('rgb(200, 59, 218)')\n      e.target.strokeWidth(3)\n    }\n    /*\n    let shape=e.target;\n    if(this.eraseMode==1){\n    let shape_data=this.shapes.find(i => i.id ===shape.attrs.id);\n    let isFunded=true;\n    if(shape_data==undefined){\n      isFunded=false;\n      let i=0;\n      while(!isFunded){\n        if(i<this.groups.length){\n          shape_data=this.groups[i].shapes_g.find(i => i.id === shape.attrs.id);\n        if(shape_data==undefined){\n          isFunded=false;\n          i++;\n        }else{\n          isFunded=true;\n        }\n        }else{        \n          isFunded=true;\n        }\n      }\n    }\n    if (shape_data!=undefined){\n      shape_data.opacity=0.3\n    }\n    */\n\n  },\n  editText(e){\n    //let valuey=document.getElementById(\"stage\").style.top+e.target.y()\n    //let valuex=document.getElementById(\"stage\").style.left+e.target.x()\n    let stageBox=e.target.getStage().attrs.container.getBoundingClientRect();\n    document.getElementById(\"input\").style.top=stageBox.y+e.target.getAbsolutePosition().y+'px';\n    document.getElementById(\"input\").style.left=stageBox.x+e.target.getAbsolutePosition().x-document.getElementById(\"input\").size*5+'px';\n    document.getElementById(\"input\").style.display=\"initial\"\n    this.editedText=e.target\n  },\n  updateText(e){\n    let shape=this.shapes.find(i => i.id ===this.editedText.attrs.id);\n    let isFunded=true;\n    if(shape==undefined){\n      isFunded=false;\n    }\n    let i=0;\n    while(!isFunded){\n      if(i<this.groups.length){\n        shape=this.groups[i].shapes_g.find(i => i.id === this.editedText.attrs.id);\n      if(shape==undefined){\n        isFunded=false;\n      }else{\n        isFunded=true;\n      }\n      i++;\n      }else{        \n        isFunded=true;\n      }\n    }\n    if(shape!=undefined){\n    let last_width;\n    let last_height;\n    let diff_width;\n    let diff_height;\n\n    last_width=this.editedText.width();\n    last_height=this.editedText.height();\n\n    shape.text=e.target.value;\n\n    this.editedText.text(e.target.value);\n    diff_width=this.editedText.width()-last_width;\n    diff_height=this.editedText.height()-last_height;\n\n    \n    shape.offsetX=shape.offsetX+diff_width/2\n    shape.offsetY=shape.offsetY+diff_height/2\n    shape.length_x=this.editedText.width()\n    shape.length_y=this.editedText.height()\n    document.getElementById(\"input\").style.display=\"none\"\n    }\n\n  },\n  updateNaration(grp){\n      let text=\"<strong>Substrate</strong> \"\n      \n      text=text+\"- <mark class='blue'> StickyLine </mark><br>\";\n      \n      text=text+\"Relation: <i>alignement and distance with</i>:\";\n      for(let j=0;j<grp.shapes_g.length;j++){\n        text=text+\"<br>\"+\"- \"+grp.shapes_g[j].className\n      }\n      text=text+\"<br>Distance kept in memory:\"\n      //+grp.line.occupiedDistances+\",<mark class='green'>\"+grp.line.freeDistances+\"</mark>\";\n      for(let i=0;i<grp.line.occupiedDistances.length;i++){\n        text=text+grp.line.occupiedDistances[i].toFixed(1)+\",\";\n      }\n      text=text+\"<mark class='green'>\"\n      for(let i=0;i<grp.line.freeDistances.length-1;i++){\n        text=text+grp.line.freeDistances[i].toFixed(1)+\",\";\n      }if(grp.line.freeDistances.length>0){\n      text=text+grp.line.freeDistances[grp.line.freeDistances.length-1].toFixed(1);\n      }\n      text=text+\"</mark>\"\n      this.$emit('explain',{origin:\"Instrument - Discoverability<br><mark class='pink'> The instrument should reveal the possible action that are available to the user. </mark>\",text:text});\n      \n  },\n  \n},\n};\n\n</script>\n<style>\n#DiscoverabilityDemo{\n  cursor: default\n}\n#activeReuseSubstrate{\n  position:absolute;\n  display: none;\n  top: 0px;\n  left: 0px;\n  width: 60px;\n  background-color: white;\n  box-shadow: 0 0 5px grey;\n  border-radius: 3px;\n}\n#center_menu{\n  position: absolute;\n  display: none;\n  top: 0px;\n  left: 0px;\n  width: 60px;\n  background-color: white;\n  box-shadow: 0 0 5px grey;\n  border-radius: 3px;\n}\ninput{\n  position:absolute;\n  display: none;\n  top:0px;\n  left:0px; \n}\n#eraser{\n  cursor:pointer;\n}\n</style> ","import { render } from \"./DiscoverabilityDemo.vue?vue&type=template&id=7f837aa2\"\nimport script from \"./DiscoverabilityDemo.vue?vue&type=script&lang=js\"\nexport * from \"./DiscoverabilityDemo.vue?vue&type=script&lang=js\"\n\nimport \"./DiscoverabilityDemo.vue?vue&type=style&index=0&id=7f837aa2&lang=css\"\n\nimport exportComponent from \"/Users/junhangyu/Desktop/PE code/github/teachingApp/node_modules/vue-loader/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render]])\n\nexport default __exports__","<template>\n    <div @mousedown=\"updateNaration()\"></div>\n\n    <div id=\"app\">\n        <div class=\"container\">\n            <video width=\"260\" controls src=\"@/assets/express-ins.mp4\"></video>\n\n        </div>\n    </div>\n</template>\n\n\n\n<script>\nexport default {\n    name: 'ExpressivityDemo',\n\n\n    methods: {\n\n        updateNaration() {\n            //let text;\n            this.$emit('explain', { origin: \"Instrument - Expressivity<br><mark class='blue'> The substrate supports user customization and updates itself. </mark>\" });\n        }\n    }\n}\n</script>","import { render } from \"./ExpressivityDemo.vue?vue&type=template&id=2d20a443\"\nimport script from \"./ExpressivityDemo.vue?vue&type=script&lang=js\"\nexport * from \"./ExpressivityDemo.vue?vue&type=script&lang=js\"\n\nimport exportComponent from \"/Users/junhangyu/Desktop/PE code/github/teachingApp/node_modules/vue-loader/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render]])\n\nexport default __exports__","<template>\n     <div id=\"app\">\n        <div class=\"container\">\n            <video width=\"300\" controls src=\"@/assets/express-sub.mp4\"></video>\n        \n        </div>\n    </div>\n</template>\n\n\n\n<script>\nexport default {\n    name: 'ExpressivitySubstrateDemo',\n}\n</script>","import { render } from \"./ExpressivitySubstrateDemo.vue?vue&type=template&id=f89b050a\"\nimport script from \"./ExpressivitySubstrateDemo.vue?vue&type=script&lang=js\"\nexport * from \"./ExpressivitySubstrateDemo.vue?vue&type=script&lang=js\"\n\nimport exportComponent from \"/Users/junhangyu/Desktop/PE code/github/teachingApp/node_modules/vue-loader/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render]])\n\nexport default __exports__","import { render } from \"./HCPartnershipsTableView.vue?vue&type=template&id=6790c700\"\nimport script from \"./HCPartnershipsTableView.vue?vue&type=script&lang=js\"\nexport * from \"./HCPartnershipsTableView.vue?vue&type=script&lang=js\"\n\nimport \"./HCPartnershipsTableView.vue?vue&type=style&index=0&id=6790c700&lang=css\"\n\nimport exportComponent from \"/Users/junhangyu/Desktop/PE code/github/teachingApp/node_modules/vue-loader/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render]])\n\nexport default __exports__","<template>\n\n<!--Vue components for the playground-->\n\n<div @click=\"HideContextMenu\" id=\"playground\">\n  <ToolBar id=\"toolbar\" :height=\"100\" :width=\"400\" \n  @need_new_shape=\"createNewShape\" @eraser_is_selected=\"switchEraseMode\"></ToolBar>\n  <v-stage\n    ref=\"stage\"\n    id=\"stage\"\n    :config=\"stageSize\"\n    @dragmove=\"update\"\n    @mousedown=\"handleTransformation\"\n    @touchstart=\"handleTransformation\"\n    @fusion=\"makeGroup\"\n    @contextMenu=\"DisplayContextMenu\"\n  >\n    <v-layer ref=\"layer\">\n      <v-group ref=\"groups\" v-for=\"step in groups\" :key=\"step.id\" :config=\"step\">\n      \n      \n      \n        <v-rect\n        v-for=\"item in step.shapes_g.filter(i=>i.className=='Rect')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        \n       \n        @transformend=\"updateTransformedShape\"\n        @dragend= \"updatePosInGrp($event,step.id) \"\n        @dragmove=\"onDragging\"\n        @dragstart=\" initializeDragging\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n        />\n        <v-circle\n        v-for=\"item in step.shapes_g.filter(i=>i.className=='Circle')\"\n        :key=\"item.id\"\n        :config=\"item\"\n\n        @transformend=\"updateTransformedShape\"\n        @dragend=\"updatePosInGrp($event,step.id)\"\n        @dragmove=\"onDragging\"\n        @dragstart=\" initializeDragging\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n        />\n        <v-image\n        v-for=\"item in step.shapes_g.filter(i=>i.className=='Image')\"\n        :key=\"item.id\"\n        :config=\"item\"\n\n        @transformend=\"updateTransformedShape\"\n        @dragend=\"updatePosInGrp($event,step.id)\"\n        @dragmove=\"onDragging\"\n        @dragstart=\" initializeDragging\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n        />\n        <v-text\n        v-for=\"item in step.shapes_g.filter(i=>i.className=='Text')\"\n        :key=\"item.id\"\n        :config=\"item\"\n\n        @transformend=\"updateTransformedShape\"\n        @dragend=\"updatePosInGrp($event,step.id)\"\n        @dragmove=\"onDragging\"\n        @dragstart=\" initializeDragging\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n\n        @dblclick=\"editText\"\n        />\n        <v-regular-polygon\n        v-for=\"item in step.shapes_g.filter(i=>i.className=='Triangle')\"\n        :key=\"item.id\"\n        :config=\"item\"\n\n        @transformend=\"updateTransformedShape\"\n        @dragend=\"updatePosInGrp($event,step.id)\"\n        @dragmove=\"onDragging\"\n        @dragstart=\" initializeDragging\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n        />\n\n\n        <v-rect\n          v-for=\"item in step.ghosts.filter(i=>i.className=='Rect')\"\n          :key=\"item.id\"\n          :config=\"item\"\n        />\n        <v-circle\n          v-for=\"item in step.ghosts.filter(i=>i.className=='Circle')\"\n          :key=\"item.id\"\n          :config=\"item\"\n        />\n        <v-image\n          v-for=\"item in step.ghosts.filter(i=>i.className=='Image')\"\n          :key=\"item.id\"\n          :config=\"item\"\n        />\n        <v-text\n          v-for=\"item in step.ghosts.filter(i=>i.className=='Text')\"\n          :key=\"item.id\"\n          :config=\"item\"\n        />\n        <v-regular-polygon\n          v-for=\"item in step.ghosts.filter(i=>i.className=='Triangle')\"\n          :key=\"item.id\"\n          :config=\"item\"\n        />\n\n        <v-line \n        :key=\"step.line.id\"\n        :config=\"step.line\"\n        @transformend=\"updateTransformedShape\"\n        @dragmove=\"updateGrp($event)\"\n        @mouseout=\"unshowSelectedShape\"\n        @mouseenter=\"showSelectedShape\"\n        />\n\n        <v-circle\n          v-for=\"item in step.line.positionPoints\"\n          :key=\"item.id\"\n          :config=\"item\"\n          \n          @mouseenter=\"showSelectedShape\"\n          @mouseout=\"unshowSelectedShape\"\n          @dragend=\"updateFreePositionInGrp($event,step.id)\" \n        />\n      </v-group>\n\n      <v-rect\n        v-for=\"item in shapes.filter(i=>i.className=='Rect')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragmove=\"updatePos\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"  \n      />\n      \n      <v-circle\n        v-for=\"item in shapes.filter(i=>i.className=='Circle')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragmove=\"updatePos\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\" \n      />\n      \n      <v-image\n        v-for=\"item in shapes.filter(i=>i.className=='Image')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragmove=\"updatePos\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n      />\n      \n      <v-text\n        v-for=\"item in shapes.filter(i=>i.className=='Text')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragmove=\"updatePos\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n        \n        @dblclick=\"editText\"\n      />\n\n      <v-regular-polygon\n        v-for=\"item in shapes.filter(i=>i.className=='Triangle')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @transformend=\"updateTransformedShape\"\n        @dragmove=\"updatePos\"\n        @mouseenter=\"showSelectedShape\"\n        @mouseout=\"unshowSelectedShape\"\n      />\n      \n      \n      <v-transformer  v-for=\"item in transformers\" :key=\"item.id\" :config=\"item\"/>\n      <v-circle :key=\"center.id\" :config=\"center\"\n      @dragend=\"ChangeCenter\"\n      @click=\"DisplayCenterMenu\"\n      />\n    </v-layer>\n  </v-stage>\n  \n  <div id=\"active\">\n    <ContextMenu :menu-of-stage=\"isStageOnlySelected\" :menu-of-line=isALineSelected :menu-of-grouped-shape=isAGroupedShapeSelected :keep-distance-button-text=\"this.keepDistanceButtonText\" \n    @keepdistance-button=\"switchStickylineMode\"\n    @copy-button=\"Copy\" @copy-all-button=\"CopyAll\" @past-button=\"Past\"></ContextMenu>\n  </div>\n\n  <div id=\"center_menu\">\n    <CenterMenu :defaultAlignment=\"this.selectedShapeAlignment\" @center-button=\"ChangeAlignCenter\"></CenterMenu>\n  </div>\n\n  <input type=\"text\" id=\"input\" \n        size=\"10\" value=\"a text\"\n       @keyup.enter=\"updateText\"\n  >\n\n</div>\n</template>\n\n<script>\nimport ContextMenu from \"@/components/interactive-components-for-canvas/ContextMenu.vue\"\nimport CenterMenu from \"@/components/interactive-components-for-canvas/CenterMenu.vue\"\nimport ToolBar from \"@/components/interactive-components-for-canvas/ToolBar.vue\";\n\n//drag bound func to prevent the objects from going outside the stage\nconst dragFunc=function (pos) {\n  let width=this.getStage().width();\n  let height=this.getStage().height();\n  let strokeSize=10\n    if(pos.x>width-strokeSize && pos.y>height-strokeSize){\n      return{\n        x: width-strokeSize,\n        y: height-strokeSize,\n      }\n    } else if(pos.x>width-strokeSize && pos.y<strokeSize){\n      return{\n        x: width-strokeSize,\n        y: strokeSize,\n      }\n    } else if(pos.y>height-strokeSize && pos.x<strokeSize){\n      return{\n        x: strokeSize,\n        y: height-strokeSize,\n      }\n    } else if(pos.x<strokeSize && pos.y<strokeSize){\n      return{\n        x: strokeSize,\n        y: strokeSize,\n      }\n    } else if(pos.x<strokeSize){\n      return{\n        x: strokeSize,\n        y: pos.y,\n      }\n    }else if(pos.y<strokeSize){\n      return{\n        x: pos.x,\n        y: strokeSize,\n      }\n    }else if(pos.x>width-strokeSize){\n      return{\n        x: width-strokeSize,\n        y: pos.y,\n      }\n    }else if(pos.y>height-strokeSize){\n      return{\n        x: pos.x,\n        y: height-strokeSize,\n      }\n    } else{\n      return {\n        x: pos.x,\n        y: pos.y,\n      };\n    }\n};\n\n\nexport default {\n  props:{\n    width:{\n      type: Number,\n      default:window.innerWidth,\n    },\n    height:{\n      type: Number,\n      default:window.innerHeight,\n    }\n  },\n  components:{\n    ContextMenu,\n    CenterMenu,\n    ToolBar,\n},\n\n  //Please read commentaries in order to undersand all parameters.\n  data() {\n    return {\n      stageSize: {\n        width: this.width,\n        height: this.height,\n      },\n\n      lengthToCapture:10, //distance btw a shape and a stickyline from which the shape is considered as captured by the stickyline.\n      lengthToDetach:15, //added distance between a shape and a stickyline when the shape is detached from the stickyline.\n      editedText:null, //When we dbl click one a text to change it, this parameter is updated by taking data of the target text.\n\n      eraseMode:0, //eraseMode=1 if the eraser is used, =0 otherwise.\n\n      selectedShapeAlignment:'', //give the position of the selected object's center (Top, Middle or Bottom)\n\n      neighbour:null, //closest neighbour of a selected shape which is attached to a stickyline.\n      dist_with_neighbour:null, //distance between a selected attached shape and his closest neighbour\n      \n      needMenu: 'initial', //say if the context menu has to be \"active\" or not.\n      isALineSelected:false, //say if a stickyline is selected or not\n      isAGroupedShapeSelected:false, //say if a shape attached to a stickyline is selected\n      isStageOnlySelected: false,//say if the selection is done on no shape or stickylines\n      \n      keepDistanceButtonText:\"Liberate Distribution\",//text which will appear on the button corresponding to the management of the distribution\n      max_id_figures: 6, //max id among ids of shapes and stickylines since the canvas exist.\n\n      //groups of shapes (a group contains a line with shapes on it)   \n      groups:[{\n        name: \"group\",\n        className: \"Group\",\n        id: '6',\n        x:0,\n        y:0,\n        offsetX:0,\n        offsetY:0,\n        rotation: 0,\n        draggable: false,\n        shapes_g:[], //list of shapes that are on the line\n        ghosts:[],/*Shadow of attached shapes created to show to the user the ouput \n        when it is dragging a shape on a stickyline with homogenous and equal distribution (ie keepDistribution=true)*/\n        aShapeHasBeenDetach:0, /*=1 if a shape has been detach from the line when dragging it.\n        It is used to not update a detached shape with the method updatePosInGrp (see the method in question)*/\n        line:{\n          x:200,\n          y:200,\n          points: [0, 0, 0, 0, 300, 0],\n          positionPoints:[],/*List of \"position points\".A \"position point\" is a little circle (see the template positionPoint) \n          which shows a position (free or occupied) determined by a distance from the stickyline's center\n          (see occupiedDistances and freeDistances).\n          */\n          strokeWidth: 10,\n          rotation: 0,\n          tension:0,\n          closed: true,\n          draggable: true,\n          scaleX:1,\n          scaleY:1,\n          opacity:0.5,\n          offset:{\n            x:150,\n            y:0,\n          },\n          name: \"ligne\",\n          className: \"Line\",\n          stroke: 'rgb(48,48,48)',\n          id:'6',\n          keepDistribution: true, /*if true, the distribution on the line is homogeneous and equal.\n          If not, shapes can be move freely on the line and distances are kept in memory (see below)*/\n          freeDistances:[], /*distance with the center of the line that can be taken by other shapes (if keepDistribution=false).\n          It means that when we a new shape is attached, it will go to the position corresponding to\n          one of the distances in freeDistances*/\n          occupiedDistances:[], //distance with the center of the line already \"taken\" by shapes on the line.       \n          keepDistanceButtonText:\"Liberate Distribution\",/*text which will appear \n          on the button of the context menu corresponding to the management of the distribution:*/\n      \n          defaultAlignment:\"Middle\",//text which describe the position of the center (Top,Middle or Bottom)\n          dragBoundFunc: dragFunc,//function which determine how the line can be dragged\n        },\n      },\n      {\n        name: \"group2\",\n        className: \"Group\",\n        id: '7',\n        x:0,\n        y:0,\n        offsetX:0,\n        offsetY:0,\n        rotation: 0,\n        draggable: false,\n        shapes_g:[],\n        ghosts:[],\n        line:{\n          x:500,\n          y:300,\n          points: [0, 0, 0, 0, 300, 0],\n          positionPoints:[],\n          strokeWidth: 10,\n          rotation: 0,\n          tension:0,\n          closed: true,\n          draggable: true,\n          scaleX:1,\n          scaleY:1,\n          opacity:0.5,\n          offset:{\n            x:150,\n            y:0,\n          },\n          name: \"ligne\",\n          className: \"Line\",\n          stroke: 'rgb(48,48,48)',\n          id:'7',\n          distShapesToCenter:[],\n          keepDistribution: true,\n          freeDistances:[],\n          occupiedDistances:[],\n          keepDistanceButtonText:\"Liberate Distribution\",\n          defaultAlignment:\"Middle\",\n          dragBoundFunc: dragFunc,\n        },\n      }],\n\n      //transfomers which allow to modify size and rotation of shapes and stickyline\n      transformers:[\n        //transformer for stickyline\n        {\n          id: 'lineTransformer',\n          enabledAnchors: ['middle-left', 'middle-right'],\n          flipEnabled: false, // in order to not have a rotation of the transformer which lead to problem related to shapes position on a line\n          nodes: [],\n\n        },\n        //transformer for shape\n        {\n          id: 'shapeTransformer',\n          nodes: [],\n        }\n      ],\n\n      //Shapes that are on the stage.\n      shapes: [\n        {\n          rotation: 0,\n          id: '1',\n          x: 100,\n          y: 10,\n          width: 130,\n          height: 100,\n          scaleX: 1,\n          scaleY: 1,\n          opacity:1,\n          strokeWidth: 0,\n          stroke: 'black',\n          fill: 'red',\n          name: 'rect1',\n          draggable: true,\n          className:\"Rect\",\n          isGrouped: 0, //if =0 the shape is not attached to a stickyline. if=1, it does.\n          offsetX:130/2,\n          offsetY:0,\n          /*When it is on a line, a shape can be rotate by the user independently from the line.\n          To keep the independant rotation of the attached shape, we add the parameter \"personalRotation\".\n          So, when the shape is attached, its final rotation is the sum of this parameter with the rotation of the line.\n          */\n          personalRotation:0, \n          centerPosition:'Top',\n          dragBoundFunc: dragFunc\n          \n        },\n        \n        {\n          rotation: 0,\n          id:'2',\n          x: 150,\n          y: 150,\n          width: 100,\n          height: 100,\n          scaleX: 1,\n          scaleY: 1,\n          opacity:1,\n          strokeWidth: 0,\n          stroke: 'black',\n          fill: 'green',\n          name: 'rect2',\n          draggable: true,\n          className:\"Rect\",\n          isGrouped: 0,\n          dragBoundFunc: dragFunc,\n          offsetX: 100/2,\n          offsetY: 0,\n          /*When it is on a line, a shape can be rotate by the user independently from the line.\n          To keep the independant rotation of the attached shape, we add the parameter \"personalRotation\".\n          So, when the shape is attached, is final rotation is the sum of this parameter with the rotation of the line.\n          */\n          personalRotation:0, \n          centerPosition:'Top',\n        },\n\n        {\n          rotation:0,\n          x: 300,\n          y: 500,\n          scaleX:1,\n          scaleY:1,\n          offsetX: 0,\n          offsetY: -50,\n          radius: 50,\n          opacity:1,\n          fill: 'orange',\n          strokeWidth: 0,\n          stroke: 'black',\n          draggable:true,\n          isGrouped: 0,\n          className:\"Circle\",\n          /*When it is on a line, a shape can be rotate by the user independently from the line.\n            To keep the independant rotation of the attached shape, we add the parameter \"personalRotation\".\n            So, when the shape is attached, is final rotation is the sum of this parameter with the rotation of the line.\n            */\n          personalRotation:0, \n          id:'3',\n          dragBoundFunc: dragFunc,\n          centerPosition:'Top',\n        },\n\n        {\n          text: 'A text',\n          rotation: 0,\n          x: 400,\n          y: 200,           \n          scaleX:1,\n          scaleY:1,\n          offsetY:0,\n          offsetX: 36,\n          opacity:1,\n          /*I cannot use height and width because otherwise they will fix the height\n          and the width of the text box: We want a flexible box so that people can write the text they want.\n          length_x and length_y are respectively the width and the height of the box.\n          Those values will be update regarding the input text*/ \n          length_x:72,\n          length_y:30,\n          draggable: true,\n          isGrouped: 0,\n          className:\"Text\",    \n          fontSize: 30,\n          fontFamily: 'Calibri',\n          /*When it is on a line, a shape can be rotate by the user independently from the line.\n          To keep the independant rotation of the attached shape, we add the parameter \"personalRotation\".\n          So, when the shape is attached, is final rotation is the sum of this parameter with the rotation of the line.\n          */\n          personalRotation:0,\n          id:'4',\n          dragBoundFunc:dragFunc,\n          centerPosition:'Top',\n        },\n        {\n          rotation: 0,\n          x: 700,\n          y: 400,           \n          scaleX:1,\n          scaleY:1,\n          offsetY:0,\n          offsetX:0,\n          opacity:1,\n          image: null,\n          draggable: true,\n          isGrouped: 0,\n          className:\"Image\", \n              \n          fontSize: 30,\n          /*When it is on a line, a shape can be rotate by the user independently from the line.\n          To keep the independant rotation of the attached shape, we add the parameter \"personalRotation\".\n          So, when the shape is attached, is final rotation is the sum of this parameter with the rotation of the line.\n          */\n          personalRotation:0, \n          id:'5',\n          dragBoundFunc:dragFunc,\n          centerPosition:'Top',\n        },\n        {\n          rotation: 0,\n          id:'8',\n          x: 300,\n          y: 150,\n          sides:3,\n          radius:60,\n          width: 120,\n          height: 120,\n          opacity:1,\n          scaleX: 1,\n          scaleY: 1,\n          strokeWidth: 0,\n          stroke: 'black',\n          fill: 'purple',\n          name: 'triangle1',\n          draggable: true,\n          className:\"Triangle\",\n          isGrouped: 0,\n          dragBoundFunc: dragFunc,\n          offsetX: 0,\n          offsetY: 0,\n          personalRotation:0, \n          centerPosition:'Middle',\n        },{\n          text: 'Try applying the 3 lenses \\n to improve the playground :-) :\\n analytical, critical and constructive',\n          rotation: 0,\n          x: 1250,\n          y: 200,           \n          scaleX:1,\n          scaleY:1,\n          offsetY:0,\n          offsetX: 36,\n          opacity:1,\n          length_x:72,\n          length_y:30,\n          draggable: true,\n          isGrouped: 0,\n          className:\"Text\",    \n          fontSize: 20,\n          fontFamily: 'Calibri',\n          personalRotation:0,\n          id:'9',\n          dragBoundFunc:dragFunc,\n          centerPosition:'Top',\n        },\n      ],\n\n      //circle which will represents the center of a selected object.\n      center:{\n        x: 300,\n        y: 500,\n        scaleX:1,\n        scaleY:1,\n        offsetX: 0,\n        offsetY: 0,\n        radius: 4,\n        fill: 'black',\n        opacity:1,\n        draggable:true,\n        isGrouped: 0,\n        className:\"Circle\",\n        id:'center',\n        dragBoundFunc:dragFunc,\n        visible: false,\n      },\n\n      //template to define a \"position point\" on the line\n      positionPoint:{\n        x: 300,\n        y: 500,\n        scaleX:1,\n        scaleY:1,\n        offsetX: 0,\n        offsetY: 0,\n        radius: 3,\n        fill: 'yellow',\n        opacity:1,\n        draggable:false,\n        isGrouped: 0,\n        className:\"positionPoint\",\n        id:'positionPoint',\n        distance_to_line_center:undefined,\n        dragBoundFunc:dragFunc,\n      },\n      selectedShapeId: '',\n    };\n  },\n  mounted(){\n    //We update length_x and length_y regarding the input text\n\n    let texts=this.$refs.stage.getStage().getChildren()[0].getChildren().filter((r)=>r.attrs.className=='Text');\n    let texts_data=this.shapes.filter((r)=>r.className==\"Text\")\n    for(let i=0;i<texts_data.length;i++){\n      texts_data[i].length_x=texts[i].width();\n      texts_data[i].length_y=texts[i].height();\n      texts[i].offsetX(texts_data[i].length_x/2);\n      texts_data[i].offsetX=texts_data[i].length_x/2;\n    }\n  },\n\n  created(){\n    \n    //We set the value of mx_id_figures\n    this.max_id_figures=this.shapes.length +this.groups.length; \n    for(let i=0;i<this.groups.length;i++){\n      this.max_id_figures= this.max_id_figures+this.groups[i].shapes_g.length;\n    }\n    \n    //We set the image for the image shape already created on the canvas at the beginning.\n    const image = new window.Image();\n    image.src = require(\"@/assets/exsitu.png\");\n\n    \n    image.height=150;\n    image.width=150;\n    //set image only when it is loaded\n    image.onload = () => {\n      this.shapes.find((r)=>r.className===\"Image\").image= image;\n      this.shapes.find((r)=>r.className===\"Image\").offsetX=image.width/2;\n      this.shapes.find((r)=>r.className===\"Image\").offsetY=0; \n    };\n  },\n\n  methods: {\n\n    /*\n    Method which switch the following modes: use of the eraser or not\n    */\n    switchEraseMode(){\n      if(this.eraseMode==0){\n        this.eraseMode=1;\n        document.getElementById(\"playground\").style.cursor='url('+require('@/assets/ugly_eraser.png')+'),default';\n        this.center.visible=false;  \n        this.eraseNodefromTransformer(\"shapeTransformer\");\n        this.eraseNodefromTransformer(\"lineTransformer\");\n      } else{\n        this.eraseMode=0;\n        document.getElementById(\"playground\").style.cursor=\"default\";\n      }\n    },\n\n    /*\n    Check if all shapes that are supposed to be on a line still in this line.\n    If not, we remove them from the stickyline to recreate them on the stage.\n    id_grp is the id of the group which contains the line.\n    */\n    checkIfShapesOnLine(id_grp){\n      const grp= this.groups.find((r) => r.id===id_grp);\n      const line=grp.line;\n      const groupedShapes = grp.shapes_g;\n      \n     \n      \n      let i=0;\n      while(i<groupedShapes.length){\n       if(!this.isCoordinateOnLine(groupedShapes[i].x,groupedShapes[i].y,line.id)){\n          //We erase ghosts or attached shapes and we make sure that their opacity is 1.\n          grp.ghosts.splice(0,grp.ghosts.length);\n          for (let i=0;i<groupedShapes.length;i++){\n            groupedShapes[i].opacity=1;\n          }\n\n          console.log(\"a shape is not on a line\");\n\n          groupedShapes[i].dragBoundFunc= dragFunc;\n          groupedShapes[i].isGrouped=0;\n          if(line.keepDistribution){\n            /*it is useless to keep position points when a shape is detach\n            and the distribution on the stickyline is homegenous and equal(keepDistribution=1)*/\n            line.positionPoints.splice(i,1)\n          }\n          this.shapes.push(groupedShapes[i],)\n          line.freeDistances.push(line.occupiedDistances[i]);\n          line.occupiedDistances.splice(i,1);\n          groupedShapes.splice(i,1);\n          \n          //We make sure that the corresponding \"position point\" of the new free position \n          //is draggable and have the good drag bound func so that we can move it only on the line.\n          if(!line.keepDistribution){\n            this.updateAllPosInGrp(id_grp);     \n            let positionPoint=line.positionPoints.find((r)=>r.distance_to_line_center==line.freeDistances[line.freeDistances.length-1]);\n            positionPoint.draggable=true;\n            this.updateDragFunc(positionPoint,line);\n          }\n        }else{\n          i=i+1;\n        }\n      }\n    },\n\n    //Return a bollean to say if {x,y} is a point from the line or not.\n    isCoordinateOnLine(x,y,id_grp){\n      const grp=this.groups.find((r) => r.id===id_grp);\n      const line=grp.line;\n      let is_not_on_straight_line=true;\n\n      //We determine de coefficients of the straight line where the stickyline is.\n      let coord_y1=line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x1=line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let coord_y2= line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x2=line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let a=(coord_y1-coord_y2)/(coord_x2-coord_x1);\n      let b=line.y-a*line.x;\n      \n      if(Math.abs(coord_x1-coord_x2)>1){\n        is_not_on_straight_line=(Math.abs(a*x+b-y)>1);\n      }else{\n        /*if the difference between coord_x1 and coord_x2 is too big, it means that the stickyline\n        is almost vertical. So to determine if a the point {x,y} is on the straight line of the stickyline\n        we look only at the horitontal axis.\n        */\n        is_not_on_straight_line=(Math.abs(x-line.x)>1)\n      }\n\n\n      /*We now look if the point is not one of the straight line \n      or if it is outside the box determine by the coordinate of the extremities of the stickyline\n      */\n      if(\n        (is_not_on_straight_line)\n\n      ||((line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<y\n      ||line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>y)\n      && ((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<x\n        ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>x)\n      &&((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<y\n        ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>y)\n      &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>-Math.PI)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>x)\n      &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>-Math.PI)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>y)\n      &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>x)\n      &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>y)\n      &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>=0)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>x)\n      &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>=0)))\n\n      \n      )\n      {\n        return false; \n      } else{\n        return true;\n      }\n    },\n\n    //update a group corresponding to the one of the target stickyline (e.target)\n    updateGrp(e){\n      let id_grp=e.target.id();\n      const grep=this.groups.find((r)=>r.id===id_grp);\n      const line= grep.line;\n      grep.offsetX=line.offsetX;\n      grep.offsetY=line.offsetY;\n      \n      line.x=e.target.x();\n      line.y=e.target.y();\n      this.center.x=line.x;\n      this.center.y=line.y;\n\n      this.updateAllPosInGrp(line.id); \n      this.checkIfShapesOnLine(line.id);\n    },\n\n\n    //update the position of all shapes that are on the stickyline of the group with the id=id_grp.\n    updateAllPosInGrp(id_grp){\n      const grp= this.groups.find((r) => r.id===id_grp);     \n      const line= grp.line;\n      const shapes_g = grp.shapes_g;\n      for (let i=0;i<shapes_g.length;i++){\n          if(line.keepDistribution){\n            shapes_g[i].x=line.x+line.occupiedDistances[i]*Math.cos(line.rotation*(Math.PI/180));\n            shapes_g[i].y=line.y+line.occupiedDistances[i]*Math.sin(line.rotation*(Math.PI/180));\n            shapes_g[i].distance_to_line_center=line.occupiedDistances[i];\n            shapes_g[i].rotation=shapes_g[i].personalRotation+line.rotation;\n            \n          } else{\n            shapes_g[i].x=line.x+line.occupiedDistances[i]*Math.cos(line.rotation*(Math.PI/180));\n            shapes_g[i].y=line.y+line.occupiedDistances[i]*Math.sin(line.rotation*(Math.PI/180));\n            shapes_g[i].distance_to_line_center=line.occupiedDistances[i];\n            shapes_g[i].rotation=shapes_g[i].personalRotation+line.rotation;\n          }\n\n          //We also update the position of the \"position points\" accordingly to the one of the attached shapes\n          line.positionPoints[i].x=shapes_g[i].x;\n          line.positionPoints[i].y=shapes_g[i].y;\n          line.positionPoints[i].distance_to_line_center=shapes_g[i].distance_to_line_center;\n      }\n      /*If not all the \"position points\" have been update before, it means that they are \"free distances\"\n      that need to be show by setting the position of those points.\n      */\n      let i=shapes_g.length;\n      while(i<line.positionPoints.length){\n        if(line.keepDistribution){\n          //If we keep distribution there is no need for more positions points because there are not \"free distances\".\n          line.positionPoints.splice(line.positionPoints.length-1,1);\n        }else{\n          line.positionPoints[i].x=line.x+line.freeDistances[i-shapes_g.length]*Math.cos(line.rotation*(Math.PI/180));\n          line.positionPoints[i].y=line.y+line.freeDistances[i-shapes_g.length]*Math.sin(line.rotation*(Math.PI/180));\n          line.positionPoints[i].distance_to_line_center=line.freeDistances[i-shapes_g.length];\n          i++\n        } \n      }\n    },\n\n    /*\n    isOutsideTheLine(shape,line){\n      let coord_y1=line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x1=line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let coord_y2= line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n      let coord_x2=line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n      let a=(coord_y1-coord_y2)/(coord_x2-coord_x1);\n      let b=line.y-a*line.x;\n      let is_on_straight_line=false;\n      if(Math.abs(coord_x1-coord_x2)>=1){\n        is_on_straight_line=(Math.abs(a*shape.x+b-shape.y)<1);\n      }else{\n        is_on_straight_line=(Math.abs(shape.x-line.x)<1);\n      }\n      if(\n        !(is_on_straight_line)\n      ||((line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n        ||line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      && ((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=0 && line.rotation*(Math.PI/180)>-Math.PI/2)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>-Math.PI)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=-Math.PI/2 && line.rotation*(Math.PI/180)>-Math.PI)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=Math.PI && line.rotation*(Math.PI/180)>Math.PI/2)))\n\n      ||((line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.y\n      ||line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.y)\n      &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>=0)))\n\n      ||((line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToDetach<shape.x\n      ||line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToDetach>shape.x)\n      &&((line.rotation*(Math.PI/180)<=Math.PI/2 && line.rotation*(Math.PI/180)>=0)))\n      ){\n        return true;\n      }else{ return false}\n    },\n    */\n    \n    //update the canvas\n    update(){\n      const shapes = this.shapes\n      \n      let is_on_straight_line=false;\n      //For each shapes on the canvas we look if it is nearby a stickyline.\n      for (let i=0;i<shapes.length;i++){\n        let x=shapes[i].x;\n        let y=shapes[i].y;\n        for (let j=0;j<this.groups.length;j++){\n      \n          let line=this.groups[j].line;\n\n          //as for isCoordinateOnLine we determine the coefficients of the straight line determined by the stickyline\n          let coord_y1=line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n          let coord_x1=line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n          let coord_y2= line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180));\n          let coord_x2=line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180));\n          let a=(coord_y1-coord_y2)/(coord_x2-coord_x1);\n          let b=line.y-a*line.x;\n\n          if(Math.abs(coord_x1-coord_x2)>1){\n            is_on_straight_line=(Math.abs(a*x+b-y)<=this.lengthToCapture);\n          }else{\n            //if the straight line is almost vertican we look only at the horizontal axis\n            is_on_straight_line=(Math.abs(x-line.x)<=this.lengthToCapture);\n          }\n          /*We now look if the shape is on the straight line \n          and if it is inside the box determine by the coordinate of the extremities of the stickyline.\n          If it is the case we add it to the group of the stickyline (see makeGroup).\n          */\n          if(\n              (\n                is_on_straight_line\n                &&(line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToCapture>=y\n                && line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToCapture<=y)\n                &&(line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToCapture>=x\n                && line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToCapture<=x)\n                &&(line.rotation*(Math.PI/180)<=0 \n                && line.rotation*(Math.PI/180)>-Math.PI/2))\n\n            ||(\n              is_on_straight_line\n              &&(line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))+this.lengthToCapture>=y\n              && line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI+line.rotation*(Math.PI/180))-this.lengthToCapture<=y) \n              &&(line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))+this.lengthToCapture>=x\n              && line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI+line.rotation*(Math.PI/180))-this.lengthToCapture<=x)\n              &&(line.rotation*(Math.PI/180)<=-Math.PI/2 \n              && line.rotation*(Math.PI/180)>=-Math.PI))\n\n            ||(\n              is_on_straight_line\n              &&(line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))+this.lengthToCapture>=y\n              &&line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(Math.PI-line.rotation*(Math.PI/180))-this.lengthToCapture<=y)\n              &&(line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))+this.lengthToCapture>=x\n              && line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(Math.PI-line.rotation*(Math.PI/180))-this.lengthToCapture<=x)\n              &&(line.rotation*(Math.PI/180)<=Math.PI \n              && line.rotation*(Math.PI/180)>Math.PI/2))\n\n            ||(\n              is_on_straight_line\n              &&(line.y+line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))+this.lengthToCapture>=y\n              && line.y-line.points[4]*(1/2)*line.scaleX*Math.sin(line.rotation*(Math.PI/180))-this.lengthToCapture<=y)\n              &&(line.x+line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))+this.lengthToCapture>=x\n              && line.x-line.points[4]*(1/2)*line.scaleX*Math.cos(line.rotation*(Math.PI/180))-this.lengthToCapture<=x)\n              &&(line.rotation*(Math.PI/180)<=Math.PI/2\n              && line.rotation*(Math.PI/180)>=0))\n          )\n          {\n            shapes[i].isGrouped=1;\n            this.makeGroup(line.id);\n          }\n        }\n      }\n    },\n\n    //Called when the user start dragging a shape attached to the line.\n    initializeDragging(e){\n      //grp is the group of the target shape:\n      \n      let grp=this.groups.find((r)=>r.id==e.target.getParent().attrs.id);\n\n      if(grp.shapes_g.length>1 && grp.line.keepDistribution==1){\n        //the data of the neighbour of the target shape in the group grp.\n        let neighbour=this.closestGroupedShape(grp,e);\n\n        //the node corresponding to this neighbour\n        this.neighbour=e.target.getParent().getChildren().find((r)=>r.attrs.id==neighbour.id);\n\n        let position={x: e.target.x(),y: e.target.y()};\n\n        //We create a ghosts of the neighbour of the target object to the position of this target object.\n        this.createGhost(grp,position,this.neighbour)\n\n        //We calculate the distance of the target shape with its neighbour\n        this.dist_with_neighbour=this.distBtwShapes(e.target.attrs,this.neighbour.attrs);\n      }\n    },\n\n    /*Give the closest shape that are attached to the group grp \n    compared to the position of a target shape e.target*/\n    closestGroupedShape(grp,e){\n      //When an attached shape has no opacity it means that it is not in the neighbourhood of the shape we drag.\n      let neighbour=grp.shapes_g.find((r)=>r.id!=e.target.attrs.id && r.opacity!=0);\n      for (let i=0;i<grp.shapes_g.length;i++){\n        this.distBtwShapes(grp.shapes_g[i],e.target.attrs)\n        if(this.distBtwShapes(grp.shapes_g[i],e.target.attrs)<this.distBtwShapes(neighbour,e.target.attrs)\n        && grp.shapes_g[i].id!=e.target.attrs.id && grp.shapes_g[i].opacity!=0){\n          neighbour=grp.shapes_g[i]\n        }\n      }\n      \n      return neighbour;\n    },\n\n    /*create a copy of the shape \"neighbour\" at the position \"position\"\n    only if the distribution is kept on the stickyline of the group \"grp\"*/\n    createGhost(grp,position,neighbour){\n      if(grp.line.keepDistribution==1){\n        let clone=neighbour.clone({\n            id: 'clone'+neighbour.attrs.id,\n            x:position.x,\n            y:position.y,\n            opacity:0,\n            draggable:false,\n        });\n        grp.ghosts.push(clone.attrs,)\n      }\n    },\n\n    //Give distance btw shape1 and shape2\n    distBtwShapes(shape1,shape2){\n      return Math.sqrt((shape2.y-shape1.y)**2+(shape2.x-shape1.x)**2);\n      \n    },\n\n    /*Give distance btw a shape (considered as the start point when dragging)\n    and the position of the actual target node which is dragged (e.target)*/\n    distFromStartPoint(shape,e){\n      return Math.sqrt((shape.y-e.target.y())**2+(shape.x-e.target.x())**2);\n    },\n\n    /*\n    targetNeighbour(e){\n      let grp= this.groups.find((r)=>r.id===e.target.getParent().attrs.id);\n      let shape=grp.shapes_g.find((r)=>r.id==e.target.attrs.id)\n      let index=grp.shapes_g.indexOf(shape);\n      if(index==0){\n        return grp.shapes_g[1];\n      } else if(index==grp.shapes_g.length-1){\n        return grp.shapes_g[index-1]\n      } else{\n        let distRight=this.distBtwShapes(e.target.attrs,grp.shapes_g[index+1]);\n        let distLeft=this.distBtwShapes(e.target.attrs,grp.shapes_g[index-1]);\n        if(distRight>distLeft){\n          return grp.shapes_g[index-1];\n        } else{\n          return grp.shapes_g[index+1];\n        }\n      }\n    },\n    */\n\n    //Called \"continuously\" when the user drag a shape which is on a stickyline.\n    onDragging(e){\n      \n      let grp=this.groups.find((r)=>r.id===e.target.getParent().attrs.id);\n      let shape= grp.shapes_g.find((r)=>r.id==e.target.id());\n      \n      \n      //if we keep distribution on the stickyline, we will show to the user the output with ghost-shapes when dragging a shape on the line\n      if(grp.line.keepDistribution==1 && grp.shapes_g.length>1){\n\n        //\"ghost\" of the current neighbour\n        let clone=grp.ghosts.find((r)=>r.id==('clone'+this.neighbour.attrs.id))\n\n        let neighbour=grp.shapes_g.find((r)=>r.id===this.neighbour.attrs.id);\n        \n        //if there is more than one shape on the stickyline and if the dragged shape is not outside the stickyline\n        if(grp.shapes_g.length>1 && this.isCoordinateOnLine(e.target.x(),e.target.y(),grp.id)){\n\n          //Distance between the position of the shape before being dragged and its actual position.\n          //let distFromStart= this.distFromStartPoint(shape,e);\n\n          //distance between shapes on the stickyline where they are equaly and homogeneously distributed.\n          let dist_btw_shapes=grp.line.points[4]*grp.line.scaleX/(grp.shapes_g.length-1);\n          \n          \n          //if the closest shape from the dragged shape change\n          if(this.closestGroupedShape(grp,e).id!=this.neighbour.attrs.id){\n            \n            let position;\n\n            /*If the opacity of the neighbour is null in its current state, \n            it means that its place is currently considered as the one of the object we drag.*/\n            if(this.neighbour.attrs.opacity==0){\n              position={x: neighbour.x,y: neighbour.y};\n            }else{\n              position={x: shape.x,y: shape.y};\n            }\n\n            /*if the change of the closest shape has been made without fully make appear the ghost-shape\n            of the previous closest shape, we can erase this ghost-shape.\n            If not, it means that the dragged shape can take the position of the previous neighbour.\n            And the previous neighbour can take the one of its clone*/\n            if(clone.opacity<1 /*&& distFromStart<=(grp.line.points[4]*grp.line.scaleX/2)*/){\n              grp.ghosts.splice(grp.ghosts.indexOf(clone),1)\n            }\n            else{ \n              shape.x=neighbour.x;\n              shape.y=neighbour.y;\n              neighbour.x=clone.x;\n              neighbour.y=clone.y;\n              neighbour.opacity=1;\n              grp.ghosts.splice(grp.ghosts.indexOf(clone),1)\n              this.sortByDistToLineCenter(grp) // in order to sort attached shapes because the position of one of them has been update\n            }\n            \n            //We consider the new neighbour (ie the new closest shape) and create its ghost-shape.\n            this.neighbour=e.target.getParent().getChildren().find((r)=>r.attrs.id==this.closestGroupedShape(grp,e).id); \n            this.createGhost(grp,position,this.neighbour)\n            clone=grp.ghosts.find((r)=>r.id==('clone'+this.neighbour.attrs.id))  \n          }\n\n          /*Distance between the position of the shape before being dragged \n          (or the new position it took from its previous neighbour) \n          and its actual position.*/\n          let distFromStart= this.distFromStartPoint(shape,e)\n\n          this.dist_with_neighbour=this.distBtwShapes(e.target.attrs,this.neighbour.attrs);\n\n          //We update the opacity of the neighbour and its ghost regarding how the dragged shape is moving.\n          let x=distFromStart/dist_btw_shapes;\n          let opacity_change=x;\n          if (x>=0.3){\n            opacity_change=0.3;\n          }\n          if(x>=1){\n            opacity_change=1;\n          }\n          clone.opacity=opacity_change;\n          this.neighbour.opacity(1-1*opacity_change)\n          neighbour=grp.shapes_g.find((r)=>r.id===this.neighbour.attrs.id);\n          neighbour.opacity=1-1*opacity_change\n\n        }else{\n          for (let i=0;i<grp.shapes_g.length;i++){\n            grp.shapes_g[i].opacity=1;\n          }\n          clone.opacity=0;\n        }\n      }\n\n      //distance btw the mouse pointer and the target shape (e.target)\n      let dist=Math.sqrt((e.target.getStage().getPointerPosition().y-e.target.y())**2+(e.target.getStage().getPointerPosition().x-e.target.x())**2);\n      \n      // We substrate dist by the height of the shape.\n      if(e.target.className==\"Rect\"){\n        dist-=e.target.attrs.height*e.target.attrs.scaleY;\n      } else if(e.target.className==\"Circle\"){\n        dist-=(2*e.target.attrs.radius)*e.target.attrs.scaleY;\n      } else if(e.target.className==\"Text\"){\n        dist-=e.target.attrs.length_y*e.target.attrs.scaleY;\n      } else if(e.target.className==\"Image\"){\n        dist-=e.target.height()*e.target.scaleY();\n      } else if(e.target.attrs.className==\"Triangle\"){\n        dist-=e.target.height()*e.target.scaleY();\n      } \n      \n      //if dist>50, we consider that the user want to detach the shape.\n      if (dist>50){\n        this.groups.find((r)=>r.id===e.target.getParent().attrs.id).aShapeHasBeenDetach=1;\n        this.DetachShape(shape,e.target.getStage().getPointerPosition().x,e.target.getStage().getPointerPosition().y); \n      }\n    },\n\n    //Give the sign of the distance of a shape from the center of a line.\n    GiveSignOfDistance(shape,line){\n      let result;\n      let angle=line.rotation*(Math.PI/180);\n      let distX=shape.x-line.x;\n      let distY=shape.y-line.y;\n      \n      if(Math.abs(distX)<=this.lengthToCapture && line.rotation==-90){\n        \n        result=-Math.sign(distY);\n      } else if (Math.abs(distX)<=this.lengthToCapture && line.rotation==90){\n        result=Math.sign(distY);\n      }\n      else{\n        result=Math.sign(distX);\n      }\n      if(angle<-Math.PI/2 || angle>Math.PI/2){\n        result=-result;\n      }\n      \n      return result;\n    },\n\n    /*Different from the previous function because \n    the straight line where the center is, is perdendicular to the stickyline.\n    The center is the one of an attached shape (ie \"shape\" argument)*/\n    GiveSignOfDistanceBtwCenterAndShape(center,shape){\n      let result;\n      let angle=shape.rotation*(Math.PI/180);\n      let distX=center.x-shape.x;\n      let distY=center.y-shape.y;\n\n      if(Math.abs(distY)<=this.lengthToCapture && shape.rotation==-90){\n        \n        result=Math.sign(distX);\n      } else if (Math.abs(distY)<=this.lengthToCapture && shape.rotation==90){\n        result=-Math.sign(distX);\n      }\n      else{\n        result=Math.sign(distY);\n      }\n      if(angle<-Math.PI/2 || angle>Math.PI/2){\n        result=-result;\n      }\n      \n      return result;\n    },\n\n    /*add shapes with isGrouped==1 to the group with the id id_grp.\n    */\n    makeGroup(id_grp){\n      this.eraseNodefromTransformer(\"shapeTransformer\");\n      this.eraseNodefromTransformer(\"lineTransformer\");\n      const grp=this.groups.find((r)=> r.id===id_grp);\n      const line=grp.line;\n      const shapes = this.shapes;\n      line.freeDistances.sort(this.isSmaller); //we will give the shortest available distance to the added shape (if keepDistribution=0)\n      shapes.sort(this.isBeforeRegardingX);\n\n      for (let i=0;i<shapes.length;i++){\n        if(shapes[i].isGrouped==1){\n          // we will create a \"position point\" for the position of the added shape (if necessary)\n          const positionPoint=Object.assign({},this.positionPoint); \n\n          let distX=shapes[i].x-line.x;\n          let distY=shapes[i].y-line.y; \n          shapes[i].personalRotation=0;\n          shapes[i].distance_to_line_center=this.GiveSignOfDistance(shapes[i],line)*Math.sqrt((distX)**2+(distY)**2);\n          /*If the distance is a little bit to far from the center \n            we adjust it so that the shape can be at one of the border of the stickyline*/\n            if(Math.abs(shapes[i].distance_to_line_center)>=line.points[4]*line.scaleX/2){\n              shapes[i].distance_to_line_center=Math.sign(shapes[i].distance_to_line_center)*line.points[4]*line.scaleX/2\n            }\n          /*We give to the center of the added shape the position determined \n          by the default alignment position of the stickyline (Top,Middle or Bottom)*/\n          this.ChangeCenterRegardingCommand(shapes[i].id,grp.line.defaultAlignment);\n\n          /*If we keep distances in memory and that there are available distances,\n          we give the corresponding position to the added shape*/\n          if(!line.keepDistribution && line.freeDistances.length>0){\n            /*We take the indice of the free distance which corresponds\n            to the nearest available position from the added shape (shapes[i])*/\n            let indice=this.isNearest(line,shapes[i]);\n            this.updateDragFunc(shapes[i],line);\n\n            //We add the shape to the group.\n            grp.shapes_g.push(shapes[i],);\n\n            //The chosen free distance is now an occupied one.\n            grp.line.occupiedDistances.push(grp.line.freeDistances[indice]);\n            grp.line.positionPoints.find((r)=>r.distance_to_line_center==grp.line.freeDistances[indice]).draggable=false;\n            grp.line.freeDistances.splice(indice,1);\n          }else{\n            this.updateDragFunc(shapes[i],line);\n            grp.shapes_g.push(shapes[i],);\n            grp.line.occupiedDistances.push(shapes[i].distance_to_line_center,);\n\n            //We create a new \"position point\" on the stickyline.\n            positionPoint.id=\"positionPoint\"+grp.id+grp.line.positionPoints.length;\n            grp.line.positionPoints.push(positionPoint,);\n          }\n          console.log(\"A new shape has been added with a distance\"+shapes[i].distance_to_line_center);\n          this.updateOccupiedDistance(line.id);\n          \n\n          this.updateAllPosInGrp(id_grp);\n          shapes.splice(i,1);\n        }\n      }\n      this.center.x=line.x;\n      this.center.y=line.y;\n    },\n\n    /*update the occupied distance corresponding to each attached shape\n    First we sort the attached shapes by their distance to the line\n    Then, we update the list which contains the occupied distances.\n    The attached shapes and their occupied distances share the same index in their respective list\n    */\n    updateOccupiedDistance(id_grp){\n      \n      const grp=this.groups.find((r)=> r.id===id_grp);\n      this.sortByDistToLineCenter(grp);\n      \n      /*If distribution is kept, we calculate the occupied distances of each shape\n      in order to keep the distribution*/\n      if(grp.line.keepDistribution){\n        let L=grp.line.points[4];\n        let nb_shapes=grp.shapes_g.length;\n        let d=(L/(nb_shapes-1))*grp.line.scaleX; //Distance btw shapes\n\n        if(nb_shapes%2==0){ \n\n          for (let i =1;i<=nb_shapes/2-1;i++){\n            grp.line.occupiedDistances[i-1]=-((nb_shapes/2-1)-i+1)*d-d/2\n          }\n          for (let i =1;i<=nb_shapes/2-1;i++){\n            grp.line.occupiedDistances[nb_shapes/2+i]=i*d+d/2;\n          }\n          grp.line.occupiedDistances[nb_shapes/2-1]=-d/2\n          grp.line.occupiedDistances[nb_shapes/2]=d/2\n\n        } else{\n\n          for (let i =1;i<=(nb_shapes-1)/2;i++){\n            grp.line.occupiedDistances[i-1]=-d*(((nb_shapes-1)/2)-i+1);\n          }\n          for (let i =1;i<=(nb_shapes-1)/2;i++){\n            grp.line.occupiedDistances[((nb_shapes-1)/2)+i]=d*i;\n          }\n          grp.line.occupiedDistances[(nb_shapes-1)/2]=0;\n\n        }\n        \n        for (let i=0;i<grp.shapes_g.length;i++){\n          grp.shapes_g[i].distance_to_line_center=grp.line.occupiedDistances[i];\n        }\n      }\n      //if only distance is kept, we sort the occupied distances in the ascending order.\n      else{\n        grp.line.occupiedDistances.sort(this.isSmaller);\n      }\n    },\n\n    isSmaller(a,b){\n      if(a<b){\n        return -1;\n      }else{\n        return 1\n      }\n    },\n\n    isBeforeRegardingX(a,b){\n      if(a.x<b.x){\n        return -1;\n      }else{\n        return 1;\n      }\n    },\n\n    /*\n    //deprecated\n    updateOccDist(grp,shape){\n      let res=this.isNearest(grp.line,shape);\n      if(res.isFree){\n\n        shape.distance_to_line_center=grp.line.freeDistances[res.indice];\n        grp.line.freeDistances.splice(res.indice,1);\n        this.sortByDistToLineCenter(grp);\n        for(let l=0;l<grp.shapes_g.length;l++){\n          if(grp.line.occupiedDistances.length==l){\n            grp.line.occupiedDistances.push(grp.shapes_g[l].distance_to_line_center,);\n          }else{\n            grp.line.occupiedDistances[l]=grp.shapes_g[l].distance_to_line_center;\n          }\n        } \n\n      }else{\n\n        grp.shapes_g.find((r)=>r.id==shape.id).distance_to_line_center=grp.line.occupiedDistances[res.indice];\n        grp.line.occupiedDistances.splice(res.indice,1);  \n        this.updateOccDist(grp,grp.shapes_g[res.indice]);\n\n      }\n    },\n    */\n\n    /*\n    Give the indice of the nearest distance in the freeDistances list of a line\n    from the distance between a shape and the line center \n    */\n    isNearest(line,shape){\n      let ecart;\n      let invx=line.x+line.freeDistances[0]*Math.cos(line.rotation*(Math.PI/180));\n      let invy=line.y+line.freeDistances[0]*Math.sin(line.rotation*(Math.PI/180));\n      let ecart_min=Math.sqrt((invx-shape.x)**2+(invy-shape.y)**2);\n      let indice=0;\n      for(let i=1;i<line.freeDistances.length;i++){\n        invx=line.x+line.freeDistances[i]*Math.cos(line.rotation*(Math.PI/180));\n        invy=line.y+line.freeDistances[i]*Math.sin(line.rotation*(Math.PI/180));\n        ecart=Math.sqrt((invx-shape.x)**2+(invy-shape.y)**2);\n        if(ecart<ecart_min){\n          ecart_min=ecart;\n          indice=i;\n        }\n      }\n      return indice;    \n    },\n\n    /*\n    Sort attached shapes of the group given in argument regarding their distance to the stickyline's center\n    */\n    sortByDistToLineCenter(grp){ \n\n      /*If the stickyline keep distribution,\n      we first update the value of distance_to_line_center of each attached shapes.*/\n      if(grp.line.keepDistribution){\n        for (let l=0;l<grp.shapes_g.length;l++){\n            let distX=grp.shapes_g[l].x-grp.line.x;\n            let distY=grp.shapes_g[l].y-grp.line.y;\n            grp.shapes_g[l].distance_to_line_center=this.GiveSignOfDistance(grp.shapes_g[l],grp.line)*Math.sqrt((distX)**2+(distY)**2);\n          }\n      }\n      \n\n      for(let i=1;i<grp.shapes_g.length;i++){\n        let shape=grp.shapes_g[i];\n        let j=i\n        while(j>0 && grp.shapes_g[j-1].distance_to_line_center>shape.distance_to_line_center){\n          grp.shapes_g[j]=grp.shapes_g[j-1];\n          j=j-1;\n        }\n        grp.shapes_g[j]=shape;\n      }\n    },\n\n    /*\n    update the drag function of a shape regarding a line\n    (which is supposed to be the one it is attached to).\n    The drag function is updated so that the user can only drag an attached shape\n    regarding the straight line of the stickyline.\n    */\n    updateDragFunc(shape,line){\n      let angle=line.rotation*(Math.PI/180);\n\n      if (angle<=0 && angle>=-Math.PI/4){\n        shape.dragBoundFunc= function (pos) {\n          return {\n            x: line.x +(pos.x-line.x)*Math.cos(angle),\n            y: line.y+(pos.x-line.x)*Math.sin(angle),\n          };\n        }\n      } else if (angle<-Math.PI/4 && angle>=-Math.PI/2){\n        /*We prefer, in this case, moving the shape of the line \n        regarding the y of the mouse position instead of the x.\n        So that the user can move the shape more intuitively*/\n        shape.dragBoundFunc= function (pos) {\n          return {\n            x: line.x-(pos.y-line.y)*Math.cos(angle),\n            y: line.y-(pos.y-line.y)*Math.sin(angle),\n          };\n        }\n      } else if (angle<-Math.PI/2 && angle>=-3*Math.PI/4){\n        shape.dragBoundFunc= function (pos) {\n          return {\n            x: line.x-(pos.y-line.y)*Math.cos(angle),\n            y: line.y-(pos.y-line.y)*Math.sin(angle),\n          };\n        }\n      } else if (angle<-3*Math.PI/4 && angle>=-Math.PI){\n        shape.dragBoundFunc= function (pos) {\n          return {\n            x: line.x-(pos.x-line.x)*Math.cos(angle),\n            y: line.y-(pos.x-line.x)*Math.sin(angle),\n          };\n        }\n      } else if (angle<=Math.PI && angle>=3*Math.PI/4){\n        shape.dragBoundFunc= function (pos) {\n          return {\n            x: line.x-(pos.x-line.x)*Math.cos(angle),\n            y: line.y-(pos.x-line.x)*Math.sin(angle),\n          };\n        }\n      } else if (angle<3*Math.PI/4 && angle>=Math.PI/2){\n        shape.dragBoundFunc= function (pos) {\n          return {\n            x: line.x+(pos.y-line.y)*Math.cos(angle),\n            y: line.y+(pos.y-line.y)*Math.sin(angle),\n          };\n        }\n      } else if (angle<Math.PI/2 && angle>=Math.PI/4){\n        shape.dragBoundFunc= function (pos) {\n          return {\n            x: line.x+(pos.y-line.y)*Math.cos(angle),\n            y: line.y+(pos.y-line.y)*Math.sin(angle),\n          };\n        }\n      } else if (angle<Math.PI/4 && angle>=0){\n        shape.dragBoundFunc= function (pos) {\n          return {\n            x: line.x+(pos.x-line.x)*Math.cos(angle),\n            y: line.y+(pos.x-line.x)*Math.sin(angle),\n          };\n        }\n      }\n    },\n\n    /*\n    Called when the user is dragging a free shape.\n    Update the potision of the shape.\n    */\n    updatePos(e){\n      const shape = this.shapes.find(i => i.id === e.target.id());\n      shape.x=e.target.x();\n      shape.y=e.target.y();\n\n      /*We also update the circle that represent the centers of objects\n      so that it can follow the shape when it is dragged*/\n      this.center.x=e.target.x();\n      this.center.y=e.target.y(); \n\n      /*\n      let pos = { x: shape.x, y: shape.y };\n      e.target.position(pos);\n      e.target.getLayer().batchDraw();\n      */\n      \n    },\n\n    /*\n    Called after a shape attached to a line (from the group with id=id_grp)has been dragged.\n    Update the position of the shape.\n    */\n    updatePosInGrp(e,id_grp){\n      let distX;\n      let distY;\n      let distance_to_line_center;\n      const grp=this.groups.find((r)=> r.id===id_grp);\n      \n      /*If the shape the user dragged as been considered as detach from the line,\n      we have no update to do because the shape as been removed from the list \n      of attached shapes of the group.\n      */\n      if(grp.aShapeHasBeenDetach==1){\n        grp.aShapeHasBeenDetach=0;\n        return;\n      }\n      \n      const line=grp.line;\n      const shape = grp.shapes_g.find(i => i.id === e.target.id());\n      const shapes_g = grp.shapes_g; \n\n      /*If the line keep distribution, the treartment is different because\n      attached shapes can switch their position*/\n      if(line.keepDistribution){\n\n        /*We erase all the ghost-shapes and make sure that all shapes have full opacity.\n        We also reset the data of th evue component which contains \n        the actual target neighbour when dragging an atatched shape*/\n        grp.ghosts.splice(0,grp.ghosts.length);\n        for(let i=0;i<shapes_g.length;i++){\n          shapes_g[i].opacity=1;\n        }\n        this.neighbour=null;\n        \n        /*If the shape still on the line after the user dragged it,\n        we see if we need to switch its position with another one*/\n        if(this.isCoordinateOnLine(e.target.x(),e.target.y(),line.id)){\n\n          distX=shape.x-e.target.x();\n          distY=shape.y -e.target.y();\n\n          let L=grp.line.points[4];\n          let nb_shapes=grp.shapes_g.length;\n          let d=(L/(nb_shapes-1))*grp.line.scaleX; // Distance btw attached shape to keep distribution\n          let dist=Math.sqrt(distX**2 +distY**2);// traveled distance since the user started dragging the shape.\n\n          /*If the traveled distance is greater than the distance btw attached shapes\n          we switch position of shapes by changing their order in the list shapes_g (see updateOccupiedDistance Method)*/\n          if(dist>=d){\n\n            shape.x=e.target.x();\n            shape.y=e.target.y();\n            this.updateOccupiedDistance(line.id)\n\n            //We also update the dragged shape's position:\n            shape.x=line.x+line.occupiedDistances[shapes_g.indexOf(shape)]*Math.cos(line.rotation*(Math.PI/180));\n            shape.y=line.y+line.occupiedDistances[shapes_g.indexOf(shape)]*Math.sin(line.rotation*(Math.PI/180));\n            shape.distance_to_line_center=line.occupiedDistances[shapes_g.indexOf(shape)];\n            shape.rotation=line.rotation;\n\n            /*These changements have a consequence on all the attached shape of the line\n            That is way we have to update the state of all of them with the method updateAllPosInGrp*/\n            this.updateAllPosInGrp(line.id);\n\n          }else{\n\n            shape.x=line.x+line.occupiedDistances[shapes_g.indexOf(shape)]*Math.cos(line.rotation*(Math.PI/180));\n            shape.y=line.y+line.occupiedDistances[shapes_g.indexOf(shape)]*Math.sin(line.rotation*(Math.PI/180));\n            shape.distance_to_line_center=line.occupiedDistances[shapes_g.indexOf(shape)];\n            shape.rotation=line.rotation;\n\n          } \n\n        }else{\n          /*If the shape has been dragged outside the line, we give to him to position where it has been dragged.  */\n          shape.x=e.target.x();\n          shape.y=e.target.y();\n        }\n\n        //We also update the position point corresponding to te shape.\n        line.positionPoints[grp.shapes_g.indexOf(shape)].x=shape.x;\n        line.positionPoints[grp.shapes_g.indexOf(shape)].y=shape.y;\n        line.positionPoints[grp.shapes_g.indexOf(shape)].distance_to_line_center=shape.distance_to_line_center; \n      \n      } else{\n        // If the line kept only distances, we update the shape as the user movement impose it.\n\n        line.positionPoints[grp.shapes_g.indexOf(shape)].x=shape.x;\n        line.positionPoints[grp.shapes_g.indexOf(shape)].y=shape.y;\n        shape.x=e.target.x();\n        shape.y=e.target.y();\n        \n        //We calculate the new distance with the line's center.\n        if(Math.sin(line.rotation*(Math.PI/180))==0){\n\n          distance_to_line_center=shape.x-line.x;\n          \n        }else{\n\n          if(Math.sign(shape.x-line.x)!=0){\n            distance_to_line_center=Math.sign(-shape.rotation)*Math.sign(shape.x-line.x)*Math.sqrt((shape.x-line.x)**2+(shape.y-line.y)**2);\n          } else{\n            distance_to_line_center=Math.sign(-shape.rotation)*Math.sign(shape.y-line.y)*Math.sqrt((shape.x-line.x)**2+(shape.y-line.y)**2); \n          }\n        \n          if(shape.rotation*(Math.PI/180)<=-Math.PI/2 || (shape.rotation*(Math.PI/180)<=Math.PI/2 && shape.rotation*(Math.PI/180)>=0)){\n            distance_to_line_center=-distance_to_line_center\n          }\n\n        }\n        line.positionPoints[grp.shapes_g.indexOf(shape)].distance_to_line_center=shape.distance_to_line_center;\n      \n      }\n\n      let pos = { x: shape.x, y: shape.y };\n\n      //We update the position of the center\n      this.center.x=shape.x;\n      this.center.y=shape.y;\n\n      /*Here, we have to precise the position of the konva node corresponding to the dragged shape.\n      Indeed, if distribution is kept, the distance with the line center and so the position\n      on the line is imposed to the user: When he drag an attached shape, the position of the node is changing regarding its movement.\n      But if we want to impose a position we have to update the node (in addition to the data of the object)*/\n      e.target.position(pos);\n      e.target.getLayer().batchDraw();\n\n      // If the shape is not on the line, we can remove it and recreate it as a free shape on the stage.\n      if(!this.isCoordinateOnLine(shape.x,shape.y,line.id)){\n\n        shape.dragBoundFunc= dragFunc;\n        shape.isGrouped=0;\n        this.shapes.push(shape,)\n        for (let i=0;i<shapes_g.length;i++){\n          if(shapes_g[i].id==shape.id){\n            line.freeDistances.push(line.occupiedDistances[i]);\n            line.occupiedDistances.splice(i,1);\n            shapes_g.splice(i,1);\n            console.log(\"a shape has been removed from the line\");\n          }\n        }\n\n      }else{\n\n        if(!line.keepDistribution){\n          /*If we don't keep distribution, we update the \"occupied distance\"\n          of the shape with the ditance btw the shape and the line's center we calculate before */\n          grp.line.occupiedDistances[shapes_g.indexOf(shape)]=distance_to_line_center;\n        }else{\n          grp.line.occupiedDistances[shapes_g.indexOf(shape)]=shape.distance_to_line_center;\n        }\n        \n        //We update the position point associated to the dragged shape.\n        line.positionPoints[grp.shapes_g.indexOf(shape)].x=shape.x;\n        line.positionPoints[grp.shapes_g.indexOf(shape)].y=shape.y;\n        line.positionPoints[grp.shapes_g.indexOf(shape)].distance_to_line_center=shape.distance_to_line_center;\n        \n      }   \n\n      if(line.keepDistribution){\n        this.updateOccupiedDistance(line.id);\n      }\n      \n      this.updateAllPosInGrp(line.id);\n\n      //If we keep the distance in memory we make sure that if there is a new free position, \n      //the corresponding \"position point\" is draggable and have the good drag bound func \n      //so that we can move it only on the line.\n      if(!line.keepDistribution && line.freeDistances.length>0){\n        let positionPoint=line.positionPoints.find((r)=>r.distance_to_line_center==line.freeDistances[line.freeDistances.length-1]);\n        \n        if(positionPoint.draggable==false){\n          positionPoint.draggable=true;\n          this.updateDragFunc(positionPoint,line);\n        }\n      }\n    },\n\n    updateFreePositionInGrp(e,id_grp){\n      let grp=this.groups.find((r)=>r.id==id_grp);\n      let positionPoint=grp.line.positionPoints.find((r)=>r.id==e.target.attrs.id);\n      let index=grp.line.freeDistances.indexOf(positionPoint.distance_to_line_center);\n      let dist=this.GiveSignOfDistance({x: e.target.x(),y:e.target.y()},grp.line)*this.distBtwShapes({x: e.target.x(),y:e.target.y()},grp.line);\n      \n      if(dist!=grp.line.freeDistances[index]){\n        if(Math.abs(dist)>grp.line.points[4]*grp.line.scaleX/2){\n          dist=Math.sign(dist)*grp.line.points[4]*grp.line.scaleX/2;\n        }\n        grp.line.freeDistances[index]=dist;\n        this.updateAllPosInGrp(id_grp);\n      }\n\n    },\n\n\n\n    /*\n    Function called when the transformation of a shape with a transfomer is finished.\n    */\n    updateTransformedShape(e) {\n      \n\n      let res;\n      let shape; //Object concerned by the transformation\n      if(e.target.className==\"Line\"){\n\n        shape=this.groups.find(\n        (r) => r.id === this.selectedShapeId\n      ).line;\n\n      }else{\n\n        res=this.findShape(this.selectedShapeId)\n        shape=res.shape_data;\n        if(shape== undefined){\n          return;\n        }\n\n      }\n\n      \n      let last_shapex= shape.x;\n      let last_shapey= shape.y;\n\n      //update data of the transformed object.\n      shape.x = e.target.x();\n      shape.y = e.target.y();\n      shape.rotation = e.target.rotation();\n      let last_scaleX= shape.scaleX;\n      shape.scaleX = e.target.scaleX();\n      shape.scaleY = e.target.scaleY();\n\n      //if the transformed object is a stickyline\n      if(e.target.className==\"Line\"){\n        const grp=this.groups.find((r)=> r.id===shape.id);\n\n        if(shape.keepDistribution){\n\n          //We update distances on the line in case it has been resize\n          for (let i=0;i<shape.occupiedDistances.length;i++){\n            shape.occupiedDistances[i]=(shape.occupiedDistances[i]/last_scaleX)*shape.scaleX;\n          }\n          \n          //We do all the necessary update as consequence.\n          this.update();\n          this.updateGrp(e);\n          this.checkIfShapesOnLine(this.selectedShapeId); \n\n        }else{\n          \n          //if the line has been resize\n          if(last_scaleX!=shape.scaleX){\n\n            //If the line has been resize, we update the distances from the shapes to the center of the line \n            for(let i=0;i<grp.shapes_g.length;i++){\n              \n              let distX=grp.shapes_g[i].x-shape.x;\n              let distY=grp.shapes_g[i].y-shape.y;\n              \n              if(Math.sign(grp.line.occupiedDistances[i])==0){\n                \n                grp.line.occupiedDistances[i]=this.GiveSignOfDistance(grp.shapes_g[i],shape)*Math.sqrt((distX)**2 +(distY)**2);\n              \n              }else{\n                grp.line.occupiedDistances[i]=Math.sign(grp.line.occupiedDistances[i])*Math.sqrt((distX)**2 +(distY)**2);\n              }\n\n              \n              if(Math.sign((grp.shapes_g[i].x-last_shapex))!=Math.sign(distX) && Math.sign((grp.shapes_g[i].x-last_shapex))!=0 && grp.line.rotation!=90 && grp.line.rotation!=-90){\n                \n                grp.line.occupiedDistances[i]=-grp.line.occupiedDistances[i];\n              }\n              if(Math.sign((grp.shapes_g[i].y-last_shapey))!=Math.sign(distY) && Math.sign((grp.shapes_g[i].y-last_shapey))!=0 && (grp.line.rotation==90 || grp.line.rotation==-90)){\n                grp.line.occupiedDistances[i]=-grp.line.occupiedDistances[i];\n              }\n\n            }\n            \n            //We update also \"free distances\"\n            for (let i=0;i<shape.freeDistances.length;i++){\n              let distX=last_shapex-shape.x;\n              let distY=last_shapey-shape.y; \n              let dist=Math.sqrt(distX**2+distY**2);\n              if(shape.rotation<-90 ||shape.rotation>90){\n                shape.freeDistances[i]=shape.freeDistances[i]-Math.sign(last_shapex-shape.x)*dist;\n              } else if(shape.rotation==90 || shape.rotation==-90){\n                shape.freeDistances[i]=shape.freeDistances[i]-distY\n              } else{\n                shape.freeDistances[i]=shape.freeDistances[i]+Math.sign(last_shapex-shape.x)*dist;\n              \n              }\n            }\n          }\n\n          //We do the necessary update as consequences.\n          this.update();\n          this.updateGrp(e);\n          this.checkIfShapesOnLine(this.selectedShapeId);\n\n          // We now see if freeDistances need to be deleted(so if they are bigger than the half of the stickyline);\n          let i=0;\n          while(i<shape.freeDistances.length){\n            if((1/2)*((shape.points[4])*shape.scaleX)+2<Math.abs(shape.freeDistances[i])){\n              let corresponding_positionPoint=shape.positionPoints.find((r)=>r.distance_to_line_center==shape.freeDistances[i])\n              let index=shape.positionPoints.indexOf(corresponding_positionPoint);\n              shape.positionPoints.splice(index,1);\n              shape.freeDistances.splice(i,1);\n            }else{\n              i=i+1;\n            }\n          }\n        }\n        //another necessary update\n        for(let i=0;i<grp.shapes_g.length;i++){\n            \n          this.updateDragFunc(grp.shapes_g[i],shape);\n\n        }\n        for(let i=0;i<grp.line.positionPoints.length;i++){\n            \n          this.updateDragFunc(grp.line.positionPoints[i],shape);\n\n        }\n\n      }else if(res.grp_id!='-1'){\n        //In this case, the object that has been transformed is not a stickyline\n\n        /*res.grp_id!=-1 means that the shape that has been find with \n        the method findShape is part of group with id=res.grp_id*/\n\n        this.groups.find((r)=>r.id===res.grp_id).shapes_g.find((r)=>r.id===e.target.id()).personalRotation=e.target.rotation()-e.target.getParent().attrs.line.rotation;\n        \n\n        this.updateAllPosInGrp(res.grp_id);\n        this.updateOccupiedDistance(res.grp_id);\n        \n        /*We actualize the target node in order to no wait actualization of the DOM regarding vue component's data \n        to show the shape at the good position.*/\n        e.target.x(e.target.getParent().attrs.shapes_g.find((r)=>r.id===e.target.id()).x);\n        e.target.y(e.target.getParent().attrs.shapes_g.find((r)=>r.id===e.target.id()).y);\n        //this.groups.find((r)=>r.id===res.grp_id).shapes_g.find((r)=>r.id===e.target.id()).personalRotation=e.target.rotation()-e.target.getParent().attrs.line.rotation;\n        \n        //this.updateAllPosInGrp(res.grp_id);\n        this.checkIfShapesOnLine(res.grp_id);\n        this.updateDragFuncOfCenter(); \n      \n      }\n      else{\n        this.update();\n        this.updateDragFuncOfCenter();\n      }\n\n      //We update the center position\n      this.center.x=e.target.attrs.x;\n      this.center.y=e.target.attrs.y;\n    },\n    \n    /*\n    Called when we touch anything on the stage (including nothing).\n    In particular, it put a transformer if the target can be transform.\n    If we are in \"eraser mode\", this method call the method eraserAction.\n    */\n    handleTransformation(e) {\n      document.getElementById(\"input\").style.display=\"none\"; //if the input for modifying the text is here, we make it disappear\n\n      //for prevention\n      if (e.evt==undefined) {\n        return;\n      }\n      //if we are in \"eraser mode\", we call the method eraserAction on the target.\n      if(this.eraseMode==1){\n        this.eraserAction(e);\n        return;\n      }\n      \n      //If we click on the stage, we have to remove the transformer from the node where it was.\n      if (e.target === e.target.getStage()) {\n        this.selectedShapeId = 'NoId';\n        this.eraseNodefromTransformer(\"lineTransformer\");\n        this.eraseNodefromTransformer(\"shapeTransformer\");\n        this.center.visible=false;\n        return;\n      }\n\n      // If we click on a transformer, nothing happen.\n      const clickedOnTransformer = e.target.getParent().className === 'Transformer';\n      if (clickedOnTransformer) {\n        return;\n      }\n      \n      const id = e.target.id();\n      let transformer_id;\n      let shape=this.findShape(id).shape_data;\n\n      //if we click on the center or \"position points\" we do nothing.\n      if(e.target.attrs.id==\"center\" || e.target.attrs.className==\"positionPoint\"){\n        return;\n      }\n\n      //if it is a line, we need the transformer dedicated to the line (ie transformer with id=\"lineTransformer\")\n      //if it is a classic shape, we need the transformer dedicated to the shape (ie transformer with id=\"shapeTransformer\")\n      if(e.target.className==\"Line\"){\n        transformer_id=\"lineTransformer\"\n        shape = this.groups.find((r) => r.id === id).line;\n        this.center.draggable=false;\n        this.selectedShapeAlignment=shape.defaultAlignment;\n        this.eraseNodefromTransformer(\"shapeTransformer\");\n      }else{\n        transformer_id=\"shapeTransformer\"\n        this.center.draggable=true;\n        this.selectedShapeAlignment=shape.centerPosition;\n        this.eraseNodefromTransformer(\"lineTransformer\");\n      }\n      \n      if (shape!=undefined) {\n        this.selectedShapeId = id;\n        this.center.visible=true; // We make the center visible on the target shape\n        this.updateTransformer(transformer_id); //We update the transformer\n      } else{\n        this.selectedShapeId = 'NoId';\n      }\n      \n      this.updateDragFuncOfCenter() //We update the drag function of the center accordingly to the target shape's orientaion.\n    },\n\n    //remove node from transformer with id=transformer_id\n    eraseNodefromTransformer(transformer_id) {\n      let stage= this.$refs.stage.getStage();      \n      const transformerNode = stage.find(\"#\"+transformer_id)[0]; \n      transformerNode.nodes([]);\n    },\n\n    //Update transformer with id=transformer_id\n    //It places the transformer regarding what node is selected\n    updateTransformer(transformer_id) {\n      \n      let stage= this.$refs.stage.getStage();\n      let transformerNode = stage.find(\"#\"+transformer_id)[0];\n      let selectedNode;\n      if (transformer_id==\"lineTransformer\"){\n        //if the transformer is the one for stickylines, it means that the selectedNode has to be a stickyline\n        selectedNode = stage.children[0].getChildren().filter((r)=> r.attrs.className==\"Group\" && r.attrs.id==this.selectedShapeId)[0]\n        .getChildren().filter(r=>r.attrs.className==\"Line\" && r.attrs.id==this.selectedShapeId)[0];\n      }else{\n        selectedNode = stage.children[0].getChildren().filter((r)=>r.attrs.className!=\"Group\" && r.attrs.id==this.selectedShapeId)[0];\n\n        let isFunded=true;\n        if(selectedNode==undefined){\n          isFunded=false;\n        }\n        let i=0;\n\n        //If we selectedNode is undefined it means that the selected node is an atttached shape and not a free one.\n        //The follow loop is executed in order to find this node.\n        while(!isFunded){\n          if(i<this.groups.length){\n            selectedNode=stage.children[0].getChildren().filter((r)=>r.attrs.className==\"Group\")[i].getChildren().find((r)=>r.attrs.id==this.selectedShapeId && r.attrs.className!=\"Line\");\n          if(selectedNode==undefined){\n            isFunded=false;\n          }else{\n            isFunded=true;\n          }\n          i++;\n          }else{        \n            isFunded=true;\n          }\n        }\n      }\n      \n     \n      //If the selected node has already the transformer on it, nothing happen\n      if (selectedNode === transformerNode.node()) {\n        return;\n      }\n\n      //If a node is selected\n      if (selectedNode!=undefined) {\n        //We attach the transformer to the node\n        transformerNode.nodes([selectedNode]);\n      } else {\n        //if no node is selected, we remove the transformer from its node.\n        transformerNode.nodes([]);\n      }\n\n      this.center.x=selectedNode.attrs.x;\n      this.center.y=selectedNode.attrs.y;\n      \n    },\n\n    //Called to display the center menu\n    DisplayCenterMenu(e){\n      CenterMenu.props.ConcernedShape=e.target;\n      document.getElementById(\"center_menu\").style.display=\"initial\";\n      document.getElementById(\"center_menu\").style.top=document.getElementById(\"playground\").getBoundingClientRect().top+document.documentElement.scrollTop+e.target.getStage().getPointerPosition().y+\"px\";\n      document.getElementById(\"center_menu\").style.left=document.getElementById(\"playground\").getBoundingClientRect().left+document.documentElement.scrollLeft+e.target.getStage().getPointerPosition().x+\"px\";\n    },\n\n    /*display context menu according to the target\n    This method is called when the contextMenu event occur*/\n    DisplayContextMenu(e){\n\n      e.evt.preventDefault() //This line allow to not show the context menu of the web browser\n      \n\n      //The context menu that is shown depends on the target\n      if (e.target.className!=undefined && e.target.attrs.id!=\"center\"){\n        this.isStageOnlySelected=false;\n        ContextMenu.data().dM='initial';\n        this.$emit('needmenu');\n        this.needMenu=true;\n        ContextMenu.props.ConcernedShape=e.target;\n        if (e.target.attrs.className==\"Line\"){\n          this.isALineSelected=true;\n          this.isAGroupedShapeSelected=true;\n          //We precise the text which depends on the line where we clicked.\n          this.keepDistanceButtonText=e.target.attrs.keepDistanceButtonText;\n        } else if(e.target.getParent().attrs.className==\"Group\"){\n          this.isAGroupedShapeSelected=true;\n        }\n        else{\n          this.isALineSelected=false;\n          this.isAGroupedShapeSelected=false;\n        }\n        document.getElementById(\"active\").style.display=\"initial\";\n        document.getElementById(\"active\").style.top=document.getElementById(\"playground\").getBoundingClientRect().top+document.documentElement.scrollTop+e.target.getStage().getPointerPosition().y+70+\"px\";\n        document.getElementById(\"active\").style.left=document.getElementById(\"playground\").getBoundingClientRect().left+document.documentElement.scrollLeft+e.target.getStage().getPointerPosition().x-50+\"px\";\n    \n      }\n      if (e.target === e.target.getStage()) {\n        this.needMenu=true;\n        this.isALineSelected=false;\n        this.isAGroupedShapeSelected=false;\n        this.isStageOnlySelected=true;\n        document.getElementById(\"active\").style.display=\"initial\";\n        document.getElementById(\"active\").style.top=document.getElementById(\"playground\").getBoundingClientRect().top+document.documentElement.scrollTop+e.target.getStage().getPointerPosition().y+70+\"px\";\n        document.getElementById(\"active\").style.left=document.getElementById(\"playground\").getBoundingClientRect().left+document.documentElement.scrollLeft+e.target.getStage().getPointerPosition().x-50+\"px\";\n    \n      }\n    },\n\n    //hide context menu\n    HideContextMenu(){\n      this.needMenu=false;\n      document.getElementById(\"active\").style.display=\"none\";\n      document.getElementById(\"center_menu\").style.display=\"none\";\n    },\n\n\n\n    \n    /*\n    //deprecated\n    ChangeShapeCenter(shape){\n        if(shape.className==\"Rect\") {\n          if(shape.offsetX==shape.width/2 && shape.offsetY==0){\n            shape.offsetX=shape.width/2;\n            shape.offsetY=shape.height/2;\n          }else if(shape.offsetX==shape.width/2 && shape.offsetY==shape.height/2){\n            shape.offsetX=shape.width/2;\n            shape.offsetY=shape.height;\n          }\n          else if(shape.offsetX==shape.width/2 && shape.offsetY==shape.height){\n            shape.offsetX=shape.width/2;\n            shape.offsetY=0;\n          }\n        }\n        else if(shape.className==\"Circle\") {\n          if(shape.offsetX==0 && shape.offsetY==-shape.radius){\n            shape.offsetX=0;\n            shape.offsetY=0;\n          }else if (shape.offsetX==0 && shape.offsetY==0){\n            shape.offsetX=0;\n            shape.offsetY=shape.radius;\n          }else{\n            shape.offsetX=0;\n            shape.offsetY=-shape.radius;\n          }\n        }\n        else if(shape.className==\"Text\") {\n          if(Math.abs(shape.offsetX-shape.length_x/2)<=1 && shape.offsetY==0){\n            shape.offsetX=shape.length_x/2;\n            shape.offsetY=shape.length_y/2;\n          }else if (Math.abs(shape.offsetX-shape.length_x/2)<=1 && Math.abs(shape.offsetY-shape.length_y/2)<=1){\n            shape.offsetX=shape.length_x/2;\n            shape.offsetY=shape.length_y;\n          }else{\n            shape.offsetX=shape.length_x/2;\n            shape.offsetY=0;\n          }\n        }\n        else if(shape.className==\"Image\") {\n          if(shape.offsetX==shape.image.width/2 && shape.offsetY==0){\n            shape.offsetX=shape.image.width/2;\n            shape.offsetY=shape.image.height/2;\n          }else if (shape.offsetX==shape.image.width/2 && shape.offsetY==shape.image.height/2){\n            shape.offsetX=shape.image.width/2;\n            shape.offsetY=shape.image.height;\n          }else{\n            shape.offsetX=shape.image.width/2;\n            shape.offsetY=0;\n          }\n        }\n\n    },\n    */\n\n    /*This method is call after the center has been draging.\n      It update the position of the center of selected shape according to the position of the center (the object) on the shape.\n    */\n    ChangeCenter(e){\n\n      let res=this.findShape(this.selectedShapeId);\n      let shape=res.shape_data;\n      let threshold1;\n      let threshold2;\n\n      //dist btw the center (the object) and the center of the selected shape.\n      let dist=this.GiveSignOfDistanceBtwCenterAndShape(e.target.attrs,shape)*Math.sqrt((e.target.y()-(shape.y))**2+(e.target.x()-shape.x)**2)+shape.offsetY*shape.scaleY;\n      \n      //let last_offsetX=shape.offsetX;\n      let last_offsetY=shape.offsetY;\n      if(shape==undefined){\n\n        //if shape is undefined, the selected shape has to be a stickyline\n        shape=this.groups.find((r)=>r.id==this.selectedShapeId).line;\n\n      }else{\n          //The calcultation to set position of the center depends on the type of shapes.\n          if(shape.className==\"Rect\") {\n            threshold1=shape.height*shape.scaleY/3;\n            threshold2=shape.height*shape.scaleY*2/3;\n            if(dist>=threshold1 && dist<=threshold2){\n              shape.offsetX=shape.width/2;\n              shape.offsetY=shape.height/2;\n              shape.centerPosition=\"Middle\";\n            }else if(dist>threshold2){\n              shape.offsetX=shape.width/2;\n              shape.offsetY=shape.height;\n              shape.centerPosition=\"Bottom\";\n            }\n            else{\n              shape.offsetX=shape.width/2;\n              shape.offsetY=0;\n              shape.centerPosition=\"Top\";\n            }\n          }\n          else if(shape.className==\"Circle\") {\n            dist=dist+shape.radius*shape.scaleY;\n            threshold1=shape.radius*shape.scaleY*2/3;\n            threshold2=shape.radius*shape.scaleY*4/3;\n            if(dist>=threshold1 && dist<=threshold2){\n              shape.offsetX=0;\n              shape.offsetY=0;\n              shape.centerPosition=\"Middle\";\n            }else if(dist>threshold2){\n              shape.offsetX=0;\n              shape.offsetY=shape.radius;\n              shape.centerPosition=\"Bottom\";\n            }else{\n              shape.offsetX=0;\n              shape.offsetY=-shape.radius;\n              shape.centerPosition=\"Top\";\n            } \n          }\n          else if(shape.className==\"Image\") {\n            threshold1=shape.image.height*shape.scaleY/3;\n            threshold2=shape.image.height*shape.scaleY*2/3;\n            if(dist>=threshold1 && dist<=threshold2){\n              shape.offsetX=shape.image.width/2;\n              shape.offsetY=shape.image.height/2;\n              shape.centerPosition=\"Middle\";\n            }else if(dist>threshold2){\n              shape.offsetX=shape.image.width/2;\n              shape.offsetY=shape.image.height;\n              shape.centerPosition=\"Bottom\";\n            }\n            else {\n              shape.offsetX=shape.image.width/2;\n              shape.offsetY=0;\n              shape.centerPosition=\"Top\";\n            }\n          }\n          else if(shape.className==\"Text\") {\n            threshold1=shape.length_y*shape.scaleY/3;\n            threshold2=shape.length_y*shape.scaleY*2/3;\n            if(dist>=threshold1 && dist<=threshold2){\n              shape.offsetX=shape.length_x/2;\n              shape.offsetY=shape.length_y/2;\n              shape.centerPosition=\"Middle\";\n            }else if(dist>threshold2){\n              shape.offsetX=shape.length_x/2;\n              shape.offsetY=shape.length_y;\n              shape.centerPosition=\"Bottom\";\n            }\n            else{\n              shape.offsetX=shape.length_x/2;\n              shape.offsetY=0;\n              shape.centerPosition=\"Top\";\n            }\n          }\n          else if(shape.className==\"Triangle\") {\n            dist=dist+shape.radius*shape.scaleY;\n            threshold1=shape.radius*shape.scaleY/2;\n            threshold2=shape.radius*shape.scaleY*5/4;\n            if(dist>=threshold1 && dist<=threshold2){\n              shape.offsetX=0;\n              shape.offsetY=0;\n            }else if(dist>threshold2){\n              shape.offsetX=0;\n              shape.offsetY=shape.radius/2\n              shape.centerPosition=\"Bottom\";\n            }\n            else{\n              shape.offsetX=0;\n              shape.offsetY=-shape.radius;\n              shape.centerPosition=\"Top\";\n            }\n          }\n\n          /*We update the position of the selected shape so that the change of position for the center \n          doesn't give the impression to the user that the shape is moving.*/\n          shape.y=shape.y-(last_offsetY-shape.offsetY)*shape.scaleY*Math.cos(shape.rotation*(Math.PI/180));\n          shape.x=shape.x+(last_offsetY-shape.offsetY)*shape.scaleY*Math.sin(shape.rotation*(Math.PI/180));\n\n          this.selectedShapeAlignment=shape.centerPosition;\n\n          \n          if (res.grp_id!='-1'){\n            this.updateAllPosInGrp(res.grp_id);\n          }\n          \n          /*To be sure that the shape is shown at the good position instead of waiting the reactualizatipon of the DOM\n          regarding the vue component's data*/\n          e.target.x(shape.x);\n          e.target.y(shape.y);   \n      }\n    },\n\n\n    /*Called when the event center-button is emitted by the vue component CenterMenu.\n    This event is emitted with a string (align_choice) which contains the chosen position for the center */\n    ChangeAlignCenter(align_choice){\n\n      let center=CenterMenu.props.ConcernedShape;\n      let grp=this.groups.find((r)=>r.id===this.selectedShapeId);\n      let shape;\n\n      //If the selected \"shape\" is actually a Stickyline\n      if(grp!=undefined){\n\n        //We change center's position of all attached shapes of the group grp.\n        for(let i=0;i<grp.shapes_g.length;i++){\n          this.ChangeCenterRegardingCommand(grp.shapes_g[i].id,align_choice)\n        }\n\n        /*update position of the center object\n        You can not that we doesn\"t really need to save it in the vue commnent's data\n        because its position is always updated when we select an object or drag something. */\n        center.x(grp.line.x);\n        center.y(grp.line.y);\n\n        if(grp.line.defaultAlignment==align_choice){\n          /*If we select again the same align_choice, we deselect it, no alignement center is fixed\n          by default for new attached shapes.*/\n          grp.line.defaultAlignment='' \n        }else{\n          grp.line.defaultAlignment=align_choice;\n        }\n        this.selectedShapeAlignment=grp.line.defaultAlignment;\n\n      }else{\n        shape=this.findShape(this.selectedShapeId).shape_data;\n        this.ChangeCenterRegardingCommand(shape.id,align_choice)\n        this.selectedShapeAlignment=shape.centerPosition;\n\n        //update position of the center object\n        center.x(shape.x);\n        center.y(shape.y);\n      }\n    },\n\n    //Allow to change the center regarding a text command (Top,Middle or Bottom)\n    ChangeCenterRegardingCommand(shape_id,command){\n\n      let res=this.findShape(shape_id);\n      let shape=res.shape_data;\n      let last_offsetY=shape.offsetY;\n\n      if(shape.className==\"Rect\" ){\n        if(command==\"Top\"){\n          shape.offsetY=0;\n          shape.offsetX=shape.width/2;\n        }\n        else if(command==\"Middle\"){\n            shape.offsetX=shape.width/2;\n            shape.offsetY=shape.height/2;\n        }else if(command==\"Bottom\"){\n              shape.offsetX=shape.width/2;\n              shape.offsetY=shape.height;\n        }\n      }\n      else if(shape.className==\"Circle\") {\n        if(command==\"Top\"){\n          shape.offsetX=0;\n          shape.offsetY=-shape.radius;\n        }else if(command==\"Middle\"){\n          shape.offsetX=0;\n          shape.offsetY=0\n        }else if(command==\"Bottom\"){\n          shape.offsetX=0;\n          shape.offsetY=shape.radius;\n        } \n      }\n      else if(shape.className==\"Image\") {\n        if(command==\"Middle\"){\n          shape.offsetX=shape.image.width/2;\n          shape.offsetY=shape.image.height/2;\n        }else if(command==\"Bottom\"){\n          shape.offsetX=shape.image.width/2;\n          shape.offsetY=shape.image.height;\n        }\n        else if (command==\"Top\"){\n          shape.offsetX=shape.image.width/2;\n          shape.offsetY=0;\n        }\n      }\n      else if(shape.className==\"Text\") {\n        if(command==\"Middle\"){\n          shape.offsetX=shape.length_x/2;\n          shape.offsetY=shape.length_y/2;\n        }else if(command==\"Bottom\"){\n          shape.offsetX=shape.length_x/2;\n          shape.offsetY=shape.length_y;\n        }\n        else if(command==\"Top\"){\n          shape.offsetX=shape.length_x/2;\n          shape.offsetY=0;\n        }\n      }\n      else if(shape.className==\"Triangle\") {\n        if(command==\"Middle\"){\n          shape.offsetX=0;\n          shape.offsetY=0;\n        }else if(command==\"Bottom\"){\n          shape.offsetX=0;\n          shape.offsetY=shape.radius/2;\n        }\n        else if(command==\"Top\"){\n          shape.offsetX=0;\n          shape.offsetY=-shape.radius;\n        }\n      }\n      shape.centerPosition=command;\n      shape.y=shape.y-(last_offsetY-shape.offsetY)*shape.scaleY*Math.cos(shape.rotation*(Math.PI/180));\n      shape.x=shape.x+(last_offsetY-shape.offsetY)*shape.scaleY*Math.sin(shape.rotation*(Math.PI/180));\n\n      if (res.grp_id!='-1'){\n        this.updateAllPosInGrp(res.grp_id);\n      }         \n    },\n\n    /*update the drag bound func of the center (the object)*/\n    updateDragFuncOfCenter(){\n      let shape=this.findShape(this.selectedShapeId).shape_data\n      if(shape==undefined){\n        return;\n      }\n      let center=this.center;\n      let angle=shape.rotation*(Math.PI/180);\n      if(angle>=-Math.PI/2 && angle<=0){\n        angle-=90*(Math.PI/180);\n      }else if(angle<-Math.PI/2){\n        angle+=(Math.PI/2);\n        angle=Math.PI+angle;\n      } else if(angle<=Math.PI && angle>0){\n        angle-=90*(Math.PI/180);\n      } \n      if (angle<=0 && angle>=-Math.PI/4){\n        center.dragBoundFunc= function (pos) {\n          return {\n            x: shape.x +(pos.x-shape.x)*Math.cos(angle),\n            y: shape.y+(pos.x-shape.x)*Math.sin(angle),\n          };\n        }\n      } else if (angle<-Math.PI/4 && angle>=-Math.PI/2){\n        center.dragBoundFunc= function (pos) {\n          return {\n            x: shape.x-(pos.y-shape.y)*Math.cos(angle),\n            y: shape.y-(pos.y-shape.y)*Math.sin(angle),\n          };\n        }\n      }\n      else if (angle<-Math.PI/2 && angle>=-3*Math.PI/4){\n        center.dragBoundFunc= function (pos) {\n          return {\n            x: shape.x-(pos.y-shape.y)*Math.cos(angle),\n            y: shape.y-(pos.y-shape.y)*Math.sin(angle),\n          };\n        }\n      } else if (angle<-3*Math.PI/4 && angle>=-Math.PI){\n        center.dragBoundFunc= function (pos) {\n          return {\n            x: shape.x-(pos.x-shape.x)*Math.cos(angle),\n            y: shape.y-(pos.x-shape.x)*Math.sin(angle),\n          };\n        }\n      }else if (angle<=Math.PI && angle>=3*Math.PI/4){\n        center.dragBoundFunc= function (pos) {\n          return {\n            x: shape.x-(pos.x-shape.x)*Math.cos(angle),\n            y: shape.y-(pos.x-shape.x)*Math.sin(angle),\n          };\n        }\n      } else if (angle<3*Math.PI/4 && angle>=Math.PI/2){\n        center.dragBoundFunc= function (pos) {\n          return {\n            x: shape.x+(pos.y-shape.y)*Math.cos(angle),\n            y: shape.y+(pos.y-shape.y)*Math.sin(angle),\n          };\n        }\n      } else if (angle<Math.PI/2 && angle>=Math.PI/4){\n        center.dragBoundFunc= function (pos) {\n          return {\n            x: shape.x+(pos.y-shape.y)*Math.cos(angle),\n            y: shape.y+(pos.y-shape.y)*Math.sin(angle),\n          };\n        }\n      }else if (angle<Math.PI/4 && angle>=0){\n        center.dragBoundFunc= function (pos) {\n          return {\n            x: shape.x+(pos.x-shape.x)*Math.cos(angle),\n            y: shape.y+(pos.x-shape.x)*Math.sin(angle),\n          };\n        }\n      }\n    },\n\n    \n    //deprecated\n    ChangeCenterButtonAction(){\n      let shape= ContextMenu.props.ConcernedShape;\n      if(shape.attrs.className==\"Line\"){\n        let shapes_g=shape.getParent().attrs.shapes_g //the list of the shapes which are on the line is in the corresponding group.\n        for (let j=0;j<shapes_g.length;j++){\n          this.ChangeCenter(shapes_g[j]);\n        }\n      }else{\n        let shape_data=this.shapes.find(i => i.id ===shape.attrs.id);\n        let isFunded=true;\n        if(shape_data==undefined){\n          isFunded=false;\n        }\n        let i=0;\n        while(!isFunded){\n          if(i<this.groups.length){\n            shape_data=this.groups[i].shapes_g.find(i => i.id === shape.attrs.id);\n          if(shape_data==undefined){\n            isFunded=false;\n          }else{\n            isFunded=true;\n          }\n          i++;\n          }else{        \n            isFunded=true;\n          }\n        }\n        this.ChangeCenter(shape_data)\n      }\n    },\n    \n      \n    //to copy an obejct alone\n    Copy(){\n      ContextMenu.props.CopiedShape=ContextMenu.props.ConcernedShape;\n      ContextMenu.props.pastOneObject=true;\n    },\n\n    //to copy a group.\n    CopyAll(){\n      ContextMenu.props.CopiedShape=ContextMenu.props.ConcernedShape;\n      ContextMenu.props.pastOneObject=false;\n    },\n\n    //to past a copied shape/group\n    Past(){   \n\n      //Prevent error when no shape is copied\n      if(ContextMenu.props.CopiedShape.attrs==undefined){\n        return;\n      }\n      \n      /*We clone the copied shape changing its id by the same time.\n      The id must be unique.*/\n      let clone=ContextMenu.props.CopiedShape.clone({\n        id: ''+this.max_id_figures,\n      })\n      \n      let i= this.groups.length\n      \n      //If we copy a line\n      if(ContextMenu.props.CopiedShape.attrs.className==\"Line\"){\n        this.max_id_figures=this.max_id_figures+1;\n\n        //If we decide to copy the line with all the shapes attached to it (we copy a group)\n        if(!ContextMenu.props.pastOneObject){\n        \n          //clone of the group\n          clone=ContextMenu.props.CopiedShape.getParent().clone({\n            id: ''+ this.max_id_figures,\n            name: \"group\"+this.max_id_figures,\n            shapes_g:[],\n          })\n\n          //updating line of the cloned group. \n          clone.attrs.line.id=''+this.max_id_figures;\n          clone.attrs.line.x=ContextMenu.props.ConcernedShape.getStage().getPointerPosition().x;\n          clone.attrs.line.y=ContextMenu.props.ConcernedShape.getStage().getPointerPosition().y;\n\n          //Remove and add new positionPoints\n          let positionPoints=Object.assign([],clone.attrs.line.positionPoints);\n          let length=positionPoints.length;\n          clone.attrs.line.positionPoints=[];\n          for(let i=0;i<length.valueOf();i++){\n            let clone_positionPoint=ContextMenu.props.CopiedShape.getParent().getChildren().find((r)=>r.attrs.id===positionPoints[i].id).clone({\n            id:'positionPoint'+clone.attrs.line.id+i,\n            });\n            clone.attrs.line.positionPoints.push(clone_positionPoint.attrs,);\n          }\n\n          //We add the cloned group to the vue component's data.\n          this.groups.push(clone.attrs,);\n\n          //We remove and add again attached shapes by cloning.\n          let shapesg=this.groups[this.groups.indexOf(this.groups.find((r)=> r.id==ContextMenu.props.CopiedShape.getParent().attrs.id))].shapes_g;\n          let shapesg_length=shapesg.length;\n          for (let j=0; j<shapesg_length;j++){\n            this.max_id_figures=this.max_id_figures + 1;\n            let clone_shape=ContextMenu.props.CopiedShape.getParent().getChildren().find((r)=>r.attrs.id===shapesg[j].id).clone({\n              id:''+this.max_id_figures,\n            });\n            this.groups[i].shapes_g.push(clone_shape.attrs,);\n            this.updateDragFunc(this.groups[i].shapes_g[this.groups[i].shapes_g.length-1],this.groups[i].line);\n          }\n          \n          this.updateAllPosInGrp(clone.attrs.id);\n\n        }else{\n          //We clone just a line without its attached shapes\n\n          clone=ContextMenu.props.CopiedShape.getParent().clone({\n            id: ''+this.max_id_figures,\n            name: \"group\"+this.max_id_figures,\n            shapes_g:[],\n          })\n          clone.attrs.line.id=''+this.max_id_figures;\n          clone.attrs.line.x=ContextMenu.props.ConcernedShape.getStage().getPointerPosition().x;\n          clone.attrs.line.y=ContextMenu.props.ConcernedShape.getStage().getPointerPosition().y;\n\n          //All occupied positions become free positions.\n          for(let j=0;j<clone.attrs.line.occupiedDistances.length;j++){\n            clone.attrs.line.freeDistances.push(clone.attrs.line.occupiedDistances[j],);\n          }\n          clone.attrs.line.occupiedDistances=[];\n\n          /*If the positions are kept on the line (no fixed distribution),\n          we have to show positions points. So we clone them too.*/\n          if(clone.attrs.line.keepDistribution!=1){\n            let positionPoints=Object.assign([],clone.attrs.line.positionPoints);\n            let length=positionPoints.length;\n            clone.attrs.line.positionPoints=[];\n            for(let i=0;i<length.valueOf();i++){\n              let clone_positionPoint=ContextMenu.props.CopiedShape.getParent().getChildren().find((r)=>r.attrs.id===positionPoints[i].id).clone({\n              id:'positionPoint'+clone.attrs.line.id+i,\n              });\n              clone.attrs.line.positionPoints.push(clone_positionPoint.attrs,);\n            }\n          }\n\n          this.groups.push(clone.attrs,)\n        }\n\n        //In order to actualize the new line (in particular to show the positionPoints):\n        this.updateAllPosInGrp(clone.attrs.id)\n      } \n      else{\n        //We clone just a shape\n\n        this.max_id_figures=this.max_id_figures + 1;\n        clone=ContextMenu.props.CopiedShape.clone({\n          id: ''+this.max_id_figures,  \n          x:ContextMenu.props.ConcernedShape.getStage().getPointerPosition().x,\n          y:ContextMenu.props.ConcernedShape.getStage().getPointerPosition().y,\n        });\n\n        //The shape is free so we make sure that its drag bound func doesn't limit its movement.\n        clone.attrs.dragBoundFunc=function (pos) {\n          return {\n            x: pos.x,\n            y: pos.y,\n          };\n        };\n        clone.attrs.isGrouped=0;\n        this.shapes.push(clone.attrs,); \n         \n      } \n    },\n\n    \n    //to remove a shape\n    Remove(shape){\n      \n      //If we erase a stickyline\n      if(shape.attrs.className==\"Line\"){\n        //We have to be sure that all attached shapes are not remove and that they become free.\n\n        let grp=this.groups.find((r)=>r.id===shape.attrs.id);\n        const length=grp.shapes_g.length;\n\n        //We remove the attached shapes to add them as free shapes on the stage.\n        for(let i=0;i<length;i++){\n          grp.shapes_g[i].dragBoundFunc= dragFunc;\n          grp.shapes_g[i].isGrouped=0;\n          this.shapes.push(grp.shapes_g[i],);\n        }\n        this.eraseNodefromTransformer(\"lineTransformer\");\n\n        //We erase the group\n        this.groups.splice(this.groups.indexOf(grp),1);\n        shape.getParent().destroy();\n\n        //We give to the circle (representing center of shapes) a default position\n        if(this.groups[0]!=undefined){\n          this.center.x=this.groups[0].line.x;\n          this.center.y=this.groups[0].line.y;\n        } else if(this.shapes[0]!=undefined){\n          this.center.x=this.shapes[0].x;\n          this.center.y=this.shapes[0].y;\n        }\n        this.center.visible=false;\n        \n      }else if(shape.attrs.className==\"positionPoint\"){\n        //If we remove a \"position point\"\n\n\n        let line=shape.getParent().attrs.line;\n        let target_positionPoint=line.positionPoints.find((r)=>r.id===shape.attrs.id); //position point we want to remove\n        let index=line.freeDistances.indexOf(shape.attrs.distance_to_line_center);\n        \n        if(line.keepDistribution!=1 && index!=-1){\n          line.freeDistances.splice(index,1);// we remove the free position where the target position point is.\n          line.positionPoints.splice(line.positionPoints.indexOf(target_positionPoint),1)\n        }\n      }\n      else{\n        //If we just remove a shape\n\n        let res=this.findShape(shape.attrs.id)\n        let shape_data=res.shape_data;\n        let grp_id=res.grp_id;\n\n        if(shape_data!=undefined){\n\n          //if the shape is an attached one\n          if(grp_id!='-1'){\n\n            let grp=this.groups.find((r)=>r.id===grp_id);\n            grp.line.freeDistances.push(grp.line.occupiedDistances[grp.shapes_g.indexOf(shape_data)],)\n            grp.line.occupiedDistances.splice(grp.shapes_g.indexOf(shape_data),1)\n            \n            grp.shapes_g.splice(grp.shapes_g.indexOf(shape_data),1);\n            this.updateOccupiedDistance(grp.id);\n            \n            this.updateAllPosInGrp(grp.id);\n\n            //We make sure that the corresponding \"position point\" of the new free position \n            //is draggable and have the good drag bound func so that we can move it only on the line.\n            let positionPoint=grp.line.positionPoints.find((r)=>r.distance_to_line_center==grp.line.freeDistances[grp.line.freeDistances.length-1]);\n            positionPoint.draggable=true;\n            this.updateDragFunc(positionPoint,grp.line);\n          \n        \n          } else{\n\n            this.eraseNodefromTransformer(\"shapeTransformer\");\n            this.shapes.splice(this.shapes.indexOf(shape_data),1);\n            //We give to the circle (representing center of shapes) a default position\n            if(this.groups[0]!=undefined){\n              this.center.x=this.groups[0].line.x;\n              this.center.y=this.groups[0].line.y;\n            } else if(this.shapes[0]!=undefined){\n              this.center.x=this.shapes[0].x;\n              this.center.y=this.shapes[0].y;\n            }\n            this.center.visible=false;\n\n          }\n          shape.destroy();\n        }\n      }\n    },\n\n    //deprecated\n    RemoveAll(){\n      let shape=ContextMenu.props.ConcernedShape;\n      if(shape.className==\"Line\"){\n        let grp=this.groups.find((r)=>r.id===shape.attrs.id);\n        while(grp.shapes_g.length!=0){\n          grp.shapes_g[0].dragBoundFunc= dragFunc;\n          grp.shapes_g.splice(0,1);\n        }\n        this.eraseNodefromTransformer(\"lineTransformer\");\n        this.groups.splice(this.groups.indexOf(grp),1);\n        shape.getParent().destroy();\n\n        //We give to the circle (representing center of shapes) a default position\n        if(this.groups[0]!=undefined){\n          this.center.x=this.groups[0].line.x;\n          this.center.y=this.groups[0].line.y;\n        } else if(this.shapes[0]!=undefined){\n          this.center.x=this.shapes[0].x;\n          this.center.y=this.shapes[0].y;\n        }\n        \n      }else{\n        return;\n      }\n    },\n\n    /*Allow to find a shape by giving its id.\n    The method returns the shape data and, if it is attached, the id of its group (-1 otherwise).*/\n    findShape(id){\n\n      let shape_data=this.shapes.find(i => i.id ===id);\n      let grp_id='-1'; // return grp_id=-1 if the shape doesn't belong to attached group.\n      let isFunded=true;\n\n      if(shape_data==undefined){\n        isFunded=false;\n      }\n\n      let i=0;\n      while(!isFunded){\n        if(i<this.groups.length){\n          shape_data=this.groups[i].shapes_g.find(i => i.id === id);\n        if(shape_data==undefined){\n          isFunded=false;\n        }else{\n          grp_id=this.groups[i].id; \n          isFunded=true;\n        }\n        i++;\n        }else{        \n          isFunded=true;\n        }\n      }\n\n      return {shape_data, grp_id}\n    },\n\n    /*method to detach a shape from its line.\n    target_x and target_y should be the position of the mouse.\n    */\n    DetachShape(shape,target_x,target_y){\n      \n      \n      const added_distance=this.lengthToCapture+10; //distance added bewteen the shape and the line after the shape has been detached\n      \n      let grp=this.groups.find((r)=>r.shapes_g.indexOf(shape)!=-1);\n      let i=grp.shapes_g.indexOf(shape);\n      \n      shape.dragBoundFunc= dragFunc; //We give to the shape the drag bound function of free shapes.\n\n      let coord_y1=grp.line.y-grp.line.points[4]*(1/2)*grp.line.scaleX*Math.sin(grp.line.rotation*(Math.PI/180));\n      let coord_x2=grp.line.x+grp.line.points[4]*(1/2)*grp.line.scaleX*Math.cos(grp.line.rotation*(Math.PI/180));\n      let coord_y2= grp.line.y+grp.line.points[4]*(1/2)*grp.line.scaleX*Math.sin(grp.line.rotation*(Math.PI/180));\n      let coord_x1=grp.line.x-grp.line.points[4]*(1/2)*grp.line.scaleX*Math.cos(grp.line.rotation*(Math.PI/180));\n      let a=(coord_y2-coord_y1)/(coord_x2-coord_x1);\n      let b=shape.x*(1/a)+shape.y;\n\n      //We add the distance added_distance by paying attention to the rotation of the line.\n      if (grp.line.rotation<0 && grp.line.rotation>-45){\n        \n        shape.x=shape.x+Math.sign(shape.y-target_y)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n\n      } else if (grp.line.rotation<=-45 && grp.line.rotation>-90){\n        \n        shape.x=shape.x+Math.sign(shape.x-target_x)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n        \n      }\n      \n      else if(grp.line.rotation<-90 && grp.line.rotation>-135){\n        shape.x=shape.x+Math.sign(shape.x-target_x)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } \n      else if(grp.line.rotation<=-135 && grp.line.rotation>-180){\n        shape.x=shape.x-Math.sign(shape.y-target_y)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } \n      \n      else if( grp.line.rotation>135 && grp.line.rotation<180){\n        \n        shape.x=shape.x-Math.sign(shape.y-target_y)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } else if( grp.line.rotation>90 && grp.line.rotation<=135){\n        \n        shape.x=shape.x-Math.sign(shape.x-target_x)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } else if( grp.line.rotation>45 && grp.line.rotation<=90){\n        \n        shape.x=shape.x-Math.sign(shape.x-target_x)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } else if( grp.line.rotation>0 && grp.line.rotation<=45){\n        \n        shape.x=shape.x+Math.sign(shape.y-target_y)*added_distance*Math.sin(grp.line.rotation*(Math.PI/180))\n        shape.y=-(1/a)*shape.x+b\n      } \n      else if(grp.line.rotation==-90){\n        shape.x=shape.x-Math.sign(shape.x-target_x)*added_distance\n      } else if(grp.line.rotation==90){\n        shape.x=shape.x+Math.sign(shape.x-target_x)*added_distance\n      } else if(grp.line.rotation==180 || grp.line.rotation==-180){\n        shape.y=shape.y-Math.sign(shape.y-target_y)*added_distance\n      } else if(grp.line.rotation==0){\n        shape.y=shape.y-Math.sign(shape.y-target_y)*added_distance\n      } \n      \n      shape.isGrouped=0;\n      this.shapes.push(shape,)\n\n      //We update the position of the center (the object)\n      this.center.x=shape.x;\n      this.center.y=shape.y;\n\n      grp.line.freeDistances.push(grp.line.occupiedDistances[i],);\n      grp.line.occupiedDistances.splice(i,1);\n      grp.shapes_g.splice(i,1);\n\n      if(grp.line.keepDistribution){\n        console.log(\"a position point is delete\")\n        grp.line.positionPoints.splice(grp.line.positionPoints.length-1,1)\n      }\n\n      this.updateOccupiedDistance(grp.id)\n      this.updateAllPosInGrp(grp.id)\n\n      //We make sure that the corresponding \"position point\" of the new free position \n      //is draggable and have the good drag bound func so that we can move it only on the line.\n      if(!grp.line.keepDistribution){\n        let positionPoint= grp.line.positionPoints.find((r)=>r.distance_to_line_center\n        ==grp.line.freeDistances[grp.line.freeDistances.length-1]);\n        positionPoint.draggable=true;\n        \n      this.updateDragFunc(positionPoint,grp.line);\n      }\n\n      this.eraseNodefromTransformer(\"shapeTransformer\");\n\n      //We erase ghosts of attached shapes and we make sure that their opacity is 1.\n      grp.ghosts.splice(0,grp.ghosts.length);\n      for (let i=0;i<grp.shapes_g.length;i++){\n        grp.shapes_g[i].opacity=1;\n      }\n    \n    },\n\n    \n    //deprecated\n    DetachShapeButtonAction(){\n      let shape= ContextMenu.props.ConcernedShape;\n      if(shape.attrs.className==\"Line\"){\n        let shapes_g=shape.getParent().attrs.shapes_g;\n        while(shapes_g.length!=0){\n          this.DetachShape(shapes_g[0]);\n        }\n      }else{\n        let shape_data=this.shapes.find(i => i.id ===shape.attrs.id);\n        let isFunded=true;\n        if(shape_data==undefined){\n          isFunded=false;\n        }\n        let i=0;\n        while(!isFunded){\n          if(i<this.groups.length){\n            shape_data=this.groups[i].shapes_g.find(i => i.id === shape.attrs.id);\n          if(shape_data==undefined){\n            isFunded=false;\n          }else{\n            isFunded=true;\n          }\n          i++;\n          }else{        \n            isFunded=true;\n          }\n        }\n        this.DetachShape(shape_data)\n      }\n    },\n\n    //called when the button \"keep/liberate distribution\" is clicked.\n    //switch btw the 2 modes of stickyline: keep distribution and keep only distance.\n    switchStickylineMode(){\n\n      let grp=this.groups.find(i => i.id === ContextMenu.props.ConcernedShape.attrs.id);\n      let line=grp.line;\n      \n      if(line==undefined){\n        return;\n      }else{\n\n        if(line.keepDistribution){\n\n          line.keepDistribution=false;\n          for (let i=0;i<grp.shapes_g.length;i++){\n            grp.shapes_g[i].distance_to_line_center=line.occupiedDistances[i]\n          }\n          line.freeDistances=[];\n\n          line.stroke='blue'\n          grp.line.keepDistanceButtonText=\"Keep Distribution\";\n\n        }else{\n\n          line.keepDistribution=true;\n          for (let i=0;i<grp.shapes_g.length;i++){\n            line.occupiedDistances[i]=grp.shapes_g[i].distance_to_line_center;\n          }\n          line.stroke='rgb(48,48,48)'\n          grp.line.keepDistanceButtonText=\"Liberate Distribution\";\n          this.updateOccupiedDistance(line.id);\n          this.updateAllPosInGrp(line.id);\n          \n        }\n      }\n    },\n\n    //called when tthe event need_new_shape is emit by the ToolBar component.\n    //This event is emitted with the shape that need to be create.\n    //This method create the shape on the stage.\n    createNewShape(shape){\n\n      //If the shape that have to be created is aline\n      if(shape.attrs.className==\"Line\"){\n        \n        //We have to create a new group by cloning the one present in the toolbar with the stickyline\n        this.max_id_figures=this.max_id_figures+1;\n        let clone=shape.getParent().clone({\n          id: ''+this.max_id_figures,\n          name: \"group\"+this.max_id_figures,\n          shapes_g:[],\n        })\n        clone.attrs.line.id=''+this.max_id_figures;\n        clone.attrs.line.x=shape.getStage().getPointerPosition().x;\n        clone.attrs.line.y=shape.getStage().getPointerPosition().y;\n        clone.attrs.line.draggable=true;\n        this.groups.push(clone.attrs,);\n        \n      }else{\n        //If we just need to create a shape\n        \n        this.max_id_figures=this.max_id_figures+1\n        let clone=shape.clone({\n          id: ''+this.max_id_figures,\n          draggable: true,\n        })\n        clone.attrs.isGrouped=0;\n        this.shapes.push(clone.attrs,);\n\n      }\n    },\n    \n    //called when the user clicked on a onject in eraser mode\n    eraserAction(e){\n      this.Remove(e.target);  \n    },\n\n    //called when the mouse go out of an object's area in eraser mode\n    //remove the stroke given to the shape if it could be erased\n    unshowSelectedShape(e){\n      if(e.target.attrs.className==\"Line\" && this.eraseMode==0){\n        e.target.opacity(0.5)\n      }\n      else if(e.target.attrs.className==\"Line\" && this.eraseMode==1){\n        if(e.target.attrs.keepDistribution==1){\n          e.target.stroke(\"rgb(48,48,48)\")\n        }else{\n          e.target.stroke(\"blue\")\n        }\n      }\n      else if(e.target.attrs.className==\"positionPoint\" && this.eraseMode==1){\n        if(e.target.getParent().attrs.line.keepDistribution!=1){\n          e.target.strokeWidth(0)\n        }\n      }\n      else if(this.eraseMode==1){\n        e.target.strokeWidth(0)\n      }\n    },\n\n    //called when the mouse enter in an object's area in eraser mode\n    //show is an object can be erased or not by giving to it a stroke\n    showSelectedShape(e){\n      if(e.target.attrs.className==\"Line\" && this.eraseMode==0){\n        e.target.opacity(1)\n      }\n      else if(e.target.attrs.className==\"Line\" && this.eraseMode==1){\n        e.target.stroke('rgb(200, 59, 218)')\n      }\n      else if(e.target.attrs.className==\"positionPoint\" && this.eraseMode==1){\n        let line=e.target.getParent().attrs.line;\n        if(line.freeDistances.indexOf(e.target.attrs.distance_to_line_center)!=-1){\n          if(line.keepDistribution!=1){\n            e.target.stroke('rgb(200, 59, 218)')\n            e.target.strokeWidth(3)\n          }\n        }\n      }\n      else if(this.eraseMode==1){\n        e.target.stroke('rgb(200, 59, 218)')\n        e.target.strokeWidth(3)\n      }\n    },\n\n    //called when we dbl click on a text\n    //show the input area so that the user can modify the text\n    editText(e){\n      //let valuey=document.getElementById(\"stage\").style.top+e.target.y()\n      //let valuex=document.getElementById(\"stage\").style.left+e.target.x()\n      let stageBox=e.target.getStage().attrs.container.getBoundingClientRect();\n      document.getElementById(\"input\").style.top=stageBox.y+e.target.getAbsolutePosition().y+'px';\n      document.getElementById(\"input\").style.left=stageBox.x+e.target.getAbsolutePosition().x-document.getElementById(\"input\").size*5+'px';\n      document.getElementById(\"input\").style.display=\"initial\"\n      this.editedText=e.target\n    },\n\n    /*Change the text accordingly to what the user wrote as input*/\n    updateText(e){\n\n      //We first need to find the text data.\n      let shape=this.shapes.find(i => i.id ===this.editedText.attrs.id);\n      let isFunded=true;\n      if(shape==undefined){\n        isFunded=false;\n      }\n      let i=0;\n      while(!isFunded){\n        if(i<this.groups.length){\n          shape=this.groups[i].shapes_g.find(i => i.id === this.editedText.attrs.id);\n        if(shape==undefined){\n          isFunded=false;\n        }else{\n          isFunded=true;\n        }\n        i++;\n        }else{        \n          isFunded=true;\n        }\n      }\n\n      if(shape!=undefined){\n        //if the data has been found we update the text.\n\n        let last_width;\n        let last_height;\n        let diff_width;\n        let diff_height;\n\n        last_width=this.editedText.width();\n        last_height=this.editedText.height();\n\n        shape.text=e.target.value;\n        this.editedText.text(e.target.value);\n\n        diff_width=this.editedText.width()-last_width;\n        diff_height=this.editedText.height()-last_height;\n\n        \n        shape.offsetX=shape.offsetX+diff_width/2\n        shape.offsetY=shape.offsetY+diff_height/2\n        shape.length_x=this.editedText.width()\n        shape.length_y=this.editedText.height()\n        document.getElementById(\"input\").style.display=\"none\"\n      }\n    }\n  },\n};\n\n</script>\n<style>\n#playground{\n  cursor: default\n}\n#active{\n  position: absolute;\n  display: none;\n  top: 0px;\n  left: 0px;\n  width: 60px;\n  background-color: white;\n  box-shadow: 0 0 5px grey;\n  border-radius: 3px;\n}\n#center_menu{\n  position: absolute;\n  display: none;\n  top: 0px;\n  left: 0px;\n  width: 60px;\n  background-color: white;\n  box-shadow: 0 0 5px grey;\n  border-radius: 3px;\n}\ninput{\n  position:absolute;\n  display: none;\n  top:0px;\n  left:0px;\n}\n</style>","<template>\n<!--Component of the toolbar-->\n<v-stage\n    ref=\"toolbar\" id=\"toolbar\" :config=\"stageConfig\">\n    <v-layer ref=\"layer\">\n      <v-rect\n        :key=\"shapes.rectangle.id\"\n        :config=\"shapes.rectangle\"\n        @mousedown=\"Copy\"\n      />\n      <v-circle\n        :key=\"shapes.circle.id\"\n        :config=\"shapes.circle\"\n        @mousedown=\"Copy\"\n      />\n      <v-regular-polygon\n      :key=\"shapes.triangle.id\"\n      :config=\"shapes.triangle\"\n      @mousedown=\"Copy\"/> \n      <v-text\n        :key=\"shapes.text.id\"\n        :config=\"shapes.text\"\n        @mousedown=\"Copy\"\n      />\n      \n      <v-text v-for=\"item in texts\" :key=\"item.text\" :config=\"item\"/>\n      <v-line v-for=\"border in borders\" :key=\"border.x\" :config=\"border\"/>\n      <v-rect v-for=\"box in boxes\" :key=\"box.x\" :config=\"box\"/>\n      <v-group \n      ref=\"groups\" \n      v-for=\"group in groups\"\n      :key=\"group.id\"\n      :config=\"group\">\n      <v-line \n        :key=\"group.line.id\"\n        :config=\"group.line\"\n        @mousedown=\"Copy\"\n      />\n      </v-group>\n      <v-image\n        :key=\"tools.eraser.id\"\n        :config=\"tools.eraser\"\n        @mousedown=\"activateTool\"\n      />\n    </v-layer>\n</v-stage>\n</template>\n<script>\nconst width=window.innerWidth;\nexport default {\n    props: {\n        CopiedShape: Object,\n        pastOneObject:{\n          type: Boolean,\n          default: true,\n        },\n    },\n    data(){\n        return{\n            stageConfig: {\n              width: width,\n              height: 100,\n            },\n            //dM: this.displayMenu,\n            //cS: \"${this.ConcernedShape.className} ==='Line'\",\n            shapes:\n            {\n              rectangle:\n              {\n                rotation: 0,\n                id: 'o1',\n                //x: 100,\n                x: 46,\n                y: 20,\n                opacity:1,\n                width: 75,\n                height: 50,\n                scaleX: 1,\n                scaleY: 1,\n                strokeWidth: 0,\n                stroke: 'black',\n                fill: 'red',\n                name: 'rect1',\n                draggable: false,\n                className:\"Rect\",\n                isGrouped: 0, //if =0 the shape doesn't need to be added to a group. if=1, it does.\n                offsetX:75/2,\n                offsetY:0,\n                personalRotation:0,\n                centerPosition:'Top', \n                \n              },\n              circle:\n              {\n                rotation:0,\n                //x: 200,\n                x:116,\n                y: 20,\n                scaleX:1,\n                scaleY:1,\n                opacity:1,\n                offsetX: 0,\n                offsetY: -25,\n                radius: 25,\n                fill: 'orange',\n                strokeWidth: 0,\n                stroke: 'black',\n                draggable:false,\n                isGrouped: 0,\n                className:\"Circle\",\n                id:'o3',\n                personalRotation:0,\n                centerPosition:'Top',\n              },\n              triangle: {\n                rotation: 0,\n                id:'8',\n                x: 170,\n                y: 51,\n                sides:3,\n                opacity:1,\n                radius:30,\n                width: 60,\n                height: 60,\n                scaleX: 1,\n                scaleY: 1,\n                strokeWidth: 0,\n                stroke: 'black',\n                fill: 'purple',\n                name: 'triangle1',\n                draggable: false,\n                className:\"Triangle\",\n                isGrouped: 0,\n                offsetX: 0,\n                offsetY: 0,\n                personalRotation:0, \n                centerPosition:'Middle',\n              },\n              text:{\n                text: 'A text',\n                rotation: 0,\n                opacity:1,\n                x: 216,\n                y: 40,           \n                scaleX:1,\n                scaleY:1,\n                offsetY:0,\n                offsetX: 18,\n                /*I cannot use height and width because otherwise thye will fix the height\n                and the width of the text box: We want a flexible xhen so that peopl can write the text they want*/ \n                length_x:36,\n                length_y:15,\n                isGrouped: 0,\n                className:\"Text\",    \n                fontSize: 15,\n                fontFamily: 'Calibri',\n                id:'4',\n                personalRotation:0,\n                centerPosition:'Top',\n            },\n\n            },\n            groups:[\n            {\n              //rotation: 20,\n              name: \"group\",\n              className: \"Group\",\n              id: '1',\n              x:0,\n              y:0,\n              offsetX:0,\n              offsetY:0,\n              rotation: 0,\n              draggable: false,\n              ghosts:[],\n              shapes_g:[], //list of shapes that are on the line\n              //the line of the group:\n              line:{\n                x:316,\n                y:50,\n                points: [0, 0, 0, 0, 300, 0],\n                positionPoints:[],\n                strokeWidth: 10,\n                rotation: 0,\n                tension:0,\n                closed: true,\n                draggable: false,\n                scaleX:60/300,\n                scaleY:1,\n                opacity:0.5,\n                offset:{\n                  x:150,\n                  y:0,\n                },\n                name: \"ligne\",\n                className: \"Line\",\n                stroke: 'rgb(48,48,48)',\n                id:'1',\n                //distShapesToCenter:[],\n                keepDistribution: true, //say of we keep the distribution on the line or not\n                freeDistances:[], // distance that can be taken by other shapes (if we keep distribution on the line).\n                occupiedDistances:[], //distance already \"taken\" by shapes on the line.       \n                //text which will appear on the button corresponding to the management of the distribution:\n                defaultAlignment:\"Middle\",\n                keepDistanceButtonText:\"Liberate Distribution\",\n              },\n            },\n            {\n              //rotation: 20,\n              name: \"group\",\n              className: \"Group\",\n              id: '2',\n              x:0,\n              y:0,\n              offsetX:0,\n              offsetY:0,\n              rotation: 0,\n              draggable: false,\n              ghosts:[],\n              shapes_g:[], //list of shapes that are on the line\n              //the line of the group:\n              line:{\n                x:366,\n                y:50,\n                points: [0, 0, 0, 0, 300, 0],\n                positionPoints:[],\n                strokeWidth: 10,\n                rotation: -90,\n                tension:0,\n                closed: true,\n                draggable: false,\n                scaleX:60/300,\n                scaleY:1,\n                opacity:0.5,\n                offset:{\n                  x:150,\n                  y:0,\n                },\n                name: \"ligne\",\n                className: \"Line\",\n                stroke: 'rgb(48,48,48)',\n                id:'2',\n                //distShapesToCenter:[],\n                keepDistribution: true, //say of we keep the distribution on the line or not\n                freeDistances:[], // distance that can be taken by other shapes (if we keep distribution on the line).\n                occupiedDistances:[], //distance already \"taken\" by shapes on the line.       \n                //text which will appear on the button corresponding to the management of the distribution:\n                defaultAlignment:\"Middle\",\n                keepDistanceButtonText:\"Liberate Distribution\",\n              },\n            },\n            \n            {\n              //rotation: 20,\n              name: \"group\",\n              className: \"Group\",\n              id: '3',\n              x:0,\n              y:0,\n              offsetX:0,\n              offsetY:0,\n              rotation: 0,\n              draggable: false,\n              ghosts:[],\n              shapes_g:[], //list of shapes that are on the line\n              //the line of the group:\n              line:{\n                x:476,\n                y:50,\n                points: [0, 0, 0, 0, 300, 0],\n                positionPoints:[],\n                strokeWidth: 10,\n                rotation: 0,\n                tension:0,\n                closed: true,\n                draggable: false,\n                scaleX:60/300,\n                scaleY:1,\n                opacity:0.5,\n                offset:{\n                  x:150,\n                  y:0,\n                },\n                name: \"ligne\",\n                className: \"Line\",\n                stroke: 'blue',\n                id:'3',\n                //distShapesToCenter:[],\n                keepDistribution: false, //say of we keep the distribution on the line or not\n                freeDistances:[], // distance that can be taken by other shapes (if we keep distribution on the line).\n                occupiedDistances:[], //distance already \"taken\" by shapes on the line.       \n                //text which will appear on the button corresponding to the management of the distribution:\n                defaultAlignment:\"Middle\",\n                keepDistanceButtonText:\"Keep Distribution\",\n              },\n            },\n            {\n              //rotation: 20,\n              name: \"group\",\n              className: \"Group\",\n              id: '4',\n              x:0,\n              y:0,\n              offsetX:0,\n              offsetY:0,\n              rotation: 0,\n              draggable: false,\n              ghosts:[],\n              shapes_g:[], //list of shapes that are on the line\n              //the line of the group:\n              line:{\n                x:526,\n                y:50,\n                points: [0, 0, 0, 0, 300, 0],\n                positionPoints:[],\n                strokeWidth: 10,\n                rotation: -90,\n                tension:0,\n                closed: true,\n                draggable: false,\n                scaleX:60/300,\n                scaleY:1,\n                opacity:0.5,\n                offset:{\n                  x:150,\n                  y:0,\n                },\n                name: \"ligne\",\n                className: \"Line\",\n                stroke: 'blue',\n                id:'4',\n                //distShapesToCenter:[],\n                keepDistribution: false, //say of we keep the distribution on the line or not\n                freeDistances:[], // distance that can be taken by other shapes (if we keep distribution on the line).\n                occupiedDistances:[], //distance already \"taken\" by shapes on the line.       \n                //text which will appear on the button corresponding to the management of the distribution:\n                defaultAlignment:\"Middle\",\n                keepDistanceButtonText:\"Keep Distribution\",\n              },\n            },\n            ],\n            tools:{\n              eraser:{\n            isActivated:0,\n            rotation: 0,\n            x: 606,\n            y: 40,           \n            scaleX:1,\n            scaleY:1,\n            offsetY:0,\n            offsetX:0,\n            opacity:1,\n            //width:72,\n            //height:30,\n            image: null,\n            isGrouped: 0,\n            className:\"eraser\",    \n            fontSize: 30,\n            id:'5',\n              },\n            },\n            borders:[\n              {x:246,\n                y:0,\n                points: [0, 0, 0, 0, 100, 0],\n                strokeWidth: 3,\n                rotation: 90,\n                opacity:1,\n                stroke: 'black',\n              },\n            ],\n            texts:[\n              {text: 'Shapes',y:5,x:6},\n              {text: 'Tools',y:5,x:250},\n              {text: 'eraser',y:25,x:588,fill:'rgb(200, 59, 218)'},\n              {text: 'StickyLines',y:19,x:260},\n              {text: '(Keep Distribution)',y:29,x:260},\n              {text: 'StickyLines',y:19,x:420,fill: 'blue'},\n              {text: '(Keep Distance)',y:29,x:420,fill:'blue'},\n            ],\n            boxes:[\n              \n              {\n                rotation: 0,\n                id: 'box1',\n                x: 296,\n                y: 17,\n                width: 145,\n                height: 70,\n                scaleX: 1,\n                scaleY: 1,\n                strokeWidth: 1,\n                stroke: 'black',\n                draggable: false,\n                offsetX:75/2,\n                offsetY:0,\n                \n              },\n               {\n                rotation: 0,\n                id: 'box2',\n                x: 456,\n                y: 17,\n                width: 145,\n                height: 70,\n                scaleX: 1,\n                scaleY: 1,\n                strokeWidth: 1,\n                stroke: 'blue',\n                draggable: false,\n                offsetX:75/2,\n                offsetY:0,\n                \n              },\n              \n            ]\n        }\n    },\n    created(){\n    \n    const image = new window.Image();\n    image.src = require(\"@/assets/ugly_eraser.png\");\n\n    //set image only when it is loaded\n    image.onload = () => {\n      this.tools.eraser.image= image;\n      this.tools.eraser.offsetX=image.width/2;\n      this.tools.eraser.offsetY=0; \n    };\n  },\n  methods:{\n\n    //Called when the user click on a shape or a stickyline\n    Copy(e){\n      this.$emit('need_new_shape',e.target);\n    },\n\n    //Call when user click on a tool like the eraser (except stickylines)\n    activateTool(e){\n      let tool;\n      if(e.target.attrs.className===\"eraser\"){\n        tool=this.tools.eraser\n        if(tool.opacity==1){\n          tool.opacity=0.4;\n        }else{\n          tool.opacity=1;\n        }\n        this.$emit('eraser_is_selected');\n      }\n    }\n  },\n}\n</script>\n<style>\n\n      #menu {\n        display: initial;\n        position: absolute;\n        overflow-y: scroll;\n        max-height:300px;\n        background-color: white;\n        box-shadow: 0 0 5px grey;\n        border-radius: 3px;\n      }\n\n      #menu button {\n        width: 100%;\n        background-color: white;\n        border: none;\n        margin: 0;\n        padding: 10px;\n      }\n\n      #menu button:hover {\n        background-color: lightgray;\n      }\n\n      #toolbar{\n      \n        box-shadow: 0 0 5px grey;\n        border-radius: 3px;\n        cursor: pointer;\n      }\n</style>","import { render } from \"./ToolBar.vue?vue&type=template&id=5a33f769\"\nimport script from \"./ToolBar.vue?vue&type=script&lang=js\"\nexport * from \"./ToolBar.vue?vue&type=script&lang=js\"\n\nimport \"./ToolBar.vue?vue&type=style&index=0&id=5a33f769&lang=css\"\n\nimport exportComponent from \"/Users/junhangyu/Desktop/PE code/github/teachingApp/node_modules/vue-loader/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render]])\n\nexport default __exports__","import { render } from \"./PlayGround.vue?vue&type=template&id=7c30b4f5\"\nimport script from \"./PlayGround.vue?vue&type=script&lang=js\"\nexport * from \"./PlayGround.vue?vue&type=script&lang=js\"\n\nimport \"./PlayGround.vue?vue&type=style&index=0&id=7c30b4f5&lang=css\"\n\nimport exportComponent from \"/Users/junhangyu/Desktop/PE code/github/teachingApp/node_modules/vue-loader/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render]])\n\nexport default __exports__","<template>\n\n  \n  <div class=\"introduction\">\n    <h1>Introduction</h1>\n    <p class=\"text_for_introduction\">The goal of this app is to help you discover two generative theories of interaction: Instrumental Interaction and Human-Computer Partnerships.\n      Even if the interactive part is more focused on the first theory, this app should help you understanding \n      the concepts and principles of these theories and how to apply them.\n    </p>\n\n\n    <p class=\"text_for_introduction\">We will first begin with an observation. Take a look at the following interactive situation:</p>\n    <p class=\"text_for_introduction\"><strong>You can drag shapes, select them by clicking on them and align the selected shapes\n      through a button that appears when you right click on the blank.</strong>\n    </p>\n    <div id=\"basic-demo\">\n    <BasicAlignmentDemo  :height=\"300\" :width=\"500\"></BasicAlignmentDemo>\n    </div>\n    <p class=\"text_for_introduction\">We can see that there is a <strong>lack of persistence and control</strong>.\n      These problems related to alignement is something that can be seen in some graphic design softwares.\n      How to improve this command?\n      We will try to apply 'Instrumental Interaction' and 'Human-Computer Partnerships', two 'Generative Theories of Interaction'\n      in order to answer this question. \n    </p>\n    <p class=\"text_for_introduction\"> <strong>We tried to apply the principles of these theories in \n      order to illustrate them: See the tab \"Instrumental Interaction Overview\" and\n      \"Human-Computer Partnerships Overview\". In these interactive illustrations, alignement is now a digital tool \n      called \"stickyline\".\n      <br>The playground is a combination of these applications.\n      <br>This work is inspired by the software of the 'ex-situ' team \n      called \"StickyLine\". See references [2] and [5] in \"About\" tab for more information</strong>\n    </p>\n    \n     \n    <h2>Generative Theory of Interaction</h2>\n    <p class=\"text_for_introduction\">A Generative theory of interaction can be seen as a theory which makes \n      a link between the HCI knowledge, scientific theories and those about human behaviour/activity \n      with the design of interactive artifacts.\n      A generative theory allows to apply three \"lenses\" based on its concepts and principles in order analyse,critize and construct new artifacts</p>\n    \n    \n    <img width=500 src=\"..\\assets\\genTheoImg.png\">\n    <p class=\"legend\">Taken from reference [1]</p>\n    \n\n    <h2>Instrumental Interaction</h2>\n    <h3>Concept:</h3>\n    <p class=\"text_for_introduction\">An 'instrumental interaction' is based on using digital tools to manipulate objects.\n      These tools, also considered as objects, \n      should be flexible and, as for physical tools, have clear technial properties\n      in order to help the user to appropiate it and allow him to use it for different kind of purposes beyond its primitive goal.\n    </p>\n    <h3>Principles:</h3>\n\n    <table>\n      <tr class=\"title_row\">\n        <th colspan=\"3\" >Principles</th>\n      </tr>\n      <tr>\n        <th>\n          <span class=\"principle\"> Reification</span> \n        </th>\n        <th>\n          <span class=\"principle\"> Polymorphism</span> \n        </th>\n        <th>\n          <span class=\"principle\"> Reuse</span> \n        </th>\n      </tr>\n      <tr>\n        <th>\n          Reify a command in a first-class object for the interface, in a digital tool that the user can manipulate directly\n        </th>\n        <th>\n          Digital instrument should have the possibility to be used on different types of object.\n          It could also reify further commands.\n        </th>\n        <th>\n          Possibility for the user to use again a previous process (Input Reuse) or its result (Output Reuse) \n        </th>\n      </tr>\n    </table>\n    <h3>Methodology:</h3>\n    <table>\n      <tr class=\"title_row\">\n        <th>Instrumental Interaction</th>\n        <th>Analytical</th>\n        <th>Critical</th>\n        <th>Constructive</th>\n      </tr>\n      <tr class=\"subtitle_row\">\n        <th colspan=\"4\">Concepts</th>\n      </tr>\n      <tr>\n        <th class=\"row_name\">Object of Interest</th>\n        <th>What are the objects visible\n          and directly manipulable\n          by the user?</th>\n        <th>Do these objects match\n          those of the users mental\n          models?</th>\n        <th>Are there other objects of\n          interest, e.g. styles in a text\n          editor? Should some\n          objects of interest turned\n          into instruments?</th>\n      </tr>\n      <tr>\n        <th class=\"row_name\">Instrumental / Tool</th>\n        <th>What functions are\n          available as tools, e.g. in\n          tool palettes, as opposed to\n          commands, e.g. menu items?</th>\n        <th>Do the tools actually work\n          as such i.e. by extending\n          users capabilities? Do the\n          tools enable technical\n          reasoning?</th>\n        <th>Which commands can be\n          turned into tools? Are they\n          related with physical tools?</th>\n      </tr>\n      <tr class=\"subtitle_row\">\n        <th colspan=\"4\">Principles</th>\n      </tr>\n      <tr>\n        <th class=\"row_name\">Reification</th>\n        <th>Which concepts/commands\n          are reified into interactive\n          objects/tools? How can\n          these objects be\n          manipulated?</th>\n        <th>Are the reified concepts\n          effective? Are the objects\n          directly manipulable?</th>\n        <th>Which concepts/commands\n          should be reified? Into\n          which objects/tools? What\n          manipulations should be\n          available?</th>\n      </tr>\n       <tr>\n        <th class=\"row_name\">Polymorphism</th>\n        <th>Which commands/tools\n          apply to objects of different\n          types? Do they apply to\n          collection of heterogeneous\n          objects?</th>\n        <th>Should commands/tools\n          apply to multiple object\n          types? Which types?</th>\n        <th>How to make each\n          instrument (more)\n          polymorphic? How to\n          create groups of\n          heterogeneous objects?</th>\n      </tr>\n       <tr>\n        <th class=\"row_name\">Reuse</th>\n        <th>Which commands/objects\n          can be reused?</th>\n        <th>Which commands/objects\n          should be reusable?</th>\n        <th>How to make commands\n          reusable (input reuse)?\n          How to make objects\n          reusable (output reuse)?</th>\n      </tr>\n    \n    </table>\n    <p class=\"legend\">Taken from reference [1]</p>\n    <h2>Human-Computer Partnerships</h2>\n    <h3>Concept:</h3>\n    <p class=\"text_for_introduction\">\n      This theory is based on the concepts of co-adaptation. In HCI, co-adaptation means that the user tames the system by getting used to it \n      but also by adapting the systems to its needs.\n      There is also the concepts of \"Reciprocal co-adaptation\" related to intelligent systems,\n      but we will not talk of that here. If you want to know more see the reference [1] in the \"About\" page.\n    </p>\n    <h3>Principles:</h3>\n\n    <table>\n      <tr class=\"title_row\">\n        <th colspan=\"3\">Principles</th>\n      </tr>\n      <tr>\n        <th>\n          <span class=\"principle\"> Discoverability</span> \n        </th>\n        <th>\n          <span class=\"principle\"> Appropriability</span> \n        </th>\n        <th>\n          <span class=\"principle\"> Expressivity</span> \n        </th>\n      </tr>\n      <tr>\n        <th>\n          Reveal how the system interprets the users recent behavior (feedback) and\n          which commands are now possible (feedforward)\n        </th>\n        <th>\n          Modify the systems behavior by customizing its characteristics for new purposes\n        </th>\n        <th>\n          Create rich, personalized output generated from individual user-controlled input\n          variation. \n        </th>\n      </tr>\n    </table>\n    <p class=\"legend\">Taken from reference [1]</p>\n    <h3>Methodology:</h3>\n    <table>\n      <tr class=\"title_row\">\n        <th>Human-Computer Partnerships</th>\n        <th>Analytical</th>\n        <th>Critical</th>\n        <th>Constructive</th>\n      </tr>\n      <tr class=\"subtitle_row\">\n        <th colspan=\"4\">Concepts</th>\n      </tr>\n      <tr>\n        <th class=\"row_name\">Co-adaptation</th>\n        <th>Can users reveal,\n          interpret or modify the\n          systems behavior?</th>\n        <th>Which aspects of the\n          system are discoverable,\n          appropriable and\n          expressive?</th>\n        <th>How can we help users to\n          both adapt to the system,\n          and adapt it for new tasks\n          and creative expression?</th>\n      </tr>\n      <tr class=\"subtitle_row\">\n        <th colspan=\"4\">Principles</th>\n      </tr>\n      <tr>\n        <th class=\"row_name\">Discoverability</th>\n        <th>Does the system reveal\n            how it interpreted user\n            behavior and show what\n            options are currently\n            available?\n            </th>\n        <th>Can users discover and\n            understand the system?\n            Can the system interpret\n            aspects of the users\n            behavior?</th>\n        <th>How can we present the\n            systems interpretation of\n            users actions and reveal\n            user-relevant features?</th>\n      </tr>\n       <tr>\n        <th class=\"row_name\">Appropriability</th>\n        <th>Does the system permit\n          customization of the\n          system or its features?</th>\n        <th>Can users create or\n          modify the commands\n          and features they need?</th>\n        <th>How can we help users\n          personalize or redefine\n          the system or its features?</th>\n      </tr>\n       <tr>\n        <th class=\"row_name\">Expressivity</th>\n        <th>Does the system\n          transform individual\n          input variation into\n          expressive output?</th>\n        <th>Can users control how\n          the system interprets\n          their actions so as to\n          generate rich or\n          expressive output?</th>\n        <th>How can we help users\n          dynamically control their\n          expressive output?</th>\n      </tr>\n    </table>\n    <p class=\"legend\">Taken from reference [1]</p>\n  </div>\n</template>\n\n<script>\n// @ is an alias to /src\n//import HelloWorld from '@/components/HelloWorld.vue'\nimport BasicAlignmentDemo from '@/components/canvas/classic-demo/BasicAlignmentDemo.vue'\nexport default {\n  name: 'IntroductionView',\n  components: {\n    BasicAlignmentDemo,\n  }\n}\n</script>\n\n<style>\n#basic-demo{\n  border:1px solid black;\n  height:290px;\n  width:500px;\n  margin-left: auto;\n  margin-right: auto;\n}\n.text_for_introduction{\n  width:700px;\n  text-align: left;\n}\n.introduction{\n  margin: auto;\n  width: 50%;\n  padding: 10px;\n  text-align: center;\n  \n}\n.title{\n  margin-left: auto;\n  margin-right: auto;\n}\n.principle{\n  color: red\n}\n.legend{\n  font-size: 12px;\n}\ntr.title_row{\n  color:rgb(255, 255, 255);\n  background-color:rgb(125, 31, 214)\n}\ntr.subtitle_row{\n  color:rgb(255, 255, 255);\n  background-color:rgb(155, 72, 233)\n}\nth.row_name{\n  background-color:rgb(201, 157, 243)\n}\n</style>\n","<template>\n<div id=\"basicAlignmentDemo\"\n@click=\"hideButton\">\n  <v-stage\n  ref=\"stage\"\n  id=\"stage\"\n  :config=\"stageSize\"\n\n  @contextMenu=\"displayButton\"\n  >\n    <v-layer ref=\"layer\">\n      <v-rect\n      v-for=\"item in shapes.filter(i=>i.className=='Rect')\"\n      :key=\"item.id\"\n      :config=\"item\"\n      \n      @click=\"selectShape\"\n      />\n      <v-circle\n        v-for=\"item in shapes.filter(i=>i.className=='Circle')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @click=\"selectShape\"\n      />\n      <v-regular-polygon\n        v-for=\"item in shapes.filter(i=>i.className=='Triangle')\"\n        :key=\"item.id\"\n        :config=\"item\"\n        @click=\"selectShape\"\n      />\n    </v-layer>\n  </v-stage>\n  <div id=\"align_button\">\n    <button @click=\"alignSelectedShapes\">Align</button>\n  </div>\n</div>\n</template>\n<script>\n\n//drag bound func to prevent the objects from going outside the stage\nconst dragFunc=function (pos) {\n  let width=this.getStage().width();\n  let height=this.getStage().height();\n  let strokeSize=10\n    if(pos.x>width-strokeSize && pos.y>height-strokeSize){\n      return{\n        x: width-strokeSize,\n        y: height-strokeSize,\n      }\n    } else if(pos.x>width-strokeSize && pos.y<strokeSize){\n      return{\n        x: width-strokeSize,\n        y: strokeSize,\n      }\n    } else if(pos.y>height-strokeSize && pos.x<strokeSize){\n      return{\n        x: strokeSize,\n        y: height-strokeSize,\n      }\n    } else if(pos.x<strokeSize && pos.y<strokeSize){\n      return{\n        x: strokeSize,\n        y: strokeSize,\n      }\n    } else if(pos.x<strokeSize){\n      return{\n        x: strokeSize,\n        y: pos.y,\n      }\n    }else if(pos.y<strokeSize){\n      return{\n        x: pos.x,\n        y: strokeSize,\n      }\n    }else if(pos.x>width-strokeSize){\n      return{\n        x: width-strokeSize,\n        y: pos.y,\n      }\n    }else if(pos.y>height-strokeSize){\n      return{\n        x: pos.x,\n        y: height-strokeSize,\n      }\n    } else{\n      return {\n        x: pos.x,\n        y: pos.y,\n      };\n    }\n};\nexport default {\n   props:{\n        width:{\n          type: Number,\n          default:window.innerWidth,\n        },\n        height:{\n          type: Number,\n          default:window.innerHeight,\n        }\n    },\n    data() {\n    return {\n      align_pos:null, // position where selected shapes will be aligned (regading y-axis)\n      stageSize: {\n        width: this.width,\n        height: this.height,\n      },\n      shapes:[\n        {\n          rotation: 0,\n          id:'2',\n          x: 220,\n          y: 250,\n          width: 70,\n          height: 70,\n          scaleX: 1,\n          scaleY: 1,\n          strokeWidth: 0,\n          stroke: 'red',\n          fill: 'green',\n          name: 'rect2',\n          draggable: true,\n          className:\"Rect\",\n          isGrouped: 0,\n          dragBoundFunc: dragFunc,\n          offsetX: 70/2,\n          offsetY: 70,\n          /*When it is on a line, a shape can be rotate by the user independently from the line.\n          To keep the independant rotation of the attached shape, we add the parameter \"personalRotation\".\n          So, when the shape is attached, is final rotation is the sum of this parameter with the rotation of the line.\n          */\n          personalRotation:0, \n          centerPosition:'Bottom',\n        },\n        {\n          rotation:0,\n          x: 50,\n          y: 100,\n          scaleX:1,\n          scaleY:1,\n          offsetX: 0,\n          offsetY: 40,\n          radius: 40,\n          fill: 'orange',\n          strokeWidth: 0,\n          stroke: 'red',\n          draggable:true,\n          isGrouped: 0,\n          className:\"Circle\",\n          /*When it is on a line, a shape can be rotate by the user independently from the line.\n            To keep the independant rotation of the attached shape, we add the parameter \"personalRotation\".\n            So, when the shape is attached, is final rotation is the sum of this parameter with the rotation of the line.\n            */\n          personalRotation:0, \n          id:'3',\n          dragBoundFunc: dragFunc,\n          centerPosition:'Bottom',\n        }, \n        {\n          rotation: 0,\n          id:'8',\n          x: 400,\n          y: 130,\n          sides:3,\n          radius:45,\n          width: 90,\n          height: 90,\n          scaleX: 1,\n          scaleY: 1,\n          strokeWidth: 0,\n          stroke: 'red',\n          fill: 'purple',\n          name: 'triangle1',\n          draggable: true,\n          className:\"Triangle\",\n          isGrouped: 0,\n          dragBoundFunc: dragFunc,\n          offsetX: 0,\n          offsetY: 22.5,\n          personalRotation:0, \n          centerPosition:'Bottum',\n        },],\n      }\n    },\n    methods:{\n\n        //Make a strock appear(select) or disappear (unselect) on the target shape\n        selectShape(e){\n          if(e.target.strokeWidth()==0){\n            this.shapes.find((r)=>r.id==e.target.attrs.id).strokeWidth=3;\n          }\n          else{\n            this.shapes.find((r)=>r.id==e.target.attrs.id).strokeWidth=0;\n          }\n        },\n\n        // align the shapes that are selected\n        alignSelectedShapes(){ \n          for(let i=0;i<this.shapes.length;i++){\n            if(this.shapes[i].strokeWidth>0){\n              this.shapes[i].strokeWidth=0;\n              this.shapes[i].y=this.align_pos\n            }\n          }\n        },\n\n        //display button\n        //called when right click on the stage\n        displayButton(e){\n          e.evt.preventDefault()\n          if(e.target.attrs.id===\"stage\"){\n            this.align_pos=e.target.getStage().getPointerPosition().y\n            document.getElementById(\"align_button\").style.display=\"initial\";\n            document.getElementById(\"align_button\").style.top= document.getElementById(\"basicAlignmentDemo\").getBoundingClientRect().top+document.documentElement.scrollTop+e.target.getStage().getPointerPosition().y+\"px\";\n            document.getElementById(\"align_button\").style.left= document.getElementById(\"basicAlignmentDemo\").getBoundingClientRect().left+document.documentElement.scrollLeft+e.target.getStage().getPointerPosition().x+\"px\"; \n          }\n        },\n\n        //hide the button\n        hideButton(){\n          document.getElementById(\"align_button\").style.display=\"none\"\n        }\n        \n\n\n\n        \n    }\n};\n</script>\n<style>\n#basicAlignmentDemo{\n  cursor: default;\n}\n#align_button{\n  position: absolute;\n  display: none;\n  top: 0px;\n  left: 0px;\n}\n</style>","import { render } from \"./BasicAlignmentDemo.vue?vue&type=template&id=47d84e43\"\nimport script from \"./BasicAlignmentDemo.vue?vue&type=script&lang=js\"\nexport * from \"./BasicAlignmentDemo.vue?vue&type=script&lang=js\"\n\nimport \"./BasicAlignmentDemo.vue?vue&type=style&index=0&id=47d84e43&lang=css\"\n\nimport exportComponent from \"/Users/junhangyu/Desktop/PE code/github/teachingApp/node_modules/vue-loader/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render]])\n\nexport default __exports__","import { render } from \"./IntroductionView.vue?vue&type=template&id=1613ff38\"\nimport script from \"./IntroductionView.vue?vue&type=script&lang=js\"\nexport * from \"./IntroductionView.vue?vue&type=script&lang=js\"\n\nimport \"./IntroductionView.vue?vue&type=style&index=0&id=1613ff38&lang=css\"\n\nimport exportComponent from \"/Users/junhangyu/Desktop/PE code/github/teachingApp/node_modules/vue-loader/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render]])\n\nexport default __exports__","import { createRouter, createWebHashHistory } from 'vue-router'\n//import HomeView from '../views/HomeView.vue'\nimport InstrumentalInteraTableView from '../views/InstrumentalInteraTableView.vue'\nimport HCPartnershipsTableView from '../views/HCPartnershipsTableView.vue'\nimport Playground from'../components/canvas/PlayGround.vue'\nimport IntroductionView from'../views/IntroductionView.vue'\nconst routes = [\n  /*\n  {\n    path: '/',\n    name: 'home',\n    component: HomeView\n  },\n  */\n  {\n    path: '/',\n    name: 'introduction',\n    component: IntroductionView\n  },\n  {\n    path: '/about',\n    name: 'about',\n    // route level code-splitting\n    // this generates a separate chunk (about.[hash].js) for this route\n    // which is lazy-loaded when the route is visited.\n    component: () => import(/* webpackChunkName: \"about\" */ '../views/AboutView.vue')\n  },\n  {\n    path: '/instrumentalinteractiontable',\n    name: 'Instrumental Interaction Overview',\n    component: InstrumentalInteraTableView\n  },\n  {\n    path: '/hc-partnerships-table',\n    name: 'Humane-Computer Partnerships Overview',\n    component: HCPartnershipsTableView\n  },\n  {\n    path: '/playground',\n    name: 'Playground',\n    component: Playground\n  },\n]\n\nconst router = createRouter({\n  history: createWebHashHistory(),\n  routes\n})\n\nexport default router\n","import { createApp } from 'vue'\nimport App from './App.vue'\nimport router from './router'\nimport VueKonva from 'vue-konva';\n\ncreateApp(App).use(router).use(VueKonva).mount('#app')\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = function(module) {\n\tvar getter = module && module.__esModule ?\n\t\tfunction() { return module['default']; } :\n\t\tfunction() { return module; };\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"js/\" + \"about\" + \".\" + \"caa6fa42\" + \".js\";\n};","// This function allow to reference async chunks\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"css/\" + \"about\" + \".\" + \"acfe18a1\" + \".css\";\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","var inProgress = {};\nvar dataWebpackPrefix = \"teaching_web_app:\";\n// loadScript function to load a script via script tag\n__webpack_require__.l = function(url, done, key, chunkId) {\n\tif(inProgress[url]) { inProgress[url].push(done); return; }\n\tvar script, needAttach;\n\tif(key !== undefined) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tfor(var i = 0; i < scripts.length; i++) {\n\t\t\tvar s = scripts[i];\n\t\t\tif(s.getAttribute(\"src\") == url || s.getAttribute(\"data-webpack\") == dataWebpackPrefix + key) { script = s; break; }\n\t\t}\n\t}\n\tif(!script) {\n\t\tneedAttach = true;\n\t\tscript = document.createElement('script');\n\n\t\tscript.charset = 'utf-8';\n\t\tscript.timeout = 120;\n\t\tif (__webpack_require__.nc) {\n\t\t\tscript.setAttribute(\"nonce\", __webpack_require__.nc);\n\t\t}\n\t\tscript.setAttribute(\"data-webpack\", dataWebpackPrefix + key);\n\t\tscript.src = url;\n\t}\n\tinProgress[url] = [done];\n\tvar onScriptComplete = function(prev, event) {\n\t\t// avoid mem leaks in IE.\n\t\tscript.onerror = script.onload = null;\n\t\tclearTimeout(timeout);\n\t\tvar doneFns = inProgress[url];\n\t\tdelete inProgress[url];\n\t\tscript.parentNode && script.parentNode.removeChild(script);\n\t\tdoneFns && doneFns.forEach(function(fn) { return fn(event); });\n\t\tif(prev) return prev(event);\n\t}\n\t;\n\tvar timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);\n\tscript.onerror = onScriptComplete.bind(null, script.onerror);\n\tscript.onload = onScriptComplete.bind(null, script.onload);\n\tneedAttach && document.head.appendChild(script);\n};","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.p = \"/teachingApp/\";","var createStylesheet = function(chunkId, fullhref, resolve, reject) {\n\tvar linkTag = document.createElement(\"link\");\n\n\tlinkTag.rel = \"stylesheet\";\n\tlinkTag.type = \"text/css\";\n\tvar onLinkComplete = function(event) {\n\t\t// avoid mem leaks.\n\t\tlinkTag.onerror = linkTag.onload = null;\n\t\tif (event.type === 'load') {\n\t\t\tresolve();\n\t\t} else {\n\t\t\tvar errorType = event && (event.type === 'load' ? 'missing' : event.type);\n\t\t\tvar realHref = event && event.target && event.target.href || fullhref;\n\t\t\tvar err = new Error(\"Loading CSS chunk \" + chunkId + \" failed.\\n(\" + realHref + \")\");\n\t\t\terr.code = \"CSS_CHUNK_LOAD_FAILED\";\n\t\t\terr.type = errorType;\n\t\t\terr.request = realHref;\n\t\t\tlinkTag.parentNode.removeChild(linkTag)\n\t\t\treject(err);\n\t\t}\n\t}\n\tlinkTag.onerror = linkTag.onload = onLinkComplete;\n\tlinkTag.href = fullhref;\n\n\tdocument.head.appendChild(linkTag);\n\treturn linkTag;\n};\nvar findStylesheet = function(href, fullhref) {\n\tvar existingLinkTags = document.getElementsByTagName(\"link\");\n\tfor(var i = 0; i < existingLinkTags.length; i++) {\n\t\tvar tag = existingLinkTags[i];\n\t\tvar dataHref = tag.getAttribute(\"data-href\") || tag.getAttribute(\"href\");\n\t\tif(tag.rel === \"stylesheet\" && (dataHref === href || dataHref === fullhref)) return tag;\n\t}\n\tvar existingStyleTags = document.getElementsByTagName(\"style\");\n\tfor(var i = 0; i < existingStyleTags.length; i++) {\n\t\tvar tag = existingStyleTags[i];\n\t\tvar dataHref = tag.getAttribute(\"data-href\");\n\t\tif(dataHref === href || dataHref === fullhref) return tag;\n\t}\n};\nvar loadStylesheet = function(chunkId) {\n\treturn new Promise(function(resolve, reject) {\n\t\tvar href = __webpack_require__.miniCssF(chunkId);\n\t\tvar fullhref = __webpack_require__.p + href;\n\t\tif(findStylesheet(href, fullhref)) return resolve();\n\t\tcreateStylesheet(chunkId, fullhref, resolve, reject);\n\t});\n}\n// object to store loaded CSS chunks\nvar installedCssChunks = {\n\t143: 0\n};\n\n__webpack_require__.f.miniCss = function(chunkId, promises) {\n\tvar cssChunks = {\"443\":1};\n\tif(installedCssChunks[chunkId]) promises.push(installedCssChunks[chunkId]);\n\telse if(installedCssChunks[chunkId] !== 0 && cssChunks[chunkId]) {\n\t\tpromises.push(installedCssChunks[chunkId] = loadStylesheet(chunkId).then(function() {\n\t\t\tinstalledCssChunks[chunkId] = 0;\n\t\t}, function(e) {\n\t\t\tdelete installedCssChunks[chunkId];\n\t\t\tthrow e;\n\t\t}));\n\t}\n};\n\n// no hmr","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t143: 0\n};\n\n__webpack_require__.f.j = function(chunkId, promises) {\n\t\t// JSONP chunk loading for javascript\n\t\tvar installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;\n\t\tif(installedChunkData !== 0) { // 0 means \"already installed\".\n\n\t\t\t// a Promise means \"currently loading\".\n\t\t\tif(installedChunkData) {\n\t\t\t\tpromises.push(installedChunkData[2]);\n\t\t\t} else {\n\t\t\t\tif(true) { // all chunks have JS\n\t\t\t\t\t// setup Promise in chunk cache\n\t\t\t\t\tvar promise = new Promise(function(resolve, reject) { installedChunkData = installedChunks[chunkId] = [resolve, reject]; });\n\t\t\t\t\tpromises.push(installedChunkData[2] = promise);\n\n\t\t\t\t\t// start chunk loading\n\t\t\t\t\tvar url = __webpack_require__.p + __webpack_require__.u(chunkId);\n\t\t\t\t\t// create error before stack unwound to get useful stacktrace later\n\t\t\t\t\tvar error = new Error();\n\t\t\t\t\tvar loadingEnded = function(event) {\n\t\t\t\t\t\tif(__webpack_require__.o(installedChunks, chunkId)) {\n\t\t\t\t\t\t\tinstalledChunkData = installedChunks[chunkId];\n\t\t\t\t\t\t\tif(installedChunkData !== 0) installedChunks[chunkId] = undefined;\n\t\t\t\t\t\t\tif(installedChunkData) {\n\t\t\t\t\t\t\t\tvar errorType = event && (event.type === 'load' ? 'missing' : event.type);\n\t\t\t\t\t\t\t\tvar realSrc = event && event.target && event.target.src;\n\t\t\t\t\t\t\t\terror.message = 'Loading chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realSrc + ')';\n\t\t\t\t\t\t\t\terror.name = 'ChunkLoadError';\n\t\t\t\t\t\t\t\terror.type = errorType;\n\t\t\t\t\t\t\t\terror.request = realSrc;\n\t\t\t\t\t\t\t\tinstalledChunkData[1](error);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\t__webpack_require__.l(url, loadingEnded, \"chunk-\" + chunkId, chunkId);\n\t\t\t\t} else installedChunks[chunkId] = 0;\n\t\t\t}\n\t\t}\n};\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n__webpack_require__.O.j = function(chunkId) { return installedChunks[chunkId] === 0; };\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = function(parentChunkLoadingFunction, data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some(function(id) { return installedChunks[id] !== 0; })) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\treturn __webpack_require__.O(result);\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunkteaching_web_app\"] = self[\"webpackChunkteaching_web_app\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","// startup\n// Load entry module and return exports\n// This entry module depends on other loaded chunks and execution need to be delayed\nvar __webpack_exports__ = __webpack_require__.O(undefined, [998], function() { return __webpack_require__(776); })\n__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n"],"names":["id","_createElementVNode","style","$data","_createVNode","_component_router_link","to","_component_router_view","width","src","_imports_0","onClick","$options","data","methods","openMenu","closeMenu","console","log","document","getElementById","JSON","stringify","this","require","__exports__","render","class","_createElementBlock","_hoisted_3","_hoisted_4","_component_ReificationDemo","height","_ctx","onExplain","_hoisted_6","_component_PolymorphismDemo","_hoisted_8","_component_ReuseDemo","_hoisted_10","_hoisted_11","_component_ReificationSubstrateDemo","_hoisted_13","_component_PolymorphismSubstrateDemo","_hoisted_15","_component_ReuseSubstrateDemo","_hoisted_17","_component_NarativeBox","onMousedown","groups","_component_v_stage","ref","config","onDragmove","onTouchstart","onFusion","onContextMenu","_component_v_layer","_Fragment","_renderList","step","_createBlock","_component_v_group","key","shapes_g","filter","i","className","item","_component_v_rect","onTransformend","onDragend","$event","onMouseenter","onMouseout","_component_v_circle","_component_v_image","_component_v_regular_polygon","_component_v_line","line","positionPoints","_component_v_transformer","dragFunc","pos","getStage","strokeSize","x","y","props","type","Number","default","window","innerWidth","innerHeight","components","stageSize","lengthToCapture","lengthToDetach","editedText","eraseMode","selectedShapeAlignment","needMenu","isALineSelected","isAGroupedShapeSelected","isStageOnlySelected","keepDistanceButtonText","max_id_figures","name","offsetX","offsetY","rotation","draggable","aShapeHasBeenDetach","points","strokeWidth","tension","closed","scaleX","scaleY","opacity","offset","stroke","keepDistribution","freeDistances","occupiedDistances","defaultAlignment","dragBoundFunc","transformers","enabledAnchors","rotateEnabled","borderEnabled","flipEnabled","nodes","shapes","fill","isGrouped","personalRotation","centerPosition","radius","sides","center","positionPoint","distance_to_line_center","undefined","selectedShapeId","mounted","texts","$refs","stage","getChildren","r","attrs","length","length_x","length_y","created","switchEraseMode","cursor","eraseNodefromTransformer","checkIfShapesOnLine","id_grp","grp","find","groupedShapes","isCoordinateOnLine","splice","push","updateNaration","is_not_on_straight_line","coord_y1","Math","sin","PI","coord_x1","cos","coord_y2","coord_x2","a","b","abs","sqrt","updateGrp","e","grep","target","updateAllPosInGrp","isOutsideTheLine","shape","is_on_straight_line","update","j","makeGroup","CheckIfNeedToDetach","getParent","dist","getPointerPosition","DetachShape","GiveSignOfDistance","result","angle","distX","distY","sign","GiveSignOfDistanceBtwCenterAndShape","sort","isSmaller","isBeforeRegardingX","Object","assign","ChangeCenterRegardingCommand","updateDragFunc","updateOccupiedDistance","sortByDistToLineCenter","L","nb_shapes","d","updateOccDist","res","isNearest","isFree","indice","l","ecart","invx","invy","ecart_min","sortAnyShapesByDistToLineCenter","updatePos","position","getLayer","batchDraw","updatePosInGrp","needToBeDetach","indexOf","updateTransformedShape","findShape","shape_data","last_shapex","last_shapey","last_scaleX","grp_id","updateDragFuncOfCenter","handleTransformation","evt","eraserAction","clickedOnTransformer","transformer_id","updateTransformer","transformerNode","selectedNode","children","isFunded","node","ChangeCenter","threshold1","threshold2","last_offsetY","image","shape_id","command","MovingCenter","target_x","target_y","added_distance","createNewShape","clone","Remove","unshowSelectedShape","showSelectedShape","editText","stageBox","container","getBoundingClientRect","top","getAbsolutePosition","left","size","display","updateText","last_width","last_height","diff_width","diff_height","text","value","$emit","origin","onFocusin","onFocusout","narationHasBeenInitialized","tabindex","_component_v_text","onDblclick","_component_ContextMenu","onChangecenterButton","onDetachshapeButton","onKeepdistanceButton","onCopyButton","onCopyAllButton","onPastButton","onRemoveButton","onRemoveAllButton","$props","ConcernedShape","CopiedShape","pastOneObject","Boolean","menuOfStage","menuOfLine","menuOfGroupedShape","needCopyButton","needPastButton","needCopyAllButton","needSwitchDistributionModeButton","String","dM","displayMenu","cS","GenerateButtonEvent","ContextMenu","slice","DisplayContextMenu","preventDefault","documentElement","scrollTop","scrollLeft","HideContextMenu","Copy","Past","valueOf","clone_positionPoint","shapesg","shapesg_length","clone_shape","destroy","target_positionPoint","index","RemoveAll","toFixed","initialNaration","stopInitialisation","stopPropagation","onKeyup","fontSize","fontFamily","Image","onload","onFocus","CopyAll","corresponding_positionPoint","visible","innerHTML","sentences","textsForNaration","ReificationDemo","ReuseDemo","PolymorphismDemo","PolymorphismSubstrateDemo","ReuseSubstrateDemo","ReificationSubstrateDemo","NarativeBox","updated","elem","getElementsByClassName","scrollHeight","naration","last_origin","last_text","addExplanation","_component_DiscoverabilityDemo","_component_AppropriabilityDemo","_component_ExpressivityDemo","_component_DiscoverabilitySubstrateDemo","_component_AppropriabilitySubstrateDemo","_component_ExpressivitySubstrateDemo","_component_ToolBar","onNeed_new_shape","onEraser_is_selected","_component_CenterMenu","onCenterButton","onMouseover","color","watch","newVal","oldVal","CenterMenu","DisplayCenterMenu","ChangeAlignCenter","align_choice","DetachShapeButtonAction","KeepDistribution","onDragstart","ghosts","neighbour","dist_with_neighbour","eraser","initializeDragging","closestGroupedShape","createGhost","distBtwShapes","shape1","shape2","distFromStartPoint","targetNeighbour","distRight","distLeft","onDragging","distFromStart","dist_btw_shapes","opacity_change","isActivated","changeCursor","controls","_hoisted_1","_hoisted_2","AppropriabilitySubstrateDemo","AppropriabilityDemo","DiscoverabilitySubstrateDemo","DiscoverabilityDemo","ExpressivityDemo","ExpressivitySubstrateDemo","rectangle","circle","triangle","border","box","group","stageConfig","tools","borders","boxes","activateTool","tool","ToolBar","distShapesToCenter","texts_data","updateFreePositionInGrp","ChangeCenterButtonAction","switchStickylineMode","_hoisted_5","_component_BasicAlignmentDemo","_hoisted_7","align_pos","selectShape","alignSelectedShapes","displayButton","hideButton","BasicAlignmentDemo","routes","path","component","IntroductionView","InstrumentalInteraTableView","HCPartnershipsTableView","Playground","router","createRouter","history","createWebHashHistory","createApp","App","use","VueKonva","mount","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","call","m","deferred","O","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","keys","every","n","getter","__esModule","definition","o","defineProperty","enumerable","get","f","chunkId","Promise","all","reduce","promises","u","miniCssF","g","globalThis","Function","obj","prop","prototype","hasOwnProperty","inProgress","dataWebpackPrefix","url","done","script","needAttach","scripts","getElementsByTagName","s","getAttribute","createElement","charset","timeout","nc","setAttribute","onScriptComplete","prev","event","onerror","clearTimeout","doneFns","parentNode","removeChild","forEach","setTimeout","bind","head","appendChild","Symbol","toStringTag","p","createStylesheet","fullhref","resolve","reject","linkTag","rel","onLinkComplete","errorType","realHref","href","err","Error","code","request","findStylesheet","existingLinkTags","tag","dataHref","existingStyleTags","loadStylesheet","installedCssChunks","miniCss","cssChunks","then","installedChunks","installedChunkData","promise","error","loadingEnded","realSrc","message","webpackJsonpCallback","parentChunkLoadingFunction","moreModules","runtime","some","chunkLoadingGlobal","self","__webpack_exports__"],"sourceRoot":""}